---
title: Vectorization
embed-resources: true
editor_options: 
  chunk_output_type: console
---



## Vectorization 

Most mathematical operations in R are vectorized (are automatically applied elementwise)

```{r}
# define x as a vector of integers from 1-4

# multiply x by 2

```


Operations on vectors of the same length are vectorized:

```{r}
# define y as a vector of integers from 6-9

# add x to y

```

Here, each element of `x` was added to its corresponding element of `y`:

```{r}
#| eval: false
x:  1  2  3  4
    +  +  +  +
y:  6  7  8  9
---------------
    7  9 11 13
```


::: {.callout}
## Challenge 1

Make a new column in the `cats` data frame that contains a "calibrated" weight measurement, corresponding to the original weight measurement weight minus 0.5.

Check the head or tail of the data frame to make sure it worked.

To define the `cats` data frame, run

```{r}
cats <- read.csv("data/feline-data.csv")
```


:::





### Comparison operators

Comparison operators applied to a vector will produce a boolean vector

```{r}
# print out x

# check if each entry of x is greater than 2

```








### Functions

Most functions also operate element-wise on vectors:


```{r}
# define a new vector x that contains the integers 1:4

# print out x

# compute the logarithm of x

```


::: {.callout}
## Challenge 2

We're interested in computing the sum of the following sequence of fractions:

```{r, eval=FALSE}
x = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)
```

This would be tedious to type out, and impossible for high values of n.  Use vectorization to compute x when n = 100. 

What is the sum when n = 10,000?

:::






What do you think will happen when we add the following two vectors?

```{r}
x <- c(1, 2, 3)
y <- c(1, 2, 3, 4, 5, 6, 7)
```

```{r}
# compute the sum of x and y

```






The vector `x` was recycled to match the length of vector `y`

```{r}
#| eval: false
x:  1  2  3  1  2  3  1
    +  +  +  +  +  +  +
y:  1  2  3  4  5  6  7
-----------------------
    2  4  6  5  7  9  8
```
:::








## Subsetting vectors using logical operations

Let's consider the following vector:

```{r}
# define a vector `x` with the entries 5.4, 6.2, 7.1, 4.8, 7.5

# set the names to be: a-e

```




We can use a logical vector to subset the `TRUE` entries:

```{r}
# Extract the third and fifth entries of `x` using a logical TRUE/FALSE vector

```





Since comparison operators (e.g. `>`, `<`, `==`) are vectorized we can use them to subset vectors based on a condition:

```{r}
# Compute a vector asking if x is greater than 7

# use this vector to subset x to the entries that are greater than 7

```









## Combining logical conditions

Several operations for combining logical vectors exist in R:

* `a & b`: the "logical AND" operator: returns `TRUE` if both the `a` and `b`
  are `TRUE`.

* `a | b`: the "logical OR" operator: returns `TRUE`, if either `a` or `b`
  (or both) are `TRUE`.

* `!`: the "logical NOT" operator: converts `TRUE` to `FALSE` and `FALSE` to
  `TRUE`. 


### "Or" `|` example:

```{r}
# use `|` to identify which values in x are equal to 5.4 or 7

# use the above logical vector to subset x to just the values 5.4 or 7

```



### "And" `&` example:

What do you think the following code will return?

```{r}
x[(x == 5.4) & (x == 7)]
```




### Equals to `==`

`==` can be used to ask whether a single value--or entries in a vector--are equal to a specified value.

```{r}
# Extract the values of x that are equal to 7.5

```


### "Not" equal to:

`!=` can be used to ask whether a single value--or entries in a vector--are *not* equal to a specified value.

```{r}
# Using !=, extract the values of x that are *not* equal to 5.4 

# Rewrite the above code by negating the entire expression instead:

```




## A warning on the use of `==` to compare with a vector

A cautionary example:

```{r}
# print x

# ask whether x is equal to the vector c(5.4, 4.8, 7.5)

```







What is happening here? **Recycling**







## The in operator `%in%`


To ask which values of `x` are included in the values in another vector:


```{r}
# Using %in% ask which values of `x` are included in 5.4, 4.8, 7

# use this logical vector to subset x to the relevant values

```






We could extract the entries of `x` that are *not* in this vector by preceding the logical expression with a `!`

```{r}
# Using `!` and `%in%` ask which values of x are *not* included in 5.4, 4.8, 7

# use this logical vector to subset `x` to exclude the values 5.4, 4.8, 7

```






::: {.callout}
## Challenge 3

Given the following vector:

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
x
```

Write a subsetting command to return the values in x that are greater than 4 *or* less than 7.

Write another subsetting command to return the values in x that are greater than 4 *and* less than 7.

:::






## Tip: Non-unique names

Multiple elements in a vector can have the same name. 


Let's define the following vector:

```{r}
x <- 1:3
names(x) <- c('a', 'a', 'a')
x
```

What do you think the following code will return?
```{r}
x["a"]
```

What about this code below?
```{r}
x[names(x) == "a"]
```

