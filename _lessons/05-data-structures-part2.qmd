---
title: "Adding/removing data from data frames"
output: html
embed-resources: true
editor_options: 
  chunk_output_type: console
---


In the last lesson, we toured all the basic
data types and data structures in R. Everything you do will be a manipulation of
those tools. But most of the time, the star of the show is the data frame: 
the table that we created by loading information from a csv file. In this lesson, we'll learn a few more things
about working with data frames.

## Adding columns and rows in data frames

We already learned that the columns of a data frame are vectors, so that our
data are consistent in type throughout the columns. As such, if we want to add a
new column, we can start by making a new vector:

```{r, echo = FALSE}
cats <- read.csv("data/feline-data.csv")
```



```{r}
age <- c(2, 3, 5)
cats
```

We can then add this as a column via:

```{r}
cbind(cats, age)
```

Note that if we tried to add a vector of ages with a different number of entries than the number of rows in the data frame, it would fail:

```{r, error=TRUE}
age <- c(2, 3, 5, 12)
cbind(cats, age)

age <- c(2, 3)
cbind(cats, age)
```

Why didn't this work? Of course, R wants to see one element in our new column
for every row in the table:

```{r}
nrow(cats)
length(age)
```

So for it to work we need to have `nrow(cats)` == `length(age)`. Let's overwrite the content of cats with our new data frame.

```{r}
age <- c(2, 3, 5)
cats <- cbind(cats, age)
```

::: {.callout-tip}
## Tip: mutate

In the dplyr lesson, you will learn another method of adding a column to a data frame using the `mutate()` function from the dplyr package in the tidyverse suite.
:::


Now how about adding rows? Since each row is itself a data frame, to add a new row, we need to create a data frame containing the new information.

```{r}
newRow <- data.frame(coat = "tortoiseshell", weight = 3.3, likes_string = TRUE, age = 9)
cats <- rbind(cats, newRow)
cats
```




::: {.callout}
## Challenge 1
Let's imagine that 1 cat year is equivalent to 7 human years.

1. Create a vector called `human_age` by multiplying `cats$age` by 7.
2. Convert `human_age` to a factor.
3. Convert `human_age` back to a numeric vector using the `as.numeric()` function. Now divide it by 7 to get the original ages back. Explain what happened.

::: {.callout collapse=true}
## Solution to Challenge 1

1. `human_age <- cats$age * 7`
2. `human_age <- factor(human_age)`. `as.factor(human_age)` works just as well.
3. `as.numeric(human_age)` yields `1 2 3 4 4` because factors are stored as integers (here, 1:4), each of which is associated with a label (here, 28, 35, 56, and 63). Converting the factor to a numeric vector gives us the underlying integers, not the labels. If we want the original numbers, we need to convert `human_age` to a character vector (using `as.character(human_age)`) and then to a numeric vector (why does this work?). This comes up in real life when we accidentally include a character somewhere in a column of a .csv file supposed to only contain numbers, and set `stringsAsFactors=TRUE` when we read in the data.
:::
:::




## Removing rows by index


```{r}
cats
```

We now know how to add rows and columns to our data frame in R, but how do we *remove* rows. For instance, if we wanted to now *remove* the "tortoiseshell" row, we can ask for a data frame minus this offending row using the `-` syntax:

```{r}
cats[-4, ]
```

Notice the comma with nothing after it to indicate that we want to drop the entire fourth row.

Note: we could also remove both new rows at once by putting the row numbers
inside of a vector using `c()`: `cats[c(-4,-5), ]`


## Removing columns  

We can also remove columns in our data frame. What if we want to remove the column "age". We can remove it by index:


```{r}
cats[, -4]
```

Notice the comma with nothing before it, indicating we want to keep all of the rows.  

However, using the column name syntax doesn't work here:

```{r}
#| error: true
cats[, -"age"]
```


To drop a column using the column name, we can instead use the `%in%` operator. The `%in%` operator goes through each element of its left argument, in this case the names of `cats`, and asks, "Does this element occur in the second argument?"

```{r}
drop <- names(cats) %in% c("age")
cats[, !drop]
```

We will cover subsetting with logical operators like `%in%` in more detail in the next lesson.

## Appending to a data frame

The key to remember when adding data to a data frame is that *columns are vectors and rows are data frames.* We can also glue two data frames
together with `rbind`:

```{r}
cats <- rbind(cats, cats)
cats
```



You can create a new data frame right from within R with the following syntax:

```{r}
df <- data.frame(id = c("a", "b", "c"),
                x = 1:3,
                y = c(TRUE, TRUE, FALSE))
```



::: {.callout}
## Challenge 2

Make a data frame that holds the following information for yourself:

- Your first name
- Your last name
- The year you were born

Then use `rbind` to add an entry for the people sitting beside you.
Finally, use `cbind` to add a column with each person's answer to the question, "Do you like piezza?"

Your final data frame should look something like this:

```{r}
#| echo: false
df <- data.frame(first = c("Grace"),
                last = c("Hopper"),
                year = 1906)
df <- rbind(df, data.frame(first = "Marie", last = "Curie", year = 1867) )
df <- cbind(df, pizza = c(TRUE, FALSE))
df

```


::: {.callout collapse=true}
## Solution to Challenge 2

```{r}
df <- data.frame(first = c("Grace"),
                last = c("Hopper"),
                year = 1906)
df <- rbind(df, data.frame(first = "Marie", last = "Curie", year = 1867) )
df <- cbind(df, pizza = c(TRUE, FALSE))
df
```
:::
:::








## Data example

So far, you have seen the basics of manipulating data frames with our cat data;
now let's use those skills to digest a more realistic dataset. Let's read in the
`gapminder` dataset that we downloaded previously:

```{r}
gapminder <- read.csv("data/gapminder_data.csv")
```

::: {.callout-tip}
## Tip: Loading files from the internet

You can also read in files directly into R from the Internet by replacing the file paths with a web address in `read.csv`. Note that in doing this no local copy of the csv file is first saved onto your computer. For example,

```{r}
#| eval: FALSE
gapminder <- read.csv("<INSERT URL HERE>")
```
:::


::: {.callout-tip}
## Tip: Loading excel files

You can read directly from excel spreadsheets using the [readxl](https://cran.r-project.org/package=readxl) package.
:::

Let's investigate gapminder a bit; the first thing we should always do is check
out what the data looks like with `head()` and `str()`:


```{r}
head(gapminder)
```

```{r}
str(gapminder)
```

An additional method for examining the structure of gapminder is to use the `summary()` function. `summary` yields a numeric, tabular, or descriptive summary of each column. Factor columns are summarized by the number of items in each level, numeric or integer columns by the descriptive statistics (quartiles and mean), and character columns by its length, class, and mode.  

```{r}
summary(gapminder)
```

We can also interrogate the data frame for information about its dimensions;
remembering that `str(gapminder)` said there were 1704 observations of 6
variables in gapminder, what do you think the following will produce, and why?

```{r}
length(gapminder)
```

A fair guess would have been to say that the length of a data frame would be the
number of rows it has (1704), but this is not the case; remember, a data frame
is a *list of vectors*. When `length` gave us 6, it's because gapminder is built out of a list of 6
vectors. To get the number of rows and columns in our dataset, try:

```{r}
nrow(gapminder)
ncol(gapminder)
```

Or, both at once:

```{r}
dim(gapminder)
```

We'll also likely want to know what the titles of all the columns are, so we can
ask for them later:

```{r}
colnames(gapminder)
```

At this stage, it's important to ask ourselves if the structure R is reporting
matches our intuition or expectations; do the basic data types reported for each
column make sense? If not, we need to sort any problems out now before they turn
into bad surprises down the road, using what we've learned about how R
interprets data, and the importance of *strict consistency* in how we record our
data.


::: {.callout}

## Challenge 3
It's good practice to also check the last few lines of your data and some in the middle. How would you do this?
Searching for ones specifically in the middle isn't too hard, but we could ask for a few lines at random. How would you code this?

::: {.callout collapse=true}
## Solution to Challenge 3

To check the last few lines it's relatively simple as R already has a function for this:

```{r}
tail(gapminder)
tail(gapminder, n = 15)
```

What about a few arbitrary rows just in case something is odd in the middle?

## Tip: There are several ways to achieve this.
The solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!

Remember `my_dataframe[rows, cols]` will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don't know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.

```{r}
gapminder[sample(nrow(gapminder), 5), ]
```
:::
:::




::: {.callout}

## Challenge 3
It's good practice to also check the last few lines of your data too. How would you do this?

::: {.callout collapse=true}
## Solution to Challenge 3

To check the last few lines it's relatively simple as R already has a function for this:

```{r}
tail(gapminder)
tail(gapminder, n = 15)
```
:::
:::



::: {.callout}
## Challenge 4

Go to file -> new file -> R script, and write an R script called `load.R` which contains R code that loads the gapminder dataset. Save `load.R` in the `functions/` directory.

Run the script in a chunk in your quarto document using the `source()` function, using the file path as its argument:

```{r}
#| eval: false
source("functions/load.R")
```
:::

