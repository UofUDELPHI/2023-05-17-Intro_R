---
title: Vectorization
embed-resources: true
---

```{r, include=FALSE}
# Silently load in the data so the rest of the lesson works
gapminder <- read.csv("data/gapminder_data.csv")
```


## Vectorization 


Most of R's functions are vectorized, meaning that the function will
operate on all elements of a vector without needing to loop through
and act on each element one at a time. This makes writing code more
concise, easy to read, and less error prone.

For example, applying multiplication to a vector will conduct the operation element-wise:

```{r}
x <- 1:4
x * 2
```

We can also add two vectors together:

```{r}
y <- 6:9
x + y
```

Each element of `x` was added to its corresponding element of `y`:

```{r}
#| eval: false
x:  1  2  3  4
    +  +  +  +
y:  6  7  8  9
---------------
    7  9 11 13
```


::: {.callout}
## Challenge 1

Let's try this on the `pop` column of the `gapminder` dataset.
Make a new column in the `gapminder` data frame that
contains population in units of millions of people.
Check the head or tail of the data frame to make sure
it worked.


::: {.callout collapse=true}
## Solution to challenge 1

Let's try this on the `pop` column of the `gapminder` dataset.
Make a new column in the `gapminder` data frame that
contains population in units of millions of people.
Check the head or tail of the data frame to make sure
it worked.

```{r}
gapminder$pop_millions <- gapminder$pop / 1e6
head(gapminder)
```
:::
:::

Comparison operators, logical operators, and many functions are also
vectorized:


### Comparison operators

Comparison operators applied to a vector will produce a boolean vector

```{r}
x > 2
```


### Functions

Most functions also operate element-wise on vectors:


```{r}
x <- 1:4
log(x)
```


::: {.callout}
## Challenge 4

We're interested in looking at the sum of the
following sequence of fractions:

```{r, eval=FALSE}
x = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)
```

This would be tedious to type out, and impossible for high values of
n.  Use vectorization to compute x when n = 100. What is the sum when
n = 10,000?

::: {.callout collapse=true}
##  Solution to Challenge 4

```{r}
sum(1/(1:100)^2)
sum(1/(1:1e04)^2)
```

We could do this for a general `n` using:

```{r}
n <- 10000
sum(1/(1:n)^2)
```

:::
:::


::: {.callout-tip}
## Tip: Operations on vectors of unequal length

Operations can also be performed on vectors of unequal length, through
a process known as *recycling*. This process automatically repeats the smaller vector 
until it matches the length of the larger vector. R will provide a warning
if the larger vector is not a multiple of the smaller vector.

```{r}
x <- c(1, 2, 3)
y <- c(1, 2, 3, 4, 5, 6, 7)
x + y
```

Vector `x` was recycled to match the length of vector `y`

```{r, eval=FALSE}
x:  1  2  3  1  2  3  1
    +  +  +  +  +  +  +
y:  1  2  3  4  5  6  7
-----------------------
    2  4  6  5  7  9  8
```
:::

## Subsetting


Let's start with the workhorse of R: a simple numeric vector.

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
x
```


So now that we've created a toy vector to play with, how do we get at its
contents?

## Accessing elements using their indices

To extract elements of a vector we can give their corresponding index, starting
from one:

```{r}
x[1]
```

```{r}
x[4]
```

The square brackets operator is a function. For vectors, it means "get me the nth element".

We can ask for multiple elements at once by providing a vector if indices:

```{r}
x[c(1, 3)]
```

Or "slices" of the vector using a sequential integer vector index:

```{r}
x[1:4]
```

Recall that the `:` operator creates a sequence of numbers from the left element to the right.
```{r}
1:4
c(1, 2, 3, 4)
```


We can ask for the same element multiple times:

```{r}
x[c(1,1,3)]
```

If we ask for an index beyond the length of the vector, R will return a missing value:
```{r}
x[6]
```

This is a vector of length one containing an `NA`, whose name is also `NA`.

If we ask for the 0th element, we get an empty vector:

```{r}
x[0]
```

::: {.callout-tip}
## Vector numbering in R starts at 1

In many programming languages (C and Python, for example), the first
element of a vector has an index of 0. In R, the first element is 1.
:::

## Skipping and removing elements

If we use a negative number as the index of a vector, R will return
every element *except* for the one specified:

```{r}
x[-2]
```

We can skip multiple elements:

```{r}
x[c(-1, -5)]  # or x[-c(1,5)]
```

::: {.callout-tip}

## Order of operations


A common trip up for novices occurs when trying to skip
slices of a vector. It's natural to try to negate a
sequence like so:

```{r, error=TRUE, eval=FALSE}
x[-1:3]
```

This gives a somewhat cryptic error:

```{r, error=TRUE, echo=FALSE}
x[-1:3]
```

But remember the order of operations. `:` is really a function.
It takes its first argument as -1, and its second as 3,
so generates the sequence of numbers: `c(-1, 0, 1, 2, 3)`.
The correct solution is to wrap that function call in brackets, so
that the `-` operator applies to the result:

```{r}
x[-(1:3)]
```
:::


To remove elements from a vector, we need to re-assign the variable to our result:

```{r}
x <- x[-4]
x
```

::: {.callout}
## Challenge 1

Given the following code:
```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Come up with at least 2 different commands that will produce the following output:

```{r, echo=FALSE}
x[2:4]
```

After you find 2 different commands, compare notes with your neighbour. Did you have different strategies?

::: {.callout collapse=true}
## Solution to challenge 1

```{r}
x[2:4]
```

```{r}
x[-c(1, 5)]
```

```{r}
x[c(2, 3, 4)]
```

```{r}
x[c("b", "c", "d")]
```
:::

:::

## Subsetting by name

We can extract elements by using their name, instead of extracting by index:

```{r}
x <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we can name a vector 'on the fly'
x[c("a", "c")]
```

This is usually a much more reliable way to subset objects: the
position of various elements can often change when chaining together
subsetting operations, but the names will always remain the same!

## Subsetting through other logical operations <a name="logical-operations"></a>

We can also use any logical vector to subset:

```{r}
x[c(FALSE, FALSE, TRUE, FALSE, TRUE)]
```

Since comparison operators (e.g. `>`, `<`, `==`) evaluate to logical vectors, we can also
use them to succinctly subset vectors: the following statement gives
the same result as the previous one.

```{r}
x[x > 7]
```

Breaking it down, this statement first evaluates `x>7`, generating
a logical vector `c(FALSE, FALSE, TRUE, FALSE, TRUE)`, and then
selects the elements of `x` corresponding to the `TRUE` values.

We can use `==` to mimic the previous method of indexing by name
(remember you have to use `==` rather than `=` for comparisons):

```{r}
names(x) == "a"
x[names(x) == "a"]
```


## Combining logical conditions

We often want to combine multiple logical
criteria. For example, we might want to find all the countries that are
located in Asia **or** Europe **and** have life expectancies within a certain
range. Several operations for combining logical vectors exist in R:

* `&`, the "logical AND" operator: returns `TRUE` if both the left and right
  are `TRUE`.

* `|`, the "logical OR" operator: returns `TRUE`, if either the left or right
  (or both) are `TRUE`.

You may sometimes see `&&` and `||` instead of `&` and `|`. These two-character operators
only look at the first element of each vector and ignore the
remaining elements. In general you should not use the two-character
operators in data analysis.

* `!`, the "logical NOT" operator: converts `TRUE` to `FALSE` and `FALSE` to
  `TRUE`. It can negate a single logical condition (eg `!TRUE` becomes
  `FALSE`), or a whole vector of conditions(eg `!c(TRUE, FALSE)` becomes
  `c(FALSE, TRUE)`).

Additionally, you can compare the elements within a single vector using the
`all` function (which returns `TRUE` if every element of the vector is `TRUE`)
and the `any` function (which returns `TRUE` if one or more elements of the
vector are `TRUE`).

For example, the following code will only return the values of `x` that are equal to either 5.4 or 7 (since there is no value equal to 7, only the value equal to 5.4 will be returned):

```{r}
(x == 5.4) | (x == 7)

x[(x == 5.4) | (x == 7)]
```




## The in operator `%in%`


Another way to do this is to ask R to subset the values of `x` that are "in" a vector of values.


```{r}
x %in% c(5.4, 7)

x[x %in% c(5.4, 7)]
```

::: {.callout-tip}
## Tip: Getting help for operators

Remember you can search for help on operators by wrapping them in quotes:
`help("%in%")` or `?"%in%"`.
:::


::: {.callout}
## Challenge 2

Given the following code:

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```
Write a subsetting command to return the values in x that are greater than 4 and less than 7.

::: {.callout collapse=true}
## Solution to challenge 2

```{r}
x[x < 7 & x > 4]
```
:::
:::


::: {.callout-tip}

## Tip: Non-unique names

It is possible for multiple elements in a vector to have the same name. (For a data frame, columns can have
the same name too.) Consider these examples:

```{r}
x <- 1:3
x
names(x) <- c('a', 'a', 'a')
x
x['a']  # only returns first value
x[names(x) == 'a']  # returns all three values
```
:::


## Removing named elements

Removing named elements is a little harder. If we try to remove one named element by negating the string, R complains (slightly obscurely) that it doesn't know how to take the negative of a string:

```{r}
#| error: true
x <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we start again by naming a vector 'on the fly'
x[-"a"]
```

However, we can use the `!=` (not-equals) operator to construct a logical vector that will do what we want:

```{r}
x[names(x) != "a"]
```

Skipping multiple named indices is a little bit harder still. Suppose we want to drop the `"a"` and `"c"` elements, so we try this:

```{r}
x[names(x) != c("a", "c")]
```

R did *something*, but it gave us a warning that we ought to pay attention to - and it apparently *gave us the wrong answer* (the `"c"` element is still included in the vector)!

So what does `!=` actually do in this case? That's an excellent question.

### Recycling

Let's take a look at the comparison component of this code:

```{r}
names(x) != c("a", "c")
```

Why does R give `TRUE` as the third element of this vector, when `names(x)[3] != "c"` is obviously false?
When you use `!=`, R tries to compare each element
of the left argument with the corresponding element of its right
argument. What happens when you compare vectors of different lengths?

![Inequality testing](figs/06-rmd-inequality.1.png)

When one vector is shorter than the other, it gets *recycled*:

![Inequality testing: results of recycling](figs/06-rmd-inequality.2.png)

In this case R **repeats** `c("a", "c")` as many times as necessary to match `names(x)`, i.e. we get `c("a","c","a","c","a")`. Since the recycled `"a"`
doesn't match the third element of `names(x)`, the value of `!=` is `TRUE`.
Because in this case the longer vector length (5) isn't a multiple of the shorter vector length (2), R printed a warning message. If we had been unlucky and `names(x)` had contained six elements, R would *silently* have done the wrong thing (i.e., not what we intended it to do). This recycling rule can can introduce hard-to-find and subtle bugs!

The way to get R to do what we really want (match *each* element of the left argument with *all* of the elements of the right argument) it to use the `%in%` operator. The `%in%` operator goes through each element of its left argument, in this case the names of `x`, and asks, "Does this element occur in the second argument?". Here, since we want to *exclude* values, we also need a `!` operator to change "in" to "not in":

```{r}
x[!(names(x) %in% c("a", "c"))]
```
