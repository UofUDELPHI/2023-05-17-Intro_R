[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Carpentry R Workshop",
    "section": "",
    "text": "Introduction\nWorkshop homepage\nThis page contains the content for the R Software Carpentry workshop taught at the University of Utah on May 17-18.\nInstructors: Rebecca Barter, George Vega Yon\nThese materials on this page have been adapted from the original Software Carpentry R for Reproducible Scientific Analysis workshop."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "01-rstudio-quarto.html#motivation",
    "href": "01-rstudio-quarto.html#motivation",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.1 Motivation",
    "text": "1.1 Motivation\nScience is a multi-step process: once you’ve designed an experiment and collected data, the real fun begins! This lesson will teach you how to start this process using R and RStudio. We will begin with raw data, perform exploratory analyses, and learn how to plot results graphically. This example starts with a dataset from gapminder.org containing population information for many countries through time. Can you read the data into R? Can you plot the population for Senegal? Can you calculate the average income for countries on the continent of Asia? By the end of these lessons you will be able to do things like plot the populations for all of these countries in under a minute!"
  },
  {
    "objectID": "01-rstudio-quarto.html#before-starting-the-workshop",
    "href": "01-rstudio-quarto.html#before-starting-the-workshop",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.2 Before Starting The Workshop",
    "text": "1.2 Before Starting The Workshop\nPlease ensure you have the latest version of R, RStudio, and Quarto installed on your machine, or that you are set up with Posit cloud (in which case everything will be installed for you). If you are having trouble installing any of the software on your local machine, we recommend that you use the Posit cloud instance that we have set up.\nNote that if you are working locally, we recommend re-installing R, RStudio, and Quarto to ensure that you have the latest version, as some features and packages used in the workshop may not work correctly (or at all) if your R, RStudio, and quarto are not up to date.\n\nDownload and install the latest version of R here\nDownload and install RStudio here\nDownload and install Quarto here"
  },
  {
    "objectID": "01-rstudio-quarto.html#introduction-to-rstudio",
    "href": "01-rstudio-quarto.html#introduction-to-rstudio",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.3 Introduction to RStudio",
    "text": "1.3 Introduction to RStudio\nThroughout this lesson, we’re going to teach you some of the fundamentals of the R language as well as some best practices for organizing code for scientific projects that will make your life easier.\nWe’ll be using RStudio: a free, open-source R Integrated Development Environment (IDE). It provides a built-in editor, works on all platforms (including on servers) and provides many advantages such as integration with version control and project management.\nBasic layout\nWhen you first open RStudio, you will be greeted by three panels:\n\nThe interactive R console/Terminal (entire left)\nEnvironment/History/Connections (tabbed in upper right)\nFiles/Plots/Packages/Help/Viewer (tabbed in lower right)\n\n\n\n\nRStudio layout\n\n\nOnce you open files, such as R scripts or quarto documents, an editor panel will also open in the top left.\n\n\n\nRStudio layout with .R file open"
  },
  {
    "objectID": "01-rstudio-quarto.html#quarto-documents",
    "href": "01-rstudio-quarto.html#quarto-documents",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.4 Quarto documents",
    "text": "1.4 Quarto documents\n\n\n\n\n\n\nQuarto documents\n\n\n\nIn this workshop, we will be saving our code in “quarto” documents (formerly R markdown documents). Quarto documents let us combine text, code, and output (such as plots and tables) into an html or pdf file. Quarto files have .qmd at the end of their names.\n\n\nQuarto documents (like their predecessor, R Markdown documents) allow you to combine text and code, so that rather than having your code standing alone in its own file, your code and its output can instead lie nestled in between narrative text that describes the analysis that you’re conducting and summarizes the results. Quarto documents are mind-blowingly versatile, and while they are mostly used to create simple html or pdf documents, they can also be used to make websites, blog posts, and books!\nSince we want to practice reproducible data science, it is important that we keep detailed records of the code that we wrote which led us to our data-driven answers. Quarto provides us with an easy way of doing that, plus since you can surround your code with text narrative, it can be used to communicate your analysis and results to other people: Quarto lets us feed two birds with one seed!\nTo start a new quarto document:\n\nHit the “New file” icon with a green plus in the top-right-hand corner of the RStudio application and select “Quarto document”. The following window should pop up:\n\n\n\n\n\n\n\nChoose a title (e.g., “My first quarto document”), and make yourself the author.\nSelect the HTML output option.\nSelect the “knitr” engine from the drop-down menu.\nUn-check “Use visual markdown editor” (if it is checked).\nHit the “Create” button to create your file.\n\nThis will open up a new quarto template document in the documents panel:\n\n\n\n\n\n\n1.4.1 Rendering quarto documents\nThe quarto file that you’ve just created contains a very brief summary of how quarto documents work. Note the instructions “When you click the Render button a document will be generated that includes both content and the output of embedded code.”\nIf you hit “Render” button while your quarto document is open, you should see that some code appeared very quickly in your console panel and your web browser opened up with a new (html) webpage titled “My first quarto document” that looks like this:\n\n\n\n\n\nIf you’re using RStudio in the cloud (or you have different settings to me), you may have instead found that the window opened in the “Viewer” panel of your RStudio application. If no window opened anywhere, find the analysis.html file on your computer that was created when you hit “Render”, and open it in your web browser.\nHitting the “Render” button “renders” your interactive quarto (.qmd) document as a static html (.html) file. This is like saving your interactive word document file as a static pdf file. Compare the original quarto (.qmd) document with the rendered web-browser page (.html). If you’re viewing the .qmd file in visual mode, they should look fairly similar.\n\n\n\n\n\n\nSimplifying quarto output files\n\n\n\nWhen you compile quarto document, you will find that a number of superfluous files are created in a xx_files/ folder, and this folder is required for the .html output to be rendered properly (i.e., the formatting in the .html file will be lost if you separate the .html output file from the xx_files/ folder).\nYou can fix this by “embedding” these resource files inside the rendered html output document by specifying embed-resources: true in the “yaml” (document settings) at the top of the quarto document.\n---\ntitle: \"Introduction to R and RStudio\"\noutput: html\nembed-resources: true\n---\nWith this option, the xx_files/ folder will no longer be created and the html file will be properly rendered as a stand-alone file.\n\n\n\n1.4.1.1 Markdown text\nBased on the html output, let’s try to make some sense of the syntax used in the original quarto (.qmd) document. The text in a quarto document uses markdown syntax.\nCan you figure out what the ## syntax does (if you can’t see the ## syntax, ensure that you are viewing the quarto document using “Source” rather than “Visual” in the top-right corner of the document)? The pound symbols are markdown syntax for creating headers: # will create a top-level header, ## will create a level-2 header, ### will create a level-3 header, etc.\nNotice that the word “Render” is shown in bold in the rendered html file. By looking at the .qmd file, can you figure out what the markdown syntax is for creating bold-face text?\nTo learn more about markdown syntax, see https://www.markdownguide.org/basic-syntax/."
  },
  {
    "objectID": "01-rstudio-quarto.html#writing-code-in-quarto-documents",
    "href": "01-rstudio-quarto.html#writing-code-in-quarto-documents",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.5 Writing code in quarto documents",
    "text": "1.5 Writing code in quarto documents\n\n1.5.1 Code chunks\nAt this stage, much of quarto’s power (like its predecessor, R Markdown) lies in combining text with “code chunks”. Take a look at your analysis.qmd file. This file already contains two code chunks indicated by the following syntax:\n```{r}\n\n```\n```{r} tells quarto that you’re beginning an R “code chunk”, i.e., you’re about to write some R code, and ``` tells quarto that you’re done with R and are going back to writing regular (markdown) text.\nNote in the compiled markdown document, this R code chunk rendered as:\n\n1 + 1\n\n[1] 2\n\n\nIn the rendered html file, the output ([1] 2) of the R code being evaluated (1 + 1) is shown below the code itself (note also that while the code is shown in the html output, the backtick syntax is hidden).\nWhy is there a [1] before the output ([1] 2)? This is just specifying that 2 is the first “entry” of the output.\nNote that in the second code chunk, there is a “code chunk option” specified: #| echo: false .\n```{r}\n#| echo: false\n2 * 2\n```\nThis #| syntax at the beginning of a code chunk corresponds to various options for when the code chunk is “rendered” into html (or pdf).\nBy looking at the output html file, can you figure out what #| echo: false does?\nIt hides the code from the html output file, while still showing the output ([1] 4). Sometimes, depending on the type of document you’re creating and who your intended audience is, it is often helpful to hide the code, but still show the output (e.g., figures or tables) of your R code in the document.\n\n\n1.5.2 Code comments\nNote that another use of the # symbol in an R code chunk is as a code comment (in this case, # will not be followed by |). Code comments will be shown with your code chunk but don’t do anything other than add some text alongside your code, which is often helpful for explaining what a piece of code is doing when it’s not obvious.\n\n\n[1] 4"
  },
  {
    "objectID": "01-rstudio-quarto.html#the-console",
    "href": "01-rstudio-quarto.html#the-console",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.6 The console",
    "text": "1.6 The console\nRather than compiling your quarto document every time you want to look at the output of the code in your quarto document, you can instead run individual chunks of your code in the R console.\n\n\n\n\n\n\nTip: Running segments of your code in the console\n\n\n\nRStudio offers you great flexibility in running code from within the editor window. There are buttons, menu choices, and keyboard shortcuts. To run the current line of code inside a code chunk, you can 1. click on the Run button above the editor panel, or 2. select “Run Lines” from the “Code” menu, or 3. hit Ctrl+Return in Windows or Linux or ⌘+Return on OS X. (This shortcut can also be seen by hovering the mouse over the button).\n\n\nThe first thing you will see in the R console (interactive session) is a bunch of information, followed by a “>” and a blinking cursor. In many ways this is similar to the shell environment you learned about during the shell lessons: it operates on the same idea of a “Read, evaluate, print loop”: you type in commands, R tries to execute them, and then returns a result.\nIf you type in an incomplete command, R will wait for you to complete it. If you are familiar with Unix Shell’s bash, you may recognize this\nbehavior from bash.\n\n\n\n\n\nAny time you hit return and the R session shows a “+” instead of a “>”, it means it’s waiting for you to complete the command. If you want to cancel a command you can hit Esc and RStudio will give you back the “>” prompt.\n\n\n\n\n\n\nTip: Canceling commands\n\n\n\nIf you’re using R from the command line instead of from within RStudio, you need to use Ctrl+C instead of Esc to cancel the command. This applies to Mac users as well! Canceling a command isn’t only useful for killing incomplete commands: you can also use it to tell R to stop running code (for example if it’s taking much longer than you expect), or to get rid of the code you’re currently writing."
  },
  {
    "objectID": "05-data-structures-part2.html#adding-columns-and-rows-in-data-frames",
    "href": "05-data-structures-part2.html#adding-columns-and-rows-in-data-frames",
    "title": "5  Adding/removing data from data frames",
    "section": "5.1 Adding columns and rows in data frames",
    "text": "5.1 Adding columns and rows in data frames\nWe already learned that the columns of a data frame are vectors, so that our data are consistent in type throughout the columns. As such, if we want to add a new column, we can start by making a new vector:\n\n\n\n\nage <- c(2, 3, 5)\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\nWe can then add this as a column via:\n\ncbind(cats, age)\n\n    coat weight likes_string age\n1 calico    2.1            1   2\n2  black    5.0            0   3\n3  tabby    3.2            1   5\n\n\nNote that if we tried to add a vector of ages with a different number of entries than the number of rows in the data frame, it would fail:\n\nage <- c(2, 3, 5, 12)\ncbind(cats, age)\n\nError in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 3, 4\n\nage <- c(2, 3)\ncbind(cats, age)\n\nError in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 3, 2\n\n\nWhy didn’t this work? Of course, R wants to see one element in our new column for every row in the table:\n\nnrow(cats)\n\n[1] 3\n\nlength(age)\n\n[1] 2\n\n\nSo for it to work we need to have nrow(cats) == length(age). Let’s overwrite the content of cats with our new data frame.\n\nage <- c(2, 3, 5)\ncats <- cbind(cats, age)\n\n\n\n\n\n\n\nTip: mutate\n\n\n\nIn the dplyr lesson, you will learn another method of adding a column to a data frame using the mutate() function from the dplyr package in the tidyverse suite.\n\n\nNow how about adding rows? Since each row is itself a data frame, to add a new row, we need to create a data frame containing the new information.\n\nnewRow <- data.frame(coat = \"tortoiseshell\", weight = 3.3, likes_string = TRUE, age = 9)\ncats <- rbind(cats, newRow)\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4 tortoiseshell    3.3            1   9\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nLet’s imagine that 1 cat year is equivalent to 7 human years.\n\nCreate a vector called human_age by multiplying cats$age by 7.\nConvert human_age to a factor.\nConvert human_age back to a numeric vector using the as.numeric() function. Now divide it by 7 to get the original ages back. Explain what happened.\n\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\nhuman_age <- cats$age * 7\nhuman_age <- factor(human_age). as.factor(human_age) works just as well.\nas.numeric(human_age) yields 1 2 3 4 4 because factors are stored as integers (here, 1:4), each of which is associated with a label (here, 28, 35, 56, and 63). Converting the factor to a numeric vector gives us the underlying integers, not the labels. If we want the original numbers, we need to convert human_age to a character vector (using as.character(human_age)) and then to a numeric vector (why does this work?). This comes up in real life when we accidentally include a character somewhere in a column of a .csv file supposed to only contain numbers, and set stringsAsFactors=TRUE when we read in the data."
  },
  {
    "objectID": "05-data-structures-part2.html#factors",
    "href": "05-data-structures-part2.html#factors",
    "title": "5  Adding/removing data from data frames",
    "section": "5.2 Factors",
    "text": "5.2 Factors\nFor an object containing the data type factor, each different value represents what is called a level. In our case, the factor “coat” has 3 levels: “black”, “calico”, and “tabby”. R will only accept values that match one of the levels. If you add a new value, it will become NA.\nThe warning is telling us that we unsuccessfully added “tortoiseshell” to our coat factor, but 3.3 (a numeric), TRUE (a logical), and 9 (a numeric) were successfully added to weight, likes_string, and age, respectively, since those variables are not factors. To successfully add a cat with a “tortoiseshell” coat, add “tortoiseshell” as a possible level of the factor:\n\nlevels(cats$coat)\n\n[1] \"black\"         \"calico\"        \"tabby\"         \"tortoiseshell\"\n\nlevels(cats$coat) <- c(levels(cats$coat), \"tortoiseshell\")\ncats <- rbind(cats, list(\"tortoiseshell\", 3.3, TRUE, 9))\n\nAlternatively, we can change a factor into a character vector; we lose the handy categories of the factor, but we can subsequently add any word we want to the column without babysitting the factor levels:\n\nstr(cats)\n\n'data.frame':   5 obs. of  4 variables:\n $ coat        : Factor w/ 4 levels \"black\",\"calico\",..: 2 1 3 4 4\n $ weight      : num  2.1 5 3.2 3.3 3.3\n $ likes_string: int  1 0 1 1 1\n $ age         : num  2 3 5 9 9\n\ncats$coat <- as.character(cats$coat)\nstr(cats)\n\n'data.frame':   5 obs. of  4 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\" \"tortoiseshell\" ...\n $ weight      : num  2.1 5 3.2 3.3 3.3\n $ likes_string: int  1 0 1 1 1\n $ age         : num  2 3 5 9 9\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nLet’s imagine that 1 cat year is equivalent to 7 human years.\n\nCreate a vector called human_age by multiplying cats$age by 7.\nConvert human_age to a factor.\nConvert human_age back to a numeric vector using the as.numeric() function. Now divide it by 7 to get the original ages back. Explain what happened.\n\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\nhuman_age <- cats$age * 7\nhuman_age <- factor(human_age). as.factor(human_age) works just as well.\nas.numeric(human_age) yields 1 2 3 4 4 because factors are stored as integers (here, 1:4), each of which is associated with a label (here, 28, 35, 56, and 63). Converting the factor to a numeric vector gives us the underlying integers, not the labels. If we want the original numbers, we need to convert human_age to a character vector (using as.character(human_age)) and then to a numeric vector (why does this work?). This comes up in real life when we accidentally include a character somewhere in a column of a .csv file supposed to only contain numbers, and set stringsAsFactors=TRUE when we read in the data."
  },
  {
    "objectID": "05-data-structures-part2.html#removing-rows",
    "href": "05-data-structures-part2.html#removing-rows",
    "title": "5  Adding/removing data from data frames",
    "section": "5.3 Removing rows",
    "text": "5.3 Removing rows\nWe now know how to add rows and columns to our data frame in R—but in our first attempt to add a “tortoiseshell” cat to the data frame we have accidentally added a garbage row:\n\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4 tortoiseshell    3.3            1   9\n5 tortoiseshell    3.3            1   9\n\n\nWe can ask for a data frame minus this offending row:\n\ncats[-4, ]\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n5 tortoiseshell    3.3            1   9\n\n\nNotice the comma with nothing after it to indicate that we want to drop the entire fourth row.\nNote: we could also remove both new rows at once by putting the row numbers inside of a vector using c(): cats[c(-4,-5), ]"
  },
  {
    "objectID": "05-data-structures-part2.html#removing-columns",
    "href": "05-data-structures-part2.html#removing-columns",
    "title": "5  Adding/removing data from data frames",
    "section": "5.3 Removing columns",
    "text": "5.3 Removing columns\nWe can also remove columns in our data frame. What if we want to remove the column “age”. We can remove it by index:\n\ncats[, -4]\n\n           coat weight likes_string\n1        calico    2.1            1\n2         black    5.0            0\n3         tabby    3.2            1\n4 tortoiseshell    3.3            1\n\n\nNotice the comma with nothing before it, indicating we want to keep all of the rows.\nHowever, using the column name syntax doesn’t work here:\n\ncats[, -\"age\"]\n\nError in -\"age\": invalid argument to unary operator\n\n\nTo drop a column using the column name, we can instead use the %in% operator. The %in% operator goes through each element of its left argument, in this case the names of cats, and asks, “Does this element occur in the second argument?”\n\ndrop <- names(cats) %in% c(\"age\")\ncats[, !drop]\n\n           coat weight likes_string\n1        calico    2.1            1\n2         black    5.0            0\n3         tabby    3.2            1\n4 tortoiseshell    3.3            1\n\n\nWe will cover subsetting with logical operators like %in% in more detail in the next lesson."
  },
  {
    "objectID": "05-data-structures-part2.html#appending-to-a-data-frame",
    "href": "05-data-structures-part2.html#appending-to-a-data-frame",
    "title": "5  Adding/removing data from data frames",
    "section": "5.4 Appending to a data frame",
    "text": "5.4 Appending to a data frame\nThe key to remember when adding data to a data frame is that columns are vectors and rows are data frames. We can also glue two data frames together with rbind:\n\ncats <- rbind(cats, cats)\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4 tortoiseshell    3.3            1   9\n5        calico    2.1            1   2\n6         black    5.0            0   3\n7         tabby    3.2            1   5\n8 tortoiseshell    3.3            1   9\n\n\nYou can create a new data frame right from within R with the following syntax:\n\ndf <- data.frame(id = c(\"a\", \"b\", \"c\"),\n                x = 1:3,\n                y = c(TRUE, TRUE, FALSE))\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nMake a data frame that holds the following information for yourself:\n\nYour first name\nYour last name\nThe year you were born\n\nThen use rbind to add an entry for the people sitting beside you. Finally, use cbind to add a column with each person’s answer to the question, “Do you like piezza?”\nYour final data frame should look something like this:\n\n\n  first   last year pizza\n1 Grace Hopper 1906  TRUE\n2 Marie  Curie 1867 FALSE\n\n\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\ndf <- data.frame(first = c(\"Grace\"),\n                last = c(\"Hopper\"),\n                year = 1906)\ndf <- rbind(df, data.frame(first = \"Marie\", last = \"Curie\", year = 1867) )\ndf <- cbind(df, pizza = c(TRUE, FALSE))\ndf\n\n  first   last year pizza\n1 Grace Hopper 1906  TRUE\n2 Marie  Curie 1867 FALSE"
  },
  {
    "objectID": "05-data-structures-part2.html#realistic-example",
    "href": "05-data-structures-part2.html#realistic-example",
    "title": "5  Exploring Data Frames",
    "section": "5.6 Realistic example",
    "text": "5.6 Realistic example\nSo far, you have seen the basics of manipulating data frames with our cat data; now let’s use those skills to digest a more realistic dataset. Let’s read in the gapminder dataset that we downloaded previously:\n\ngapminder <- read.csv(\"data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\n\n\n\n\n\n\nMiscellaneous Tips\n\n\n\n\nAnother type of file you might encounter are tab-separated value files (.tsv). To specify a tab as a separator, use \"\\\\t\" or read.delim().\nFiles can also be downloaded directly from the Internet into a local folder of your choice onto your computer using the download.file function.\n\nThe read.csv function can then be executed to read the downloaded file from the download location, for example,\n\ndownload.file(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv\", destfile = \"data/gapminder_data.csv\")\ngapminder <- read.csv(\"data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\n\nAlternatively, you can also read in files directly into R from the Internet by replacing the file paths with a web address in read.csv. One should note that in doing this no local copy of the csv file is first saved onto your computer. For example,\n\n\ngapminder <- read.csv(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\n\nYou can read directly from excel spreadsheets without converting them to plain text first by using the readxl package.\n\n\n\nLet’s investigate gapminder a bit; the first thing we should always do is check out what the data looks like with str:\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\nAn additional method for examining the structure of gapminder is to use the summary function. This function can be used on various objects in R. For data frames, summary yields a numeric, tabular, or descriptive summary of each column. Factor columns are summarized by the number of items in each level, numeric or integer columns by the descriptive statistics (quartiles and mean), and character columns by its length, class, and mode.\n\nsummary(gapminder$country)\n\n             Afghanistan                  Albania                  Algeria \n                      12                       12                       12 \n                  Angola                Argentina                Australia \n                      12                       12                       12 \n                 Austria                  Bahrain               Bangladesh \n                      12                       12                       12 \n                 Belgium                    Benin                  Bolivia \n                      12                       12                       12 \n  Bosnia and Herzegovina                 Botswana                   Brazil \n                      12                       12                       12 \n                Bulgaria             Burkina Faso                  Burundi \n                      12                       12                       12 \n                Cambodia                 Cameroon                   Canada \n                      12                       12                       12 \nCentral African Republic                     Chad                    Chile \n                      12                       12                       12 \n                   China                 Colombia                  Comoros \n                      12                       12                       12 \n         Congo Dem. Rep.               Congo Rep.               Costa Rica \n                      12                       12                       12 \n           Cote d'Ivoire                  Croatia                     Cuba \n                      12                       12                       12 \n          Czech Republic                  Denmark                 Djibouti \n                      12                       12                       12 \n      Dominican Republic                  Ecuador                    Egypt \n                      12                       12                       12 \n             El Salvador        Equatorial Guinea                  Eritrea \n                      12                       12                       12 \n                Ethiopia                  Finland                   France \n                      12                       12                       12 \n                   Gabon                   Gambia                  Germany \n                      12                       12                       12 \n                   Ghana                   Greece                Guatemala \n                      12                       12                       12 \n                  Guinea            Guinea-Bissau                    Haiti \n                      12                       12                       12 \n                Honduras          Hong Kong China                  Hungary \n                      12                       12                       12 \n                 Iceland                    India                Indonesia \n                      12                       12                       12 \n                    Iran                     Iraq                  Ireland \n                      12                       12                       12 \n                  Israel                    Italy                  Jamaica \n                      12                       12                       12 \n                   Japan                   Jordan                    Kenya \n                      12                       12                       12 \n         Korea Dem. Rep.               Korea Rep.                   Kuwait \n                      12                       12                       12 \n                 Lebanon                  Lesotho                  Liberia \n                      12                       12                       12 \n                   Libya               Madagascar                   Malawi \n                      12                       12                       12 \n                Malaysia                     Mali               Mauritania \n                      12                       12                       12 \n               Mauritius                   Mexico                 Mongolia \n                      12                       12                       12 \n              Montenegro                  Morocco               Mozambique \n                      12                       12                       12 \n                 Myanmar                  Namibia                    Nepal \n                      12                       12                       12 \n             Netherlands              New Zealand                Nicaragua \n                      12                       12                       12 \n                   Niger                  Nigeria                   Norway \n                      12                       12                       12 \n                    Oman                 Pakistan                   Panama \n                      12                       12                       12 \n                 (Other) \n                     516 \n\n\nAlong with the str() and summary() functions, we can examine individual columns of the data frame with our class() function:\n\nclass(gapminder$year)\n\n[1] \"integer\"\n\nclass(gapminder$country)\n\n[1] \"factor\"\n\nstr(gapminder$country)\n\n Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n\nWe can also interrogate the data frame for information about its dimensions; remembering that str(gapminder) said there were 1704 observations of 6 variables in gapminder, what do you think the following will produce, and why?\n\nlength(gapminder)\n\n[1] 6\n\n\nA fair guess would have been to say that the length of a data frame would be the number of rows it has (1704), but this is not the case; remember, a data frame is a list of vectors and factors. When length gave us 6, it’s because gapminder is built out of a list of 6 columns. To get the number of rows and columns in our dataset, try:\n\nnrow(gapminder)\n\n[1] 1704\n\nncol(gapminder)\n\n[1] 6\n\n\nOr, both at once:\n\ndim(gapminder)\n\n[1] 1704    6\n\n\nWe’ll also likely want to know what the titles of all the columns are, so we can ask for them later:\n\ncolnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nAt this stage, it’s important to ask ourselves if the structure R is reporting matches our intuition or expectations; do the basic data types reported for each column make sense? If not, we need to sort any problems out now before they turn into bad surprises down the road, using what we’ve learned about how R interprets data, and the importance of strict consistency in how we record our data.\nOnce we’re happy that the data types and structures seem reasonable, it’s time to start digging into our data proper. Check out the first few lines:\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nIt’s good practice to also check the last few lines of your data and some in the middle. How would you do this? Searching for ones specifically in the middle isn’t too hard, but we could ask for a few lines at random. How would you code this?\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nTo check the last few lines it’s relatively simple as R already has a function for this:\n\ntail(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\ntail(gapminder, n = 15)\n\n      country year      pop continent lifeExp gdpPercap\n1690   Zambia 1997  9417789    Africa  40.238 1071.3538\n1691   Zambia 2002 10595811    Africa  39.193 1071.6139\n1692   Zambia 2007 11746035    Africa  42.384 1271.2116\n1693 Zimbabwe 1952  3080907    Africa  48.451  406.8841\n1694 Zimbabwe 1957  3646340    Africa  50.469  518.7643\n1695 Zimbabwe 1962  4277736    Africa  52.358  527.2722\n1696 Zimbabwe 1967  4995432    Africa  53.995  569.7951\n1697 Zimbabwe 1972  5861135    Africa  55.635  799.3622\n1698 Zimbabwe 1977  6642107    Africa  57.674  685.5877\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\n\nWhat about a few arbitrary rows just in case something is odd in the middle?\n\n5.7 Tip: There are several ways to achieve this.\nThe solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!\nRemember my_dataframe[rows, cols] will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don’t know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.\n\ngapminder[sample(nrow(gapminder), 5), ]\n\n         country year      pop continent lifeExp gdpPercap\n1648     Vietnam 1967 39463910      Asia  47.838  637.1233\n1419       Spain 1962 31158061    Europe  69.690 5693.8439\n473  El Salvador 1972  3790903  Americas  58.207 4520.2460\n623       Guinea 2002  8807818    Africa  53.676  945.5836\n285        Chile 1992 13572994  Americas  74.126 7596.1260\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nGo to file -> new file -> R script, and write an R script to load in the gapminder dataset. Put it in the scripts/ directory and add it to version control.\nRun the script using the source function, using the file path as its argument (or by pressing the “source” button in RStudio).\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nThe source function can be used to use a script within a script. Assume you would like to load the same type of file over and over again and therefore you need to specify the arguments to fit the needs of your file. Instead of writing the necessary argument again and again you could just write it once and save it as a script. Then, you can use source(\"Your_Script_containing_the_load_function\") in a new script to use the function of that script without writing everything again. Check out ?source to find out more.\n\ndownload.file(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv\", destfile = \"data/gapminder_data.csv\")\ngapminder <- read.csv(file = \"data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\nTo run the script and load the data into the gapminder variable:\n\nsource(file = \"scripts/load-gapminder.R\")\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nRead the output of str(gapminder) again; this time, use what you’ve learned about factors, lists and vectors, as well as the output of functions like colnames and dim to explain what everything that str prints out for gapminder means. If there are any parts you can’t interpret, discuss with your neighbors!\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nThe object gapminder is a data frame with columns - country and continent are factors. - year is an integer vector. - pop, lifeExp, and gdpPercap are numeric vectors."
  },
  {
    "objectID": "05-data-structures-part2.html#tip-there-are-several-ways-to-achieve-this.",
    "href": "05-data-structures-part2.html#tip-there-are-several-ways-to-achieve-this.",
    "title": "5  Adding/removing data from data frames",
    "section": "5.6 Tip: There are several ways to achieve this.",
    "text": "5.6 Tip: There are several ways to achieve this.\nThe solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!\nRemember my_dataframe[rows, cols] will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don’t know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.\n\ngapminder[sample(nrow(gapminder), 5), ]\n\n               country year     pop continent lifeExp gdpPercap\n1394           Somalia 1957 2780415    Africa  34.977 1258.1474\n931             Malawi 1982 6502825    Africa  45.642  632.8039\n559             Gambia 1982  715523    Africa  45.580  835.8096\n491  Equatorial Guinea 2002  495627    Africa  49.348 7703.4959\n201       Burkina Faso 1992 8878303    Africa  50.260  931.7528"
  },
  {
    "objectID": "12-tidyr.html#getting-started",
    "href": "12-tidyr.html#getting-started",
    "title": "12  Reshaping data frames with tidyr",
    "section": "12.1 Getting started",
    "text": "12.1 Getting started\nFirst install the packages if you haven’t already done so (you probably installed dplyr in the previous lesson):\n\n#install.packages(\"tidyverse\")\n\nLoad the packages\n\nlibrary(\"tidyverse\")\n\nFirst, lets look at the structure of our original gapminder data frame:\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nIs gapminder a purely long, purely wide, or some intermediate format?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nThe original gapminder data.frame is in an intermediate format. It is not purely long since it had multiple observation variables (pop,lifeExp,gdpPercap).\n\n\n\n\n\nSometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely ‘long’ and ‘wide’ data formats. We have 3 “ID variables” (continent, country, year) and 3 “Observation variables” (pop,lifeExp,gdpPercap). This intermediate format can be preferred despite not having ALL observations in 1 column given that all 3 observation variables have different units. There are few operations that would need us to make this data frame any longer (i.e. 4 ID variables and 1 Observation variable).\nWhile using many of the functions in R, which are often vector based, you usually do not want to do mathematical operations on values with different units. For example, using the purely long format, a single mean for all of the values of population, life expectancy, and GDP would not be meaningful since it would return the mean of values with 3 incompatible units. The solution is that we first manipulate the data either by grouping (see the lesson on dplyr), or we change the structure of the data frame. Note: Some plotting functions in R actually work better in the wide format data."
  },
  {
    "objectID": "12-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "href": "12-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "title": "12  Reshaping data frames with tidyr",
    "section": "12.2 From wide to long format with pivot_longer()",
    "text": "12.2 From wide to long format with pivot_longer()\nUntil now, we’ve been using the nicely formatted original gapminder dataset, but ‘real’ data (i.e. our own research data) will never be so well organized. Here let’s start with the wide formatted version of the gapminder dataset.\n\nDownload the wide version of the gapminder data from here and save it in your data folder.\n\nWe’ll load the data file and look at it. Note: we don’t want our continent and country columns to be factors, so we use the stringsAsFactors argument for read.csv() to disable that.\n\ngap_wide <- read.csv(\"data/gapminder_wide.csv\", stringsAsFactors = FALSE)\nstr(gap_wide)\n\n'data.frame':   142 obs. of  38 variables:\n $ continent     : chr  \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr  \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num  2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num  3014 3828 960 918 617 ...\n $ gdpPercap_1962: num  2551 4269 949 984 723 ...\n $ gdpPercap_1967: num  3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num  4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num  4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num  5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num  5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num  5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num  4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num  5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num  6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num  43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num  45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num  48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num  51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num  54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num  58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num  61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num  65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num  67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num  69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num  71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num  72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num  9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num  10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num  11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num  12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num  14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num  17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num  20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num  23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num  26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num  29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : int  31287142 10866106 7026113 1630347 12251209 7021078 15929988 4048013 8835739 614382 ...\n $ pop_2007      : int  33333216 12420476 8078314 1639131 14326203 8390505 17696293 4369038 10238807 710960 ...\n\n\n\n\n\nDiagram illustrating the wide format of the gapminder data frame\n\n\nTo change this very wide data frame layout back to our nice, intermediate (or longer) layout, we will use one of the two available pivot functions from the tidyr package. To convert from wide to a longer format, we will use the pivot_longer() function. pivot_longer() makes datasets longer by increasing the number of rows and decreasing the number of columns, or ‘lengthening’ your observation variables into a single variable.\n\n\n\nDiagram illustrating how pivot longer reorganizes a data frame from a wide to long format\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"pop_1952\" \"pop_1957\" \"pop_1962\" \"pop_1967\" ...\n $ obs_values  : num [1:5112] 9279525 10270856 11000948 12760499 14760787 ...\n\n\nHere we have used piping syntax which is similar to what we were doing in the previous lesson with dplyr. In fact, these are compatible and you can use a mix of tidyr and dplyr functions by piping them together.\nWe first provide to pivot_longer() a vector of column names that will be pivoted into longer format. We could type out all the observation variables, but as in the select() function (see dplyr lesson), we can use the starts_with() argument to select all variables that start with the desired character string. pivot_longer() also allows the alternative syntax of using the - symbol to identify which variables are not to be pivoted (i.e. ID variables).\nThe next arguments to pivot_longer() are names_to for naming the column that will contain the new ID variable (obstype_year) and values_to for naming the new amalgamated observation variable (obs_value). We supply these new column names as strings.\n\n\n\nDiagram illustrating the long format of the gapminder data\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(-continent, -country),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values  : num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nThat may seem trivial with this particular data frame, but sometimes you have 1 ID variable and 40 observation variables with irregular variable names. The flexibility is a huge time saver!\nNow obstype_year actually contains 2 pieces of information, the observation type (pop,lifeExp, or gdpPercap) and the year. We can use the separate() function to split the character strings into multiple variables\n\ngap_long <- gap_long %>% separate(obstype_year, into = c('obs_type', 'year'), sep = \"_\")\ngap_long$year <- as.integer(gap_long$year)\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nUsing gap_long, calculate the mean life expectancy, population, and gdpPercap for each continent. *Hint:** use the group_by() and summarize() functions we learned in the dplyr lesson\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\ngap_long %>% group_by(continent, obs_type) %>%\n    summarize(means=mean(obs_values))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 15 × 3\n# Groups:   continent [5]\n   continent obs_type       means\n   <chr>     <chr>          <dbl>\n 1 Africa    gdpPercap     2194. \n 2 Africa    lifeExp         48.9\n 3 Africa    pop        9916003. \n 4 Americas  gdpPercap     7136. \n 5 Americas  lifeExp         64.7\n 6 Americas  pop       24504795. \n 7 Asia      gdpPercap     7902. \n 8 Asia      lifeExp         60.1\n 9 Asia      pop       77038722. \n10 Europe    gdpPercap    14469. \n11 Europe    lifeExp         71.9\n12 Europe    pop       17169765. \n13 Oceania   gdpPercap    18622. \n14 Oceania   lifeExp         74.3\n15 Oceania   pop        8874672."
  },
  {
    "objectID": "12-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "href": "12-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "title": "12  Reshaping data frames with tidyr",
    "section": "12.3 From long to intermediate format with pivot_wider()",
    "text": "12.3 From long to intermediate format with pivot_wider()\nIt is always good to check work. So, let’s use the second pivot function, pivot_wider(), to ‘widen’ our observation variables back out. pivot_wider() is the opposite of pivot_longer(), making a dataset wider by increasing the number of columns and decreasing the number of rows. We can use pivot_wider() to pivot or reshape our gap_long to the original intermediate format or the widest format. Let’s start with the intermediate format.\nThe pivot_wider() function takes names_from and values_from arguments.\nTo names_from we supply the column name whose contents will be pivoted into new output columns in the widened data frame. The corresponding values will be added from the column named in the values_from argument.\n\ngap_normal <- gap_long %>%\n  pivot_wider(names_from = obs_type, values_from = obs_values)\ndim(gap_normal)\n\n[1] 1704    6\n\ndim(gapminder)\n\n[1] 1704    6\n\nnames(gap_normal)\n\n[1] \"continent\" \"country\"   \"year\"      \"gdpPercap\" \"lifeExp\"   \"pop\"      \n\nnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nNow we’ve got an intermediate data frame gap_normal with the same dimensions as the original gapminder, but the order of the variables is different. Let’s fix that before checking if they are all.equal().\n\ngap_normal <- gap_normal[, names(gapminder)]\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n[3] \"Component \\\"country\\\": 1704 string mismatches\"                                         \n[4] \"Component \\\"pop\\\": Mean relative difference: 1.634504\"                                 \n[5] \"Component \\\"continent\\\": 1212 string mismatches\"                                       \n[6] \"Component \\\"lifeExp\\\": Mean relative difference: 0.203822\"                             \n[7] \"Component \\\"gdpPercap\\\": Mean relative difference: 1.162302\"                           \n\nhead(gap_normal)\n\n# A tibble: 6 × 6\n  country  year      pop continent lifeExp gdpPercap\n  <chr>   <int>    <dbl> <chr>       <dbl>     <dbl>\n1 Algeria  1952  9279525 Africa       43.1     2449.\n2 Algeria  1957 10270856 Africa       45.7     3014.\n3 Algeria  1962 11000948 Africa       48.3     2551.\n4 Algeria  1967 12760499 Africa       51.4     3247.\n5 Algeria  1972 14760787 Africa       54.5     4183.\n6 Algeria  1977 17152804 Africa       58.0     4910.\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\nWe’re almost there, the original was sorted by country, then year.\n\ngap_normal <- gap_normal %>% arrange(country, year)\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n\n\nThat’s great! We’ve gone from the longest format back to the intermediate and we didn’t introduce any errors in our code.\nNow let’s convert the long all the way back to the wide. In the wide format, we will keep country and continent as ID variables and pivot the observations across the 3 metrics (pop,lifeExp,gdpPercap) and time (year). First we need to create appropriate labels for all our new variables (time*metric combinations) and we also need to unify our ID variables to simplify the process of defining gap_wide.\n\ngap_temp <- gap_long %>% unite(var_ID, continent, country, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ var_ID    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ obs_type  : chr [1:5112] \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" ...\n $ year      : int [1:5112] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\ngap_temp <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 3] (S3: tbl_df/tbl/data.frame)\n $ ID_var    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ var_names : chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nUsing unite() we now have a single ID variable which is a combination of continent,country,and we have defined variable names. We’re now ready to pipe in pivot_wider()\n\ngap_wide_new <- gap_long %>%\n  unite(ID_var, continent, country, sep = \"_\") %>%\n  unite(var_names, obs_type, year, sep = \"_\") %>%\n  pivot_wider(names_from = var_names, values_from = obs_values)\nstr(gap_wide_new)\n\ntibble [142 × 37] (S3: tbl_df/tbl/data.frame)\n $ ID_var        : chr [1:142] \"Africa_Algeria\" \"Africa_Angola\" \"Africa_Benin\" \"Africa_Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nTake this 1 step further and create a gap_ludicrously_wide format data by pivoting over countries, year and the 3 metrics? Hint this new data frame should only have 5 rows.\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\ngap_ludicrously_wide <- gap_long %>%\n    unite(var_names, obs_type, year, country, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values)\n\n\n\n\n\n\nNow we have a great ‘wide’ format data frame, but the ID_var could be more usable, let’s separate it into 2 variables with separate()\n\ngap_wide_betterID <- separate(gap_wide_new, ID_var, c(\"continent\", \"country\"), sep=\"_\")\ngap_wide_betterID <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values) %>%\n    separate(ID_var, c(\"continent\",\"country\"), sep = \"_\")\nstr(gap_wide_betterID)\n\ntibble [142 × 38] (S3: tbl_df/tbl/data.frame)\n $ continent     : chr [1:142] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr [1:142] \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\nall.equal(gap_wide, gap_wide_betterID)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (1, 3) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\""
  },
  {
    "objectID": "12-tidyr.html#other-great-resources",
    "href": "12-tidyr.html#other-great-resources",
    "title": "12  Reshaping data frames with tidyr",
    "section": "12.4 Other great resources",
    "text": "12.4 Other great resources\n\nR for Data Science\nData Wrangling Cheat sheet\nIntroduction to tidyr\nData wrangling with R and RStudio"
  },
  {
    "objectID": "11-plot-ggplot2.html#layers",
    "href": "11-plot-ggplot2.html#layers",
    "title": "11  Data visualization with ggplot2",
    "section": "11.1 Layers",
    "text": "11.1 Layers\nUsing a scatterplot probably isn’t the best for visualizing change over time. Instead, let’s tell ggplot to visualize the data as a line plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, color=continent)) +\n  geom_line()\n\n\n\n\nInstead of adding a geom_point layer, we’ve added a geom_line layer.\nHowever, the result doesn’t look quite as we might have expected: it seems to be jumping around a lot in each continent. Let’s try to separate the data by country, plotting one line for each country:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line()\n\n\n\n\nWe’ve added the group aesthetic, which tells ggplot to draw a line for each country.\nBut what if we want to visualize both lines and points on the plot? We can add another layer to the plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line() + geom_point()\n\n\n\n\nIt’s important to note that each layer is drawn on top of the previous layer. In this example, the points have been drawn on top of the lines. Here’s a demonstration:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_line(mapping = aes(color=continent)) + geom_point()\n\n\n\n\nIn this example, the aesthetic mapping of color has been moved from the global plot options in ggplot to the geom_line layer so it no longer applies to the points. Now we can clearly see that the points are drawn on top of the lines.\n\n\n\n\n\n\nTip: Setting an aesthetic to a value instead of a mapping\n\n\n\nSo far, we’ve seen how to use an aesthetic (such as color) as a mapping to a variable in the data. For example, when we use geom_line(mapping = aes(color=continent)), ggplot will give a different color to each continent. But what if we want to change the color of all lines to blue? You may think that geom_line(mapping = aes(color=\"blue\")) should work, but it doesn’t. Since we don’t want to create a mapping to a specific variable, we can move the color specification outside of the aes() function, like this: geom_line(color=\"blue\").\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSwitch the order of the point and line layers from the previous example. What happened?\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nThe lines now get drawn over the points!\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_point() + geom_line(mapping = aes(color=continent))\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The plot illustrates the possibilities for styling visualisations in ggplot2 with data points enlarged, coloured orange, and displayed without transparency."
  },
  {
    "objectID": "11-plot-ggplot2.html#transformations-and-statistics",
    "href": "11-plot-ggplot2.html#transformations-and-statistics",
    "title": "11  Data visualization with ggplot2",
    "section": "11.2 Transformations and statistics",
    "text": "11.2 Transformations and statistics\nggplot2 also makes it easy to overlay statistical models over the data. To demonstrate we’ll go back to our first example:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nCurrently it’s hard to see the relationship between the points due to some strong outliers in GDP per capita. We can change the scale of units on the x axis using the scale functions. These control the mapping between the data values and visual values of an aesthetic. We can also modify the transparency of the points, using the alpha function, which is especially helpful when you have a large amount of data which is very clustered.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10()\n\n\n\n\nScatterplot of GDP vs life expectancy showing logarithmic x-axis data spread\n\n\n\n\nThe scale_x_log10 function applied a transformation to the coordinate system of the plot, so that each multiple of 10 is evenly spaced from left to right. For example, a GDP per capita of 1,000 is the same horizontal distance away from a value of 10,000 as the 10,000 value is from 100,000. This helps to visualize the spread of the data along the x-axis.\n\n\n\n\n\n\nTip Reminder: Setting an aesthetic to a value instead of a mapping\n\n\n\nNotice that we used geom_point(alpha = 0.5). As the previous tip mentioned, using a setting outside of the aes() function will cause this value to be used for all points, which is what we want in this case. But just like any other aesthetic setting, alpha can also be mapped to a variable in the data. For example, we can give a different transparency to each continent with geom_point(mapping = aes(alpha = continent)).\n\n\nWe can fit a simple relationship to the data by adding another layer, geom_smooth:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a blue trend line summarising the relationship between variables, and gray shaded area indicating 95% confidence intervals for that trend line.\n\n\n\n\nWe can make the line thicker by setting the size aesthetic in the geom_smooth layer:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\", size=1.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The blue trend line is slightly thicker than in the previous figure.\n\n\n\n\nThere are two ways an aesthetic can be specified. Here we set the size aesthetic by passing it as an argument to geom_smooth. Previously in the lesson we’ve used the aes function to define a mapping between data variables and their visual representation.\n\n\n\n\n\n\nChallenge 4a\n\n\n\nModify the color and size of the points on the point layer in the previous example. Hint: do not use the aes function.\n\n\n\n\n\n\nSolution to challenge 4a\n\n\n\n\n\nHere a possible solution:\nNotice that the color argument is supplied outside of the aes() function. This means that it applies to all data points on the graph and is not related to a specific variable.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\ngeom_point(size = 3, color = \"orange\") + scale_x_log10() +\ngeom_smooth(method = \"lm\", size = 1.5)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4b\n\n\n\nModify your solution to Challenge 4a so that the points are now a different shape and are colored by continent with new trendlines. Hint: The color argument can be used inside the aesthetic.\n\n\n\n\n\n\nSolution to challenge 4b\n\n\n\n\n\nHere is a possible solution:\nNotice that supplying the color argument inside the aes() functions enables you to connect it to a certain variable. The shape argument, as you can see, modifies all data points the same way (it is outside the aes() call) while the color argument which is placed inside the aes() call modifies a point’s color based on its continent value.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\ngeom_point(size=3, shape=17) + scale_x_log10() +\ngeom_smooth(method=\"lm\", size=1.5)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "11-plot-ggplot2.html#multi-panel-figures",
    "href": "11-plot-ggplot2.html#multi-panel-figures",
    "title": "11  Data visualization with ggplot2",
    "section": "11.3 Multi-panel figures",
    "text": "11.3 Multi-panel figures\nEarlier we visualized the change in life expectancy over time across all countries in one plot. Alternatively, we can split this out over multiple panels by adding a layer of facet panels.\n\n\n\n\n\n\nTip\n\n\n\nWe start by making a subset of data including only countries located in the Americas. This includes 25 countries, which will begin to clutter the figure. Note that we apply a “theme” definition to rotate the x-axis labels to maintain readability. Nearly everything in ggplot2 is customizable.\n\n\n\namericas <- gapminder[gapminder$continent == \"Americas\",]\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThe facet_wrap layer took a “formula” as its argument, denoted by the tilde (~). This tells R to draw a panel for each unique value in the country column of the gapminder dataset."
  },
  {
    "objectID": "11-plot-ggplot2.html#modifying-text",
    "href": "11-plot-ggplot2.html#modifying-text",
    "title": "11  Data visualization with ggplot2",
    "section": "11.4 Modifying text",
    "text": "11.4 Modifying text\nTo clean this figure up for a publication we need to change some of the text elements. The x-axis is too cluttered, and the y axis should read “Life expectancy”, rather than the column name in the data frame.\nWe can do this by adding a couple of different layers. The theme layer controls the axis text, and overall text size. Labels for the axes, plot title and any legend can be set using the labs function. Legend titles are set using the same names we used in the aes specification. Thus below the color legend title is set using color = \"Continent\", while the title of a fill legend would be set using fill = \"MyTitle\".\n\nggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))"
  },
  {
    "objectID": "11-plot-ggplot2.html#exporting-the-plot",
    "href": "11-plot-ggplot2.html#exporting-the-plot",
    "title": "11  Data visualization with ggplot2",
    "section": "11.5 Exporting the plot",
    "text": "11.5 Exporting the plot\nThe ggsave() function allows you to export a plot created with ggplot. You can specify the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi) to create high quality graphics for publication. In order to save the plot from above, we first assign it to a variable lifeExp_plot, then tell ggsave to save that plot in png format to a directory called results. (Make sure you have a results/ folder in your working directory.)\n\n\n\n\nlifeExp_plot <- ggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\nggsave(filename = \"results/lifeExp.png\", plot = lifeExp_plot, width = 12, height = 10, dpi = 300, units = \"cm\")\n\nThere are two nice things about ggsave. First, it defaults to the last plot, so if you omit the plot argument it will automatically save the last plot you created with ggplot. Secondly, it tries to determine the format you want to save your plot in from the file extension you provide for the filename (for example .png or .pdf). If you need to, you can specify the format explicitly in the device argument.\nThis is a taste of what you can do with ggplot2. RStudio provides a really useful cheat sheet of the different layers available, and more extensive documentation is available on the ggplot2 website. Finally, if you have no idea how to change something, a quick Google search will usually send you to a relevant question and answer on Stack Overflow with reusable code to modify!\n\n\n\n\n\n\nChallenge 5\n\n\n\nGenerate boxplots to compare life expectancy between the different continents during the available years.\nAdvanced:\n\nRename y axis as Life Expectancy.\nRemove x axis labels.\n\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nHere a possible solution:\nxlab() and ylab() set labels for the x and y axes, respectively The axis title, text and ticks are attributes of the theme and must be modified within a theme() call.\n\nggplot(data = gapminder, mapping = aes(x = continent, y = lifeExp, fill = continent)) +\ngeom_boxplot() + facet_wrap(~year) +\nylab(\"Life Expectancy\") +\ntheme(axis.title.x=element_blank(),\n      axis.text.x = element_blank(),\n      axis.ticks.x = element_blank())"
  },
  {
    "objectID": "11-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "href": "11-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "title": "11  Data visualization with ggplot2",
    "section": "11.6 Combining dplyr and ggplot2",
    "text": "11.6 Combining dplyr and ggplot2\nNote, however, that if you installed and loaded the tidyverse above, then you will already have installed and loaded ggplot2.\nIn the plotting lesson we looked at how to make a multi-panel figure by adding a layer of facet panels using ggplot2. Here is the code we used (with some extra comments):\n\n# Filter countries located in the Americas\namericas <- gapminder[gapminder$continent == \"Americas\", ]\n# Make the plot\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThis code makes the right plot but it also creates an intermediate variable (americas) that we might not have any other uses for. Just as we used |> to pipe data along a chain of dplyr functions we can use it to pass data to ggplot(). Because |> replaces the first argument in a function we don’t need to specify the data = argument in the ggplot() function. By combining dplyr and ggplot2 functions we can make the same figure without creating any new variables or modifying the data.\n\ngapminder |>\n  # Filter countries located in the Americas\n  filter(continent == \"Americas\") |>\n  # Make the plot\n  ggplot(mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nMore examples of using the function mutate() and the ggplot2 package.\n\ngapminder |>\n  # extract first letter of country name into new column\n  mutate(startsWith = substr(country, 1, 1)) |>\n  # only keep countries starting with A or Z\n  filter(startsWith %in% c(\"A\", \"Z\")) |>\n  # plot lifeExp into facets\n  ggplot(aes(x = year, y = lifeExp, colour = continent)) +\n  geom_line() +\n  facet_wrap(vars(country)) +\n  theme_minimal()"
  },
  {
    "objectID": "10-dplyr.html#the-dplyr-package",
    "href": "10-dplyr.html#the-dplyr-package",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.1 The dplyr package",
    "text": "10.1 The dplyr package\nLuckily, the dplyr package provides a number of very useful functions for manipulating data frames in a way that will reduce the above repetition, reduce the probability of making errors, and probably even save you some typing. As an added bonus, you might even find the dplyr grammar easier to read.\n\n\n\n\n\n\nTip: Tidyverse\n\n\n\ndplyr package belongs to a broader family of opinionated R packages designed for data science called the “Tidyverse”. These packages are specifically designed to work harmoniously together. Some of these packages will be covered along this course, but you can find more complete information here: https://www.tidyverse.org/.\n\n\nHere we’re going to cover 5 of the most commonly used functions as well as using pipes (|>) to combine them.\n\nselect()\nfilter()\ngroup_by()\nsummarize()\nmutate()\n\nIf you have have not installed this package earlier, please do so:\n\ninstall.packages('dplyr')\n\nNow let’s load the package:\n\nlibrary(dplyr)\n\nAlternatively, you can load the tidyverse package, which will also install ggplot2 and other related packages:\n\ninstall.packages('tidyverse')\n\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "10-dplyr.html#using-select",
    "href": "10-dplyr.html#using-select",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.2 Using select()",
    "text": "10.2 Using select()\nIf, for example, we wanted to move forward with only a few of the variables in our data frame we could use the select() function. This will keep only the variables you select.\n\nyear_country_gdp <- select(gapminder, year, country, gdpPercap)\n\n If we want to remove one column only from the gapminder data, for example, removing the continent column.\n\nsmaller_gapminder_data <- select(gapminder, -continent)\n\nIf we open up year_country_gdp we’ll see that it only contains the year, country and gdpPercap. Above we used ‘normal’ grammar, but the strengths of dplyr lie in combining several functions using pipes. Since the pipes grammar is unlike anything we’ve seen in R before, let’s repeat what we’ve done above using pipes.\n\nyear_country_gdp <- gapminder |> select(year, country, gdpPercap)\n\nTo help you understand why we wrote that in that way, let’s walk through it step by step. First we summon the gapminder data frame and pass it on, using the pipe symbol |>, to the next step, which is the select() function. In this case we don’t specify which data object we use in the select() function since in gets that from the previous pipe. Fun Fact: There is a good chance you have encountered pipes before in the shell. In R, a pipe symbol is |> while in the shell it is | but the concept is the same!\n\n\n\n\n\n\nTip: Renaming data frame columns in dplyr\n\n\n\nIn Chapter 4 we covered how you can rename columns with base R by assigning a value to the output of the names() function. Just like select, this is a bit cumbersome, but thankfully dplyr has a rename() function. Within a pipeline, the syntax is rename(new_name = old_name). For example, we may want to rename the gdpPercap column name from our select() statement above.\n\ntidy_gdp <- year_country_gdp |> rename(gdp_per_capita = gdpPercap)\nhead(tidy_gdp)\n\n  year     country gdp_per_capita\n1 1952 Afghanistan       779.4453\n2 1957 Afghanistan       820.8530\n3 1962 Afghanistan       853.1007\n4 1967 Afghanistan       836.1971\n5 1972 Afghanistan       739.9811\n6 1977 Afghanistan       786.1134"
  },
  {
    "objectID": "10-dplyr.html#using-filter",
    "href": "10-dplyr.html#using-filter",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.3 Using filter()",
    "text": "10.3 Using filter()\nIf we now want to move forward with the above, but only with European countries, we can combine select and filter\n\nyear_country_gdp_euro <- gapminder |>\n    filter(continent == \"Europe\") |>\n    select(year, country, gdpPercap)\n\nIf we now want to show life expectancy of European countries but only for a specific year (e.g., 2007), we can do as below.\n\neurope_lifeExp_2007 <- gapminder |>\n  filter(continent == \"Europe\", year == 2007) |>\n  select(country, lifeExp)\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nWrite a single command (which can span multiple lines and includes pipes) that will produce a data frame that has the African values for lifeExp, country and year, but not for other Continents. How many rows does your data frame have and why?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\nyear_country_lifeExp_Africa <- gapminder |>\n                          filter(continent == \"Africa\") |>\n                          select(year, country, lifeExp)\n\n\n\n\n\n\nAs with last time, first we pass the gapminder data frame to the filter() function, then we pass the filtered version of the gapminder data frame to the select() function. Note: The order of operations is very important in this case. If we used ‘select’ first, filter would not be able to find the variable continent since we would have removed it in the previous step."
  },
  {
    "objectID": "10-dplyr.html#using-group_by",
    "href": "10-dplyr.html#using-group_by",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.4 Using group_by()",
    "text": "10.4 Using group_by()\nNow, we were supposed to be reducing the error prone repetitiveness of what can be done with base R, but up to now we haven’t done that since we would have to repeat the above for each continent. Instead of filter(), which will only pass observations that meet your criteria (in the above: continent == \"Europe\"), we can use group_by(), which will essentially use every unique criteria that you could have used in filter.\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\nstr(gapminder |> group_by(continent))\n\ngropd_df [1,704 × 6] (S3: grouped_df/tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num [1:1704] 8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n - attr(*, \"groups\")= tibble [5 × 2] (S3: tbl_df/tbl/data.frame)\n  ..$ continent: chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...\n  ..$ .rows    : list<int> [1:5] \n  .. ..$ : int [1:624] 25 26 27 28 29 30 31 32 33 34 ...\n  .. ..$ : int [1:300] 49 50 51 52 53 54 55 56 57 58 ...\n  .. ..$ : int [1:396] 1 2 3 4 5 6 7 8 9 10 ...\n  .. ..$ : int [1:360] 13 14 15 16 17 18 19 20 21 22 ...\n  .. ..$ : int [1:24] 61 62 63 64 65 66 67 68 69 70 ...\n  .. ..@ ptype: int(0) \n  ..- attr(*, \".drop\")= logi TRUE\n\n\nYou will notice that the structure of the data frame where we used group_by() (grouped_df) is not the same as the original gapminder (data.frame). A grouped_df can be thought of as a list where each item in the listis a data.frame which contains only the rows that correspond to the a particular value continent (at least in the example above).\n\n\n\nDiagram illustrating how the group by function oraganizes a data frame into groups"
  },
  {
    "objectID": "10-dplyr.html#using-summarize",
    "href": "10-dplyr.html#using-summarize",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.5 Using summarize()",
    "text": "10.5 Using summarize()\nThe above was a bit on the uneventful side but group_by() is much more exciting in conjunction with summarize(). This will allow us to create new variable(s) by using functions that repeat for each of the continent-specific data frames. That is to say, using the group_by() function, we split our original data frame into multiple pieces, then we can run functions (e.g. mean() or sd()) within summarize().\n\ngdp_bycontinents <- gapminder |>\n    group_by(continent) |>\n    summarize(mean_gdpPercap = mean(gdpPercap))\n\n\n\n\nDiagram illustrating the use of group by and summarize together to create a new variable\n\n\n\ncontinent mean_gdpPercap\n     <fctr>          <dbl>\n1    Africa       2193.755\n2  Americas       7136.110\n3      Asia       7902.150\n4    Europe      14469.476\n5   Oceania      18621.609\n\nThat allowed us to calculate the mean gdpPercap for each continent, but it gets even better.\n\n\n\n\n\n\nChallenge 2\n\n\n\nCalculate the average life expectancy per country. Which has the longest average life expectancy and which has the shortest average life expectancy?\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nlifeExp_bycountry <- gapminder |>\n    group_by(country) |>\n    summarize(mean_lifeExp = mean(lifeExp))\nlifeExp_bycountry |>\n    filter(mean_lifeExp == min(mean_lifeExp) | mean_lifeExp == max(mean_lifeExp))\n\n# A tibble: 2 × 2\n  country      mean_lifeExp\n  <chr>               <dbl>\n1 Iceland              76.5\n2 Sierra Leone         36.8\n\n\nAnother way to do this is to use the dplyr function arrange(), which arranges the rows in a data frame according to the order of one or more variables from the data frame. It has similar syntax to other functions from the dplyr package. You can use desc() inside arrange() to sort in descending order.\n\nlifeExp_bycountry |>\n    arrange(mean_lifeExp) |>\n    head(1)\n\n# A tibble: 1 × 2\n  country      mean_lifeExp\n  <chr>               <dbl>\n1 Sierra Leone         36.8\n\nlifeExp_bycountry |>\n    arrange(desc(mean_lifeExp)) |>\n    head(1)\n\n# A tibble: 1 × 2\n  country mean_lifeExp\n  <chr>          <dbl>\n1 Iceland         76.5\n\n\nAlphabetical order works too\n\nlifeExp_bycountry |>\n    arrange(desc(country)) |>\n    head(1)\n\n# A tibble: 1 × 2\n  country  mean_lifeExp\n  <chr>           <dbl>\n1 Zimbabwe         52.7\n\n\n\n\n\n\n\nThe function group_by() allows us to group by multiple variables. Let’s group by year and continent.\n\ngdp_bycontinents_byyear <- gapminder |>\n    group_by(continent, year) |>\n    summarize(mean_gdpPercap = mean(gdpPercap))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\nThat is already quite powerful, but it gets even better! You’re not limited to defining 1 new variable in summarize().\n\ngdp_pop_bycontinents_byyear <- gapminder |>\n    group_by(continent, year) |>\n    summarize(mean_gdpPercap = mean(gdpPercap),\n              sd_gdpPercap = sd(gdpPercap),\n              mean_pop = mean(pop),\n              sd_pop = sd(pop))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "10-dplyr.html#count-and-n",
    "href": "10-dplyr.html#count-and-n",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.6 count() and n()",
    "text": "10.6 count() and n()\nA very common operation is to count the number of observations for each group. The dplyr package comes with two related functions that help with this.\nFor instance, if we wanted to check the number of countries included in the dataset for the year 2002, we can use the count() function. It takes the name of one or more columns that contain the groups we are interested in, and we can optionally sort the results in descending order by adding sort=TRUE:\n\ngapminder |>\n    filter(year == 2002) |>\n    count(continent, sort = TRUE)\n\n  continent  n\n1    Africa 52\n2      Asia 33\n3    Europe 30\n4  Americas 25\n5   Oceania  2\n\n\nIf we need to use the number of observations in calculations, the n() function is useful. It will return the total number of observations in the current group rather than counting the number of observations in each group within a specific column. For instance, if we wanted to get the standard error of the life expectency per continent:\n\ngapminder |>\n    group_by(continent) |>\n    summarize(se_le = sd(lifeExp)/sqrt(n()))\n\n# A tibble: 5 × 2\n  continent se_le\n  <chr>     <dbl>\n1 Africa    0.366\n2 Americas  0.540\n3 Asia      0.596\n4 Europe    0.286\n5 Oceania   0.775\n\n\nYou can also chain together several summary operations; in this case calculating the minimum, maximum, mean and se of each continent’s per-country life-expectancy:\n\ngapminder |>\n    group_by(continent) |>\n    summarize(\n      mean_le = mean(lifeExp),\n      min_le = min(lifeExp),\n      max_le = max(lifeExp),\n      se_le = sd(lifeExp)/sqrt(n()))\n\n# A tibble: 5 × 5\n  continent mean_le min_le max_le se_le\n  <chr>       <dbl>  <dbl>  <dbl> <dbl>\n1 Africa       48.9   23.6   76.4 0.366\n2 Americas     64.7   37.6   80.7 0.540\n3 Asia         60.1   28.8   82.6 0.596\n4 Europe       71.9   43.6   81.8 0.286\n5 Oceania      74.3   69.1   81.2 0.775"
  },
  {
    "objectID": "10-dplyr.html#using-mutate",
    "href": "10-dplyr.html#using-mutate",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.7 Using mutate()",
    "text": "10.7 Using mutate()\nWe can also create new variables prior to (or even after) summarizing information using mutate().\n\ngdp_pop_bycontinents_byyear <- gapminder |>\n    mutate(gdp_billion = gdpPercap * pop / 10^9) |>\n    group_by(continent, year) |>\n    summarize(mean_gdpPercap = mean(gdpPercap),\n              sd_gdpPercap = sd(gdpPercap),\n              mean_pop = mean(pop),\n              sd_pop = sd(pop),\n              mean_gdp_billion = mean(gdp_billion),\n              sd_gdp_billion = sd(gdp_billion))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "10-dplyr.html#connect-mutate-with-logical-filtering-ifelse",
    "href": "10-dplyr.html#connect-mutate-with-logical-filtering-ifelse",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.8 Connect mutate with logical filtering: ifelse",
    "text": "10.8 Connect mutate with logical filtering: ifelse\nWhen creating new variables, we can hook this with a logical condition. A simple combination of mutate() and ifelse() facilitates filtering right where it is needed: in the moment of creating something new. This easy-to-read statement is a fast and powerful way of discarding certain data (even though the overall dimension of the data frame will not change) or for updating values depending on this given condition.\n\n## keeping all data but \"filtering\" after a certain condition\n# calculate GDP only for people with a life expectation above 25\ngdp_pop_bycontinents_byyear_above25 <- gapminder |>\n    mutate(gdp_billion = ifelse(lifeExp > 25, gdpPercap * pop / 10^9, NA)) |>\n    group_by(continent, year) |>\n    summarize(mean_gdpPercap = mean(gdpPercap),\n              sd_gdpPercap = sd(gdpPercap),\n              mean_pop = mean(pop),\n              sd_pop = sd(pop),\n              mean_gdp_billion = mean(gdp_billion),\n              sd_gdp_billion = sd(gdp_billion))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n## updating only if certain condition is fullfilled\n# for life expectations above 40 years, the gpd to be expected in the future is scaled\ngdp_future_bycontinents_byyear_high_lifeExp <- gapminder |>\n    mutate(gdp_futureExpectation = ifelse(lifeExp > 40, gdpPercap * 1.5, gdpPercap)) |>\n    group_by(continent, year) |>\n    summarize(mean_gdpPercap = mean(gdpPercap),\n              mean_gdpPercap_expected = mean(gdp_futureExpectation))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\nAdvanced Challenge\n\n\n\nCalculate the average life expectancy in 2002 of 2 randomly selected countries for each continent. Then arrange the continent names in reverse order. Hint: Use the dplyr functions arrange() and sample_n(), they have similar syntax to other dplyr functions.\n\n\n\n\n\n\nSolution to Advanced Challenge\n\n\n\n\n\n\nlifeExp_2countries_bycontinents <- gapminder |>\n    filter(year == 2002) |>\n    group_by(continent) |>\n    sample_n(2) |>\n    summarize(mean_lifeExp = mean(lifeExp)) |>\n    arrange(desc(mean_lifeExp))"
  },
  {
    "objectID": "10-dplyr.html#other-great-resources",
    "href": "10-dplyr.html#other-great-resources",
    "title": "10  Data Frame Manipulation with dplyr",
    "section": "10.9 Other great resources",
    "text": "10.9 Other great resources\n\nR for Data Science\nData Wrangling Cheat sheet\nIntroduction to dplyr\nData wrangling with R and RStudio"
  },
  {
    "objectID": "09-functions.html#defining-a-function",
    "href": "09-functions.html#defining-a-function",
    "title": "9  Functions",
    "section": "9.1 Defining a function",
    "text": "9.1 Defining a function\nIf you haven’t already, create a functions/ directory in the same folder as your working quarto file.\nOpen a new R script file and call it functions-lesson.R and save it in the functions/ directory.\nThe general structure of a function is:\n\nmy_function <- function(parameters) {\n  # perform action\n  # return value\n}\n\nLet’s define a function fahr_to_kelvin() that converts temperatures from Fahrenheit to Kelvin:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nThe list of arguments that the function takes are contained within the parentheses in function(args).\nNext, the body of the function–the statements that are executed when it runs–is contained within curly braces ({}). The statements in the body are indented by two spaces. This makes the code easier to read but does not affect how the code operates.\nIt is useful to think of creating functions like writing a cookbook. First you define the “ingredients” that your function needs. In this case, we only need one ingredient to use our function: “temp”. After we list our ingredients, we then say what we will do with them, in this case, we are taking our ingredient and applying a set of mathematical operators to it.\nWhen we call the function, the values we pass to it as arguments are assigned to those variables so that we can use them inside the function. Inside the function, we use a to output a result when the function is used.\n\n\n\n\n\n\nReturn statements\n\n\n\nOne feature unique to R is that the return statement is not required.\nR automatically returns whichever variable is on the last line of the body of the function. But for clarity, we will explicitly define the return statement.\n\n\nLet’s try running our function. Calling our own function is no different from calling any other function:\n\n# freezing point of water\nfahr_to_kelvin(32)\n\n[1] 273.15\n\n\n\n# boiling point of water\nfahr_to_kelvin(212)\n\n[1] 373.15\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nWrite a function called kelvin_to_celsius() that takes a temperature in Kelvin and returns that temperature in Celsius. Hint: To convert from Kelvin to Celsius you subtract 273.15\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\nWrite a function called kelvin_to_celsius that takes a temperature in Kelvin and returns that temperature in Celsius\n\nkelvin_to_celsius <- function(temp) {\ncelsius <- temp - 273.15\nreturn(celsius)\n}"
  },
  {
    "objectID": "09-functions.html#combining-functions",
    "href": "09-functions.html#combining-functions",
    "title": "9  Functions",
    "section": "9.2 Combining functions",
    "text": "9.2 Combining functions\nThe real power of functions comes from mixing, matching and combining them into ever-larger chunks to get the effect we want.\nLet’s define two functions that will convert temperature from Fahrenheit to Kelvin, and Kelvin to Celsius:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nkelvin_to_celsius <- function(temp) {\n  celsius <- temp - 273.15\n  return(celsius)\n}\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nDefine the function to convert directly from Fahrenheit to Celsius, by reusing the two functions above (or using your own functions if you prefer).\n\n\n\n\n\n\nSolution to challenge 2\n\n\n\n\n\nDefine the function to convert directly from Fahrenheit to Celsius, by reusing these two functions above\n\nfahr_to_celsius <- function(temp) {\n temp_k <- fahr_to_kelvin(temp)\n result <- kelvin_to_celsius(temp_k)\n return(result)\n}"
  },
  {
    "objectID": "09-functions.html#interlude-defensive-programming",
    "href": "09-functions.html#interlude-defensive-programming",
    "title": "9  Functions",
    "section": "9.3 Interlude: Defensive Programming",
    "text": "9.3 Interlude: Defensive Programming\nNow that we’ve begun to appreciate how writing functions provides an efficient way to make R code re-usable and modular, we should note that it is important to ensure that functions only work in their intended use-cases. Checking function parameters is related to the concept of defensive programming. Defensive programming encourages us to frequently check conditions and throw an error if something is wrong. These checks are referred to as assertion statements because we want to assert some condition is TRUE before proceeding. They make it easier to debug because they give us a better idea of where the errors originate.\n\n9.3.1 Checking conditions with stopifnot()\nLet’s start by re-examining fahr_to_kelvin(), our function for converting temperatures from Fahrenheit to Kelvin. It was defined like so:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nFor this function to work as intended, the argument temp must be a numeric value; otherwise, the mathematical procedure for converting between the two temperature scales will not work. To create an error, we can use the function stop(). For example, since the argument temp must be a numeric vector, we could check for this condition with an if statement and throw an error if the condition was violated. We could augment our function above like so:\n\nfahr_to_kelvin <- function(temp) {\n  if (!is.numeric(temp)) {\n    stop(\"temp must be a numeric vector.\")\n  }\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nIf we had multiple conditions or arguments to check, it would take many lines of code to check all of them. Luckily R provides the convenience function stopifnot(). We can list as many requirements that should evaluate to TRUE; stopifnot() throws an error if it finds one that is FALSE. Listing these conditions also serves a secondary purpose as extra documentation for the function.\nLet’s try out defensive programming with stopifnot() by adding assertions to check the input to our function fahr_to_kelvin().\nWe want to assert the following: temp is a numeric vector. We may do that like so:\n\nfahr_to_kelvin <- function(temp) {\n  stopifnot(is.numeric(temp))\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nIt still works when given proper input.\n\n# freezing point of water\nfahr_to_kelvin(temp = 32)\n\n[1] 273.15\n\n\nBut fails instantly if given improper input.\n\n# Metric is a factor instead of numeric\nfahr_to_kelvin(temp = as.factor(32))\n\nError in fahr_to_kelvin(temp = as.factor(32)): is.numeric(temp) is not TRUE\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nUse defensive programming to ensure that our fahr_to_celsius() function throws an error immediately if the argument temp is specified inappropriately.\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nExtend our previous definition of the function by adding in an explicit call to stopifnot(). Since fahr_to_celsius() is a composition of two other functions, checking inside here makes adding checks to the two component functions redundant.\n\nfahr_to_celsius <- function(temp) {\n stopifnot(is.numeric(temp))\n temp_k <- fahr_to_kelvin(temp)\n result <- kelvin_to_celsius(temp_k)\n return(result)\n}"
  },
  {
    "objectID": "09-functions.html#more-on-combining-functions",
    "href": "09-functions.html#more-on-combining-functions",
    "title": "9  Functions",
    "section": "9.4 More on combining functions",
    "text": "9.4 More on combining functions\nNow, we’re going to define a function that calculates the Gross Domestic Product of a nation from the data available in our dataset:\n\n# Takes a dataset and multiplies the population column\n# with the GDP per capita column.\ncalcGDP <- function(dat) {\n  gdp <- dat$pop * dat$gdpPercap\n  return(gdp)\n}\n\nWe define calcGDP() by assigning it to the output of function. The list of argument names are contained within parentheses. Next, the body of the function – the statements executed when you call the function – is contained within curly braces ({}).\nWe’ve indented the statements in the body by two spaces. This makes the code easier to read but does not affect how it operates.\nWhen we call the function, the values we pass to it are assigned to the arguments, which become variables inside the body of the function.\nInside the function, we use the return() function to send back the result. This return() function is optional: R will automatically return the results of whatever command is executed on the last line of the function.\n\ncalcGDP(head(gapminder))\n\n[1]  6567086330  7585448670  8758855797  9648014150  9678553274 11697659231\n\n\nThat’s not very informative. Let’s add some more arguments so we can extract that per year and country.\n\n# Takes a dataset and multiplies the population column\n# with the GDP per capita column.\ncalcGDP <- function(dat, year=NULL, country=NULL) {\n  if(!is.null(year)) {\n    dat <- dat[dat$year %in% year, ]\n  }\n  if (!is.null(country)) {\n    dat <- dat[dat$country %in% country,]\n  }\n  gdp <- dat$pop * dat$gdpPercap\n\n  new <- cbind(dat, gdp=gdp)\n  return(new)\n}\n\nIf you’ve been writing these functions down into a separate R script (a good idea!), you can load in the functions into our R session by using the source() function:\n\nsource(\"functions/functions-lesson.R\")\n\nOk, so there’s a lot going on in this function now. In plain English, the function now subsets the provided data by year if the year argument isn’t empty, then subsets the result by country if the country argument isn’t empty. Then it calculates the GDP for whatever subset emerges from the previous two steps. The function then adds the GDP as a new column to the subsetted data and returns this as the final result. You can see that the output is much more informative than a vector of numbers.\nLet’s take a look at what happens when we specify the year:\n\nhead(calcGDP(gapminder, year = 2007))\n\n       country year      pop continent lifeExp  gdpPercap          gdp\n12 Afghanistan 2007 31889923      Asia  43.828   974.5803  31079291949\n24     Albania 2007  3600523    Europe  76.423  5937.0295  21376411360\n36     Algeria 2007 33333216    Africa  72.301  6223.3675 207444851958\n48      Angola 2007 12420476    Africa  42.731  4797.2313  59583895818\n60   Argentina 2007 40301927  Americas  75.320 12779.3796 515033625357\n72   Australia 2007 20434176   Oceania  81.235 34435.3674 703658358894\n\n\nOr for a specific country:\n\ncalcGDP(gapminder, country = \"Australia\")\n\n     country year      pop continent lifeExp gdpPercap          gdp\n61 Australia 1952  8691212   Oceania  69.120  10039.60  87256254102\n62 Australia 1957  9712569   Oceania  70.330  10949.65 106349227169\n63 Australia 1962 10794968   Oceania  70.930  12217.23 131884573002\n64 Australia 1967 11872264   Oceania  71.100  14526.12 172457986742\n65 Australia 1972 13177000   Oceania  71.930  16788.63 221223770658\n66 Australia 1977 14074100   Oceania  73.490  18334.20 258037329175\n67 Australia 1982 15184200   Oceania  74.740  19477.01 295742804309\n68 Australia 1987 16257249   Oceania  76.320  21888.89 355853119294\n69 Australia 1992 17481977   Oceania  77.560  23424.77 409511234952\n70 Australia 1997 18565243   Oceania  78.830  26997.94 501223252921\n71 Australia 2002 19546792   Oceania  80.370  30687.75 599847158654\n72 Australia 2007 20434176   Oceania  81.235  34435.37 703658358894\n\n\nOr both:\n\ncalcGDP(gapminder, year = 2007, country = \"Australia\")\n\n     country year      pop continent lifeExp gdpPercap          gdp\n72 Australia 2007 20434176   Oceania  81.235  34435.37 703658358894\n\n\nLet’s walk through the body of the function:\n\ncalcGDP <- function(dat, year = NULL, country = NULL) {\n\nHere we’ve added two arguments, year, and country. We’ve set default arguments for both as NULL using the = operator in the function definition. This means that those arguments will take on those values unless the user specifies otherwise.\n\n  if(!is.null(year)) {\n    dat <- dat[dat$year %in% year, ]\n  }\n  if (!is.null(country)) {\n    dat <- dat[dat$country %in% country,]\n  }\n\nHere, we check whether each additional argument is set to null, and whenever they’re not null overwrite the dataset stored in dat with a subset given by the non-null argument.\nBuilding these conditionals into the function makes it more flexible for later. Now, we can use it to calculate the GDP for:\n\nThe whole dataset;\nA single year;\nA single country;\nA single combination of year and country.\n\nBy using %in% instead, we can also give multiple years or countries to those arguments.\n\n\n\n\n\n\nTip: Pass by value\n\n\n\nFunctions in R almost always make copies of the data to operate on inside of a function body. When we modify dat inside the function we are modifying the copy of the gapminder dataset stored in dat, not the original variable we gave as the first argument. This is called “pass-by-value” and it makes writing code much safer: you can always be sure that whatever changes you make within the body of the function, stay inside the body of the function.\n\n\n\n\n\n\n\n\nTip: Function scope\n\n\n\nAnother important concept is scoping: any variables (or functions!) you create or modify inside the body of a function only exist for the lifetime of the function’s execution. When we call calcGDP(), the variables dat, gdp and new only exist inside the body of the function. Even if we have variables of the same name in our interactive R session, they are not modified in any way when executing a function.\n\n\n\n  gdp <- dat$pop * dat$gdpPercap\n  new <- cbind(dat, gdp=gdp)\n  return(new)\n}\n\nFinally, we calculated the GDP on our new subset, and created a new data frame with that column added. This means when we call the function later we can see the context for the returned GDP values, which is much better than in our first attempt where we got a vector of numbers.\n\n\n\n\n\n\nChallenge 4\n\n\n\nTest out your GDP function by calculating the GDP for New Zealand in 1987. How does this differ from New Zealand’s GDP in 1952?\n\n\n\n\n\n\nSolution to challenge 4\n\n\n\n\n\n\n calcGDP(gapminder, year = c(1952, 1987), country = \"New Zealand\")\n\nGDP for New Zealand in 1987: 65050008703 GDP for New Zealand in 1952: 21058193787\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nThe paste() function can be used to combine text together, e.g:\n\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\npaste(best_practice, collapse=\" \")\n\n[1] \"Write programs for people not computers\"\n\n\nWrite a function called fence() that takes two vectors as arguments, called text and wrapper, and prints out the text wrapped with the wrapper:\n\nfence(text=best_practice, wrapper=\"***\")\n\nNote: the paste() function has an argument called sep, which specifies the separator between text. The default is a space: ” “. The default for paste0() is no space”“.\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\nWrite a function called fence() that takes two vectors as arguments, called text and wrapper, and prints out the text wrapped with the wrapper:\n\nfence <- function(text, wrapper){\n text <- c(wrapper, text, wrapper)\n result <- paste(text, collapse = \" \")\n return(result)\n}\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\nfence(text=best_practice, wrapper=\"***\")\n\n[1] \"*** Write programs for people not computers ***\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nR has some unique aspects that can be exploited when performing more complicated operations. We will not be writing anything that requires knowledge of these more advanced concepts. In the future when you are comfortable writing functions in R, you can learn more by reading the R Language Manual or this chapter from Advanced R Programming by Hadley Wickham.\n\n\n\n\n\n\n\n\nTip: Testing and documenting\n\n\n\nIt’s important to both test functions and document them: Documentation helps you, and others, understand what the purpose of your function is, and how to use it, and its important to make sure that your function actually does what you think.\nWhen you first start out, your workflow will probably look a lot like this:\n\nWrite a function\nComment parts of the function to document its behaviour\nLoad in the source file\nExperiment with it in the console to make sure it behaves as you expect\nMake any necessary bug fixes\nRinse and repeat.\n\nFormal documentation for functions, written in separate .Rd files, gets turned into the documentation you see in help files. The roxygen2 package allows R coders to write documentation alongside the function code and then process it into the appropriate .Rd files. You will want to switch to this more formal method of writing documentation when you start writing more complicated R projects. In fact, packages are, in essence, bundles of functions with this formal documentation. Loading your own functions through source(\"functions.R\") is equivalent to loading someone else’s functions (or your own one day!) through library(\"package\").\nFormal automated tests can be written using the testthat package."
  },
  {
    "objectID": "08-vectorization.html",
    "href": "08-vectorization.html",
    "title": "8  Vectorization",
    "section": "",
    "text": "Most of R’s functions are vectorized, meaning that the function will operate on all elements of a vector without needing to loop through and act on each element one at a time. This makes writing code more concise, easy to read, and less error prone.\n\nx <- 1:4\nx * 2\n\n[1] 2 4 6 8\n\n\nThe multiplication happened to each element of the vector.\nWe can also add two vectors together:\n\ny <- 6:9\nx + y\n\n[1]  7  9 11 13\n\n\nEach element of x was added to its corresponding element of y:\n\nx:  1  2  3  4\n    +  +  +  +\ny:  6  7  8  9\n---------------\n    7  9 11 13\n\nHere is how we would add two vectors together using a for loop:\n\noutput_vector <- c()\nfor (i in 1:4) {\n  output_vector[i] <- x[i] + y[i]\n}\noutput_vector\n\n[1]  7  9 11 13\n\n\nCompare this to the output using vectorised operations.\n\nsum_xy <- x + y\nsum_xy\n\n[1]  7  9 11 13\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nLet’s try this on the pop column of the gapminder dataset. Make a new column in the gapminder data frame that contains population in units of millions of people. Check the head or tail of the data frame to make sure it worked.\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\nLet’s try this on the pop column of the gapminder dataset. Make a new column in the gapminder data frame that contains population in units of millions of people. Check the head or tail of the data frame to make sure it worked.\n\ngapminder$pop_millions <- gapminder$pop / 1e6\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap pop_millions\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453     8.425333\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530     9.240934\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007    10.267083\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971    11.537966\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811    13.079460\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134    14.880372\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparison operators, logical operators, and many functions are also vectorized:\nComparison operators\n\nx > 2\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\nLogical operators\n\na <- x > 3  # or, for clarity, a <- (x > 3)\na\n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n\n\n\n\n\nTip: some useful functions for logical vectors\n\n\n\nany() will return TRUE if any element of a vector is TRUE.\nall() will return TRUE if all elements of a vector are TRUE.\n\n\nMost functions also operate element-wise on vectors:\nFunctions\n\nx <- 1:4\nlog(x)\n\n[1] 0.0000000 0.6931472 1.0986123 1.3862944\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nWe’re interested in looking at the sum of the following sequence of fractions:\n\nx = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)\n\nThis would be tedious to type out, and impossible for high values of n. Use vectorisation to compute x when n=100. What is the sum when n=10,000?\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nWe’re interested in looking at the sum of the following sequence of fractions:\n\nx = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)\n\nThis would be tedious to type out, and impossible for high values of n. Can you use vectorisation to compute x, when n=100? How about when n=10,000?\n\nsum(1/(1:100)^2)\n\n[1] 1.634984\n\nsum(1/(1:1e04)^2)\n\n[1] 1.644834\n\nn <- 10000\nsum(1/(1:n)^2)\n\n[1] 1.644834\n\n\nWe can also obtain the same results using a function:\n\ninverse_sum_of_squares <- function(n) {\n sum(1/(1:n)^2)\n}\ninverse_sum_of_squares(100)\n\n[1] 1.634984\n\ninverse_sum_of_squares(10000)\n\n[1] 1.644834\n\nn <- 10000\ninverse_sum_of_squares(n)\n\n[1] 1.644834\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Operations on vectors of unequal length\n\n\n\nOperations can also be performed on vectors of unequal length, through a process known as recycling. This process automatically repeats the smaller vector until it matches the length of the larger vector. R will provide a warning if the larger vector is not a multiple of the smaller vector.\n\nx <- c(1, 2, 3)\ny <- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 5 7 9 8\n\n\nVector x was recycled to match the length of vector y\n\nx:  1  2  3  1  2  3  1\n    +  +  +  +  +  +  +\ny:  1  2  3  4  5  6  7\n-----------------------\n    2  4  6  5  7  9  8"
  },
  {
    "objectID": "07-control-flow.html#repeating-operations",
    "href": "07-control-flow.html#repeating-operations",
    "title": "7  Control Flow",
    "section": "7.1 Repeating operations",
    "text": "7.1 Repeating operations\nIf you want to iterate over a set of values, when the order of iteration is important, and perform the same operation on each, a for() loop will do the job.\nThis is the most flexible of looping operations, but therefore also the hardest to use correctly. In general, the advice of many R users would be to learn about for() loops, but to avoid using for() loops unless the order of iteration is important: i.e. the calculation at each iteration depends on the results of previous iterations.\nIf the order of iteration is not important, then you should learn about vectorized alternatives, such as the purrr package, as they pay off in computational efficiency.\nThe basic structure of a for() loop is:\n\nfor (iterator in set of values) {\n  do a thing\n}\n\nFor example:\n\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\nThe 1:10 bit creates a vector on the fly; you can iterate over any other vector as well.\nWe can use a for() loop nested within another for() loop to iterate over two things at once.\n\nfor (i in 1:5) {\n  for (j in c('a', 'b', 'c', 'd', 'e')) {\n    print(paste(i,j))\n  }\n}\n\n[1] \"1 a\"\n[1] \"1 b\"\n[1] \"1 c\"\n[1] \"1 d\"\n[1] \"1 e\"\n[1] \"2 a\"\n[1] \"2 b\"\n[1] \"2 c\"\n[1] \"2 d\"\n[1] \"2 e\"\n[1] \"3 a\"\n[1] \"3 b\"\n[1] \"3 c\"\n[1] \"3 d\"\n[1] \"3 e\"\n[1] \"4 a\"\n[1] \"4 b\"\n[1] \"4 c\"\n[1] \"4 d\"\n[1] \"4 e\"\n[1] \"5 a\"\n[1] \"5 b\"\n[1] \"5 c\"\n[1] \"5 d\"\n[1] \"5 e\"\n\n\nWe notice in the output that when the first index (i) is set to 1, the second index (j) iterates through its full set of indices. Once the indices of j have been iterated through, then i is incremented. This process continues until the last index has been used for each for() loop.\nRather than printing the results, we could write the loop output to a new object.\n\noutput_vector <- c()\nfor (i in 1:5) {\n  for (j in c('a', 'b', 'c', 'd', 'e')) {\n    temp_output <- paste(i, j)\n    output_vector <- c(output_vector, temp_output)\n  }\n}\noutput_vector\n\n [1] \"1 a\" \"1 b\" \"1 c\" \"1 d\" \"1 e\" \"2 a\" \"2 b\" \"2 c\" \"2 d\" \"2 e\" \"3 a\" \"3 b\"\n[13] \"3 c\" \"3 d\" \"3 e\" \"4 a\" \"4 b\" \"4 c\" \"4 d\" \"4 e\" \"5 a\" \"5 b\" \"5 c\" \"5 d\"\n[25] \"5 e\"\n\n\nThis approach can be useful, but ‘growing your results’ (building the result object incrementally) is computationally inefficient, so avoid it when you are iterating through a lot of values.\n\n\n\n\n\n\nTip: don’t grow your results\n\n\n\nOne of the biggest things that trips up novices and experienced R users alike, is building a results object (vector, list, matrix, data frame) as your for loop progresses. Computers are very bad at handling this, so your calculations can very quickly slow to a crawl. It’s much better to define an empty results object before hand of appropriate dimensions, rather than initializing an empty object without dimensions. So if you know the end result will be stored in a matrix like above, create an empty matrix with 5 row and 5 columns, then at each iteration store the results in the appropriate location.\n\n\nA better way is to define your (empty) output object before filling in the values. For this example, it looks more involved, but is still more efficient.\n\noutput_matrix <- matrix(nrow = 5, ncol = 5)\nj_vector <- c('a', 'b', 'c', 'd', 'e')\nfor (i in 1:5) {\n  for (j in 1:5) {\n    temp_j_value <- j_vector[j]\n    temp_output <- paste(i, temp_j_value)\n    output_matrix[i, j] <- temp_output\n  }\n}\noutput_vector2 <- as.vector(output_matrix)\noutput_vector2\n\n [1] \"1 a\" \"2 a\" \"3 a\" \"4 a\" \"5 a\" \"1 b\" \"2 b\" \"3 b\" \"4 b\" \"5 b\" \"1 c\" \"2 c\"\n[13] \"3 c\" \"4 c\" \"5 c\" \"1 d\" \"2 d\" \"3 d\" \"4 d\" \"5 d\" \"1 e\" \"2 e\" \"3 e\" \"4 e\"\n[25] \"5 e\"\n\n\n\n\n\n\n\n\nTip: While loops\n\n\n\nSometimes you will find yourself needing to repeat an operation as long as a certain condition is met. You can do this with a while() loop.\n\nwhile(this condition is true){\n do a thing\n}\n\nR will interpret a condition being met as “TRUE”. As an example, here’s a while loop that generates random numbers from a uniform distribution (the runif() function) between 0 and 1 until it gets one that’s less than 0.1.\n\nz <- 1\nwhile(z > 0.1){\n z <- runif(1)\n cat(z, \"\\n\")\n}\n\n0.5074782 \n0.3067685 \n0.4269077 \n0.6931021 \n0.08513597 \n\n\nwhile()` loops will not always be appropriate. You have to be particularly careful that you don’t end up stuck in an infinite loop because your condition is always met and hence the while statement never terminates.\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nCompare the objects output_vector and output_vector2. Are they the same? If not, why not? How would you change the last block of code to make output_vector2 the same as output_vector?\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\nWe can check whether the two vectors are identical using the all() function:\n\nall(output_vector == output_vector2)\n\nHowever, all the elements of output_vector can be found in output_vector2:\n\nall(output_vector %in% output_vector2)\n\nand vice versa:\n\nall(output_vector2 %in% output_vector)\n\ntherefore, the element in output_vector and output_vector2 are just sorted in a different order. This is because as.vector() outputs the elements of an input matrix going over its column. Taking a look at output_matrix, we can notice that we want its elements by rows. The solution is to transpose the output_matrix. We can do it either by calling the transpose function t() or by inputting the elements in the right order. The first solution requires to change the original\n\noutput_vector2 <- as.vector(output_matrix)\n\ninto\n\noutput_vector2 <- as.vector(t(output_matrix))\n\nThe second solution requires to change\n\noutput_matrix[i, j] <- temp_output\n\ninto\n\noutput_matrix[j, i] <- temp_output\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nWrite a script that loops through the gapminder data by continent and prints out whether the mean life expectancy is smaller or larger than 50 years.\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nStep 1: We want to make sure we can extract all the unique values of the continent vector\n\ngapminder <- read.csv(\"data/gapminder_data.csv\")\nunique(gapminder$continent)\n\nStep 2: We also need to loop over each of these continents and calculate the average life expectancy for each subset of data. We can do that as follows:\n\nLoop over each of the unique values of ‘continent’\nFor each value of continent, create a temporary variable storing that subset\nReturn the calculated life expectancy to the user by printing the output:\n\n\nfor (iContinent in unique(gapminder$continent)) {\n tmp <- gapminder[gapminder$continent == iContinent, ]\n cat(iContinent, mean(tmp$lifeExp, na.rm = TRUE), \"\\n\")\n rm(tmp)\n}\n\nStep 3: The exercise only wants the output printed if the average life expectancy is less than 50 or greater than 50. So we need to add an if() condition before printing, which evaluates whether the calculated average life expectancy is above or below a threshold, and prints an output conditional on the result.\nWe need to amend (3) from above:\n3a. If the calculated life expectancy is less than some threshold (50 years), return the continent and a statement that life expectancy is less than threshold, otherwise return the continent and a statement that life expectancy is greater than threshold:\n\nthresholdValue <- 50\nfor (iContinent in unique(gapminder$continent)) {\n  tmp <- mean(gapminder[gapminder$continent == iContinent, \"lifeExp\"])\n  if (tmp < thresholdValue){\n      cat(\"Average Life Expectancy in\", iContinent, \"is less than\", thresholdValue, \"\\n\")\n  } else {\n      cat(\"Average Life Expectancy in\", iContinent, \"is greater than\", thresholdValue, \"\\n\")\n  } # end if else condition\n  rm(tmp)\n} # end for loop\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nModify the script from Challenge 3 to loop over each country. This time print out whether the life expectancy is smaller than 50, between 50 and 70, or greater than 70.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nWe modify our solution to Challenge 3 by now adding two thresholds, lowerThreshold and upperThreshold and extending our if-else statements:\n\nlowerThreshold <- 50\nupperThreshold <- 70\nfor (iCountry in unique(gapminder$country)) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if(tmp < lowerThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", lowerThreshold, \"\\n\")\n   } else if(tmp > lowerThreshold && tmp < upperThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is between\", lowerThreshold, \"and\", upperThreshold, \"\\n\")\n   } else {\n       cat(\"Average Life Expectancy in\", iCountry, \"is greater than\", upperThreshold, \"\\n\")\n   }\n   rm(tmp)\n}\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5 - Advanced\n\n\n\nWrite a script that loops over each country in the gapminder dataset, tests whether the country starts with a ‘B’, and graphs life expectancy against time as a line graph if the mean life expectancy is under 50 years.\n\n\n\n\n\n\nSolution for Challenge 5\n\n\n\n\n\nWe will use the grep() command that was introduced in the Unix Shell lesson to find countries that start with “B.” Lets understand how to do this first. Following from the Unix shell section we may be tempted to try the following\n\ngrep(\"^B\", unique(gapminder$country))\n\nBut when we evaluate this command it returns the indices of the factor variable country that start with “B.” To get the values, we must add the value = TRUE option to the grep() command:\n\ngrep(\"^B\", unique(gapminder$country), value = TRUE)\n\nWe will now store these countries in a variable called candidateCountries, and then loop over each entry in the variable. Inside the loop, we evaluate the average life expectancy for each country, and if the average life expectancy is less than 50 we use base-plot to plot the evolution of average life expectancy using with() and subset():\n\nthresholdValue <- 50\ncandidateCountries <- grep(\"^B\", unique(gapminder$country), value = TRUE)\nfor (iCountry in candidateCountries) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if (tmp < thresholdValue) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", thresholdValue, \"plotting life expectancy graph... \\n\")\n       with(subset(gapminder, country == iCountry),\n               plot(year, lifeExp,\n                    type = \"o\",\n                    main = paste(\"Life Expectancy in\", iCountry, \"over time\"),\n                    ylab = \"Life Expectancy\",\n                    xlab = \"Year\"\n                    ) # end plot\n            ) # end with\n   } # end if\n   rm(tmp)\n} # end for loop"
  },
  {
    "objectID": "06-data-subsetting.html#accessing-elements-using-their-indices",
    "href": "06-data-subsetting.html#accessing-elements-using-their-indices",
    "title": "6  Advanced subsetting",
    "section": "6.1 Accessing elements using their indices",
    "text": "6.1 Accessing elements using their indices\nTo extract elements of a vector we can give their corresponding index, starting from one:\n\nx[1]\n\n  a \n5.4 \n\n\n\nx[4]\n\n  d \n4.8 \n\n\nThe square brackets operator is a function. For vectors, it means “get me the nth element”.\nWe can ask for multiple elements at once by providing a vector if indices:\n\nx[c(1, 3)]\n\n  a   c \n5.4 7.1 \n\n\nOr “slices” of the vector using a sequential integer vector index:\n\nx[1:4]\n\n  a   b   c   d \n5.4 6.2 7.1 4.8 \n\n\nRecall that the : operator creates a sequence of numbers from the left element to the right.\n\n1:4\n\n[1] 1 2 3 4\n\nc(1, 2, 3, 4)\n\n[1] 1 2 3 4\n\n\nWe can ask for the same element multiple times:\n\nx[c(1,1,3)]\n\n  a   a   c \n5.4 5.4 7.1 \n\n\nIf we ask for an index beyond the length of the vector, R will return a missing value:\n\nx[6]\n\n<NA> \n  NA \n\n\nThis is a vector of length one containing an NA, whose name is also NA.\nIf we ask for the 0th element, we get an empty vector:\n\nx[0]\n\nnamed numeric(0)\n\n\n\n\n\n\n\n\nVector numbering in R starts at 1\n\n\n\nIn many programming languages (C and Python, for example), the first element of a vector has an index of 0. In R, the first element is 1."
  },
  {
    "objectID": "06-data-subsetting.html#skipping-and-removing-elements",
    "href": "06-data-subsetting.html#skipping-and-removing-elements",
    "title": "6  Advanced subsetting",
    "section": "6.2 Skipping and removing elements",
    "text": "6.2 Skipping and removing elements\nIf we use a negative number as the index of a vector, R will return every element except for the one specified:\n\nx[-2]\n\n  a   c   d   e \n5.4 7.1 4.8 7.5 \n\n\nWe can skip multiple elements:\n\nx[c(-1, -5)]  # or x[-c(1,5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\n\n\n\n\n\nOrder of operations\n\n\n\nA common trip up for novices occurs when trying to skip slices of a vector. It’s natural to try to negate a sequence like so:\n\nx[-1:3]\n\nThis gives a somewhat cryptic error:\n\n\nError in x[-1:3]: only 0's may be mixed with negative subscripts\n\n\nBut remember the order of operations. : is really a function. It takes its first argument as -1, and its second as 3, so generates the sequence of numbers: c(-1, 0, 1, 2, 3). The correct solution is to wrap that function call in brackets, so that the - operator applies to the result:\n\nx[-(1:3)]\n\n  d   e \n4.8 7.5 \n\n\n\n\nTo remove elements from a vector, we need to re-assign the variable to our result:\n\nx <- x[-4]\nx\n\n  a   b   c   e \n5.4 6.2 7.1 7.5 \n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nprint(x)\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nCome up with at least 2 different commands that will produce the following output:\n\n\n  b   c   d \n6.2 7.1 4.8 \n\n\nAfter you find 2 different commands, compare notes with your neighbour. Did you have different strategies?\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\n\nx[2:4]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[-c(1, 5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(2, 3, 4)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(\"b\", \"c\", \"d\")]\n\n  b   c   d \n6.2 7.1 4.8"
  },
  {
    "objectID": "06-data-subsetting.html#subsetting-by-name",
    "href": "06-data-subsetting.html#subsetting-by-name",
    "title": "6  Advanced subsetting",
    "section": "6.3 Subsetting by name",
    "text": "6.3 Subsetting by name\nWe can extract elements by using their name, instead of extracting by index:\n\nx <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we can name a vector 'on the fly'\nx[c(\"a\", \"c\")]\n\n  a   c \n5.4 7.1 \n\n\nThis is usually a much more reliable way to subset objects: the position of various elements can often change when chaining together subsetting operations, but the names will always remain the same!"
  },
  {
    "objectID": "06-data-subsetting.html#subsetting-through-other-logical-operations",
    "href": "06-data-subsetting.html#subsetting-through-other-logical-operations",
    "title": "6  Advanced subsetting",
    "section": "6.4 Subsetting through other logical operations ",
    "text": "6.4 Subsetting through other logical operations \nWe can also use any logical vector to subset:\n\nx[c(FALSE, FALSE, TRUE, FALSE, TRUE)]\n\n  c   e \n7.1 7.5 \n\n\nSince comparison operators (e.g. >, <, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one.\n\nx[x > 7]\n\n  c   e \n7.1 7.5 \n\n\nBreaking it down, this statement first evaluates x>7, generating a logical vector c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x corresponding to the TRUE values.\nWe can use == to mimic the previous method of indexing by name (remember you have to use == rather than = for comparisons):\n\nnames(x) == \"a\"\n\n[1]  TRUE FALSE FALSE FALSE FALSE\n\nx[names(x) == \"a\"]\n\n  a \n5.4"
  },
  {
    "objectID": "06-data-subsetting.html#removing-named-elements",
    "href": "06-data-subsetting.html#removing-named-elements",
    "title": "6  Advanced subsetting",
    "section": "6.7 Removing named elements",
    "text": "6.7 Removing named elements\nRemoving named elements is a little harder. If we try to remove one named element by negating the string, R complains (slightly obscurely) that it doesn’t know how to take the negative of a string:\n\nx <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we start again by naming a vector 'on the fly'\nx[-\"a\"]\n\nError in -\"a\": invalid argument to unary operator\n\n\nHowever, we can use the != (not-equals) operator to construct a logical vector that will do what we want:\n\nx[names(x) != \"a\"]\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nSkipping multiple named indices is a little bit harder still. Suppose we want to drop the \"a\" and \"c\" elements, so we try this:\n\nx[names(x) != c(\"a\", \"c\")]\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nR did something, but it gave us a warning that we ought to pay attention to - and it apparently gave us the wrong answer (the \"c\" element is still included in the vector)!\nSo what does != actually do in this case? That’s an excellent question.\n\n6.7.1 Recycling\nLet’s take a look at the comparison component of this code:\n\nnames(x) != c(\"a\", \"c\")\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nWhy does R give TRUE as the third element of this vector, when names(x)[3] != \"c\" is obviously false? When you use !=, R tries to compare each element of the left argument with the corresponding element of its right argument. What happens when you compare vectors of different lengths?\n\n\n\nInequality testing\n\n\nWhen one vector is shorter than the other, it gets recycled:\n\n\n\nInequality testing: results of recycling\n\n\nIn this case R repeats c(\"a\", \"c\") as many times as necessary to match names(x), i.e. we get c(\"a\",\"c\",\"a\",\"c\",\"a\"). Since the recycled \"a\" doesn’t match the third element of names(x), the value of != is TRUE. Because in this case the longer vector length (5) isn’t a multiple of the shorter vector length (2), R printed a warning message. If we had been unlucky and names(x) had contained six elements, R would silently have done the wrong thing (i.e., not what we intended it to do). This recycling rule can can introduce hard-to-find and subtle bugs!\nThe way to get R to do what we really want (match each element of the left argument with all of the elements of the right argument) it to use the %in% operator. The %in% operator goes through each element of its left argument, in this case the names of x, and asks, “Does this element occur in the second argument?”. Here, since we want to exclude values, we also need a ! operator to change “in” to “not in”:\n\nx[!(names(x) %in% c(\"a\", \"c\"))]\n\n  b   d   e \n6.2 4.8 7.5 \n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSelecting elements of a vector that match “any of” a list of components is a very common data analysis task.\nSuppose we want to pull out information from Southeast Asia, which includes the countries of Myanmar, Thailand, Cambodia, Vietnam, and Laos.\nYour task is to subset the data just to the rows that include the countries in Southeast Asia\n\nDefine a logical vector that is TRUE for all of the countries in southeast Asia and FALSE otherwise.\nUse this logical vector to extract just the rows for Southeast Asia from the gapminder dataset.\n\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\n\nse_asia = gapminder$country %in% c(\"Myanmar\", \"Thailand\", \"Cambodia\", \"Vietnam\", \"Laos\")\ngapminder[se_asia, ]\n\n      country year      pop continent lifeExp gdpPercap\n217  Cambodia 1952  4693836      Asia  39.417  368.4693\n218  Cambodia 1957  5322536      Asia  41.366  434.0383\n219  Cambodia 1962  6083619      Asia  43.415  496.9136\n220  Cambodia 1967  6960067      Asia  45.415  523.4323\n221  Cambodia 1972  7450606      Asia  40.317  421.6240\n222  Cambodia 1977  6978607      Asia  31.220  524.9722\n223  Cambodia 1982  7272485      Asia  50.957  624.4755\n224  Cambodia 1987  8371791      Asia  53.914  683.8956\n225  Cambodia 1992 10150094      Asia  55.803  682.3032\n226  Cambodia 1997 11782962      Asia  56.534  734.2852\n227  Cambodia 2002 12926707      Asia  56.752  896.2260\n228  Cambodia 2007 14131858      Asia  59.723 1713.7787\n1045  Myanmar 1952 20092996      Asia  36.319  331.0000\n1046  Myanmar 1957 21731844      Asia  41.905  350.0000\n1047  Myanmar 1962 23634436      Asia  45.108  388.0000\n1048  Myanmar 1967 25870271      Asia  49.379  349.0000\n1049  Myanmar 1972 28466390      Asia  53.070  357.0000\n1050  Myanmar 1977 31528087      Asia  56.059  371.0000\n1051  Myanmar 1982 34680442      Asia  58.056  424.0000\n1052  Myanmar 1987 38028578      Asia  58.339  385.0000\n1053  Myanmar 1992 40546538      Asia  59.320  347.0000\n1054  Myanmar 1997 43247867      Asia  60.328  415.0000\n1055  Myanmar 2002 45598081      Asia  59.908  611.0000\n1056  Myanmar 2007 47761980      Asia  62.069  944.0000\n1525 Thailand 1952 21289402      Asia  50.848  757.7974\n1526 Thailand 1957 25041917      Asia  53.630  793.5774\n1527 Thailand 1962 29263397      Asia  56.061 1002.1992\n1528 Thailand 1967 34024249      Asia  58.285 1295.4607\n1529 Thailand 1972 39276153      Asia  60.405 1524.3589\n1530 Thailand 1977 44148285      Asia  62.494 1961.2246\n1531 Thailand 1982 48827160      Asia  64.597 2393.2198\n1532 Thailand 1987 52910342      Asia  66.084 2982.6538\n1533 Thailand 1992 56667095      Asia  67.298 4616.8965\n1534 Thailand 1997 60216677      Asia  67.521 5852.6255\n1535 Thailand 2002 62806748      Asia  68.564 5913.1875\n1536 Thailand 2007 65068149      Asia  70.616 7458.3963\n1645  Vietnam 1952 26246839      Asia  40.412  605.0665\n1646  Vietnam 1957 28998543      Asia  42.887  676.2854\n1647  Vietnam 1962 33796140      Asia  45.363  772.0492\n1648  Vietnam 1967 39463910      Asia  47.838  637.1233\n1649  Vietnam 1972 44655014      Asia  50.254  699.5016\n1650  Vietnam 1977 50533506      Asia  55.764  713.5371\n1651  Vietnam 1982 56142181      Asia  58.816  707.2358\n1652  Vietnam 1987 62826491      Asia  62.820  820.7994\n1653  Vietnam 1992 69940728      Asia  67.662  989.0231\n1654  Vietnam 1997 76048996      Asia  70.672 1385.8968\n1655  Vietnam 2002 80908147      Asia  73.017 1764.4567\n1656  Vietnam 2007 85262356      Asia  74.249 2441.5764\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: filter\n\n\n\nIn the dplyr lesson, you will learn another method of filtering to rows of a data frame that satisfy a certain condition using the filter() function from the dplyr package in the tidyverse suite."
  },
  {
    "objectID": "06-data-subsetting.html#handling-special-values",
    "href": "06-data-subsetting.html#handling-special-values",
    "title": "6  Advanced subsetting",
    "section": "6.7 Handling special values",
    "text": "6.7 Handling special values\nAt some point you will encounter functions in R that cannot handle missing, infinite, or undefined data.\nThere are a number of special functions you can use to filter out this data:\n\nis.na will return all positions in a vector, matrix, or data.frame containing NA (or NaN)\nlikewise, is.nan, and is.infinite will do the same for NaN and Inf.\nis.finite will return all positions in a vector, matrix, or data.frame that do not contain NA, NaN or Inf.\nna.omit will filter out all missing values from a vector"
  },
  {
    "objectID": "06-data-subsetting.html#factor-subsetting",
    "href": "06-data-subsetting.html#factor-subsetting",
    "title": "6  Advanced subsetting",
    "section": "6.8 Factor subsetting",
    "text": "6.8 Factor subsetting\nNow that we’ve explored the different ways to subset vectors, how do we subset the other data structures?\nFactor subsetting works the same way as vector subsetting.\n\nf <- factor(c(\"a\", \"a\", \"b\", \"c\", \"c\", \"d\"))\nf[f == \"a\"]\n\n[1] a a\nLevels: a b c d\n\nf[f %in% c(\"b\", \"c\")]\n\n[1] b c c\nLevels: a b c d\n\nf[1:3]\n\n[1] a a b\nLevels: a b c d\n\n\nSkipping elements will not remove the level even if no more of that category exists in the factor:\n\nf[-3]\n\n[1] a a c c d\nLevels: a b c d"
  },
  {
    "objectID": "06-data-subsetting.html#list-subsetting",
    "href": "06-data-subsetting.html#list-subsetting",
    "title": "6  Advanced subsetting",
    "section": "6.9 List subsetting",
    "text": "6.9 List subsetting\nNow we’ll introduce some new subsetting operators. There are three functions used to subset lists. We’ve already seen these when learning about atomic vectors and matrices: [, [[, and $.\nUsing [ will always return a list. If you want to subset a list, but not extract an element, then you will likely use [.\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist[1]\n\n$a\n[1] \"Software Carpentry\"\n\n\nThis returns a list with one element.\nWe can subset elements of a list exactly the same way as atomic vectors using [. Comparison operations however won’t work as they’re not recursive, they will try to condition on the data structures in each element of the list, not the individual elements within those data structures.\n\nxlist[1:2]\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nTo extract individual elements of a list, you need to use the double-square bracket function: [[.\n\nxlist[[1]]\n\n[1] \"Software Carpentry\"\n\n\nNotice that now the result is a vector, not a list.\nYou can’t extract more than one element at once:\n\nxlist[[1:2]]\n\nError in xlist[[1:2]]: subscript out of bounds\n\n\nNor use it to skip elements:\n\nxlist[[-1]]\n\nError in xlist[[-1]]: invalid negative subscript in get1index <real>\n\n\nBut you can use names to both subset and extract elements:\n\nxlist[[\"a\"]]\n\n[1] \"Software Carpentry\"\n\n\nThe $ function is a shorthand way for extracting elements by name:\n\nxlist$data\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nGiven the following list:\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nUsing list and vector subsetting, extract the second entry in the second element of the list (i.e., extract the number 2 from the b entry from xlist`). There are several ways to do this. Compare your answer with your neighbor. Did you do it the same way?\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\n\nxlist$b[2]\n\n[1] 2\n\n\n\nxlist[[2]][2]\n\n[1] 2\n\n\n\nxlist[[\"b\"]][2]\n\n[1] 2"
  },
  {
    "objectID": "06-data-subsetting.html#data-frames",
    "href": "06-data-subsetting.html#data-frames",
    "title": "6  Advanced subsetting",
    "section": "6.10 Data frames",
    "text": "6.10 Data frames\nRemember the data frames are lists underneath the hood, so similar rules apply. However they are also two dimensional objects:\n[ with one argument will act the same way as for lists, where each list element corresponds to a column. The resulting object will be a data frame:\n\nhead(gapminder[3])\n\n       pop\n1  8425333\n2  9240934\n3 10267083\n4 11537966\n5 13079460\n6 14880372\n\n\nSimilarly, [[ will act to extract a single column as a vector:\n\nhead(gapminder[[3]])\n\n[1]  8425333  9240934 10267083 11537966 13079460 14880372\n\n\nNotice the difference in the way the two results are presented (the first is a data frame, the second is a vector)\n\nhead(gapminder[[\"lifeExp\"]])\n\n[1] 28.801 30.332 31.997 34.020 36.088 38.438\n\n\nAnd $ provides a convenient shorthand to extract columns by name:\n\nhead(gapminder$year)\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nWith two arguments, [ behaves lets us extract multiple rows and columns:\n\ngapminder[1:3, ]\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nIf we subset a single row, the result will be a data frame (because the elements are mixed types, they can’t be a vector):\n\ngapminder[3, ]\n\n      country year      pop continent lifeExp gdpPercap\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nFor a single column the result will be a vector (this can be changed with the third argument, drop = FALSE).\n\nhead(gapminder[, 2])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nwhich is equivalent to\n\nhead(gapminder[[2]])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nEach of the following pieces of code are incorrect. Identify the error and fix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\ngapminder[gapminder$year = 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\ngapminder[, -1:4]\n\n\nExtract the rows where the life expectancy is longer the 80 years\n\n\ngapminder[gapminder$lifeExp > 80]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\ngapminder[1, 4, 5]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\ngapminder[gapminder$year == 2002 | 2007, ]\n\n\n\n\n\n\n\nSolution to challenge 6\n\n\n\n\n\nFix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\n# gapminder[gapminder$year = 1957, ]\ngapminder[gapminder$year == 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\n# gapminder[, -1:4]\ngapminder[, -c(1:4)]\n\n\nExtract the rows where the life expectancy is longer than 80 years\n\n\n# gapminder[gapminder$lifeExp > 80]\ngapminder[gapminder$lifeExp > 80, ]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\n# gapminder[1, 4, 5]\ngapminder[1, c(4, 5)]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\n# gapminder[gapminder$year == 2002 | 2007, ]\ngapminder[gapminder$year == 2002 | gapminder$year == 2007, ]\n# or\ngapminder[gapminder$year %in% c(2002, 2007), ]\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 7\n\n\n\n\nWhy does gapminder[1:20] return an error? How does it differ from gapminder[1:20, ]?\nCreate a new data.frame called gapminder_subset that only contains rows 1 through 9 and rows 19 through 23.\n\n\n\n\n\n\n\nSolution to challenge 7\n\n\n\n\n\n\ngapminder[1:20] tries to extract the first 20 columns, but there are not 20 columns. gapminder[1:20, ] subsets the data to give the first 20 rows and all columns.\n\n\n\ngapminder_subset <- gapminder[c(1:9, 19:23), ]"
  },
  {
    "objectID": "05-data-structures-part2.html#data-example",
    "href": "05-data-structures-part2.html#data-example",
    "title": "5  Adding/removing data from data frames",
    "section": "5.5 Data example",
    "text": "5.5 Data example\nSo far, you have seen the basics of manipulating data frames with our cat data; now let’s use those skills to digest a more realistic dataset. Let’s read in the gapminder dataset that we downloaded previously:\n\ngapminder <- read.csv(\"data/gapminder_data.csv\")\n\n\n\n\n\n\n\nTip: Loading files from the internet\n\n\n\nYou can also read in files directly into R from the Internet by replacing the file paths with a web address in read.csv. Note that in doing this no local copy of the csv file is first saved onto your computer. For example,\n\ngapminder <- read.csv(\"<INSERT URL HERE>\")\n\n\n\n\n\n\n\n\n\nTip: Loading excel files\n\n\n\nYou can read directly from excel spreadsheets using the readxl package.\n\n\nLet’s investigate gapminder a bit; the first thing we should always do is check out what the data looks like with head() and str():\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\nAn additional method for examining the structure of gapminder is to use the summary() function. summary yields a numeric, tabular, or descriptive summary of each column. Factor columns are summarized by the number of items in each level, numeric or integer columns by the descriptive statistics (quartiles and mean), and character columns by its length, class, and mode.\n\nsummary(gapminder)\n\n   country               year           pop             continent        \n Length:1704        Min.   :1952   Min.   :6.001e+04   Length:1704       \n Class :character   1st Qu.:1966   1st Qu.:2.794e+06   Class :character  \n Mode  :character   Median :1980   Median :7.024e+06   Mode  :character  \n                    Mean   :1980   Mean   :2.960e+07                     \n                    3rd Qu.:1993   3rd Qu.:1.959e+07                     \n                    Max.   :2007   Max.   :1.319e+09                     \n    lifeExp        gdpPercap       \n Min.   :23.60   Min.   :   241.2  \n 1st Qu.:48.20   1st Qu.:  1202.1  \n Median :60.71   Median :  3531.8  \n Mean   :59.47   Mean   :  7215.3  \n 3rd Qu.:70.85   3rd Qu.:  9325.5  \n Max.   :82.60   Max.   :113523.1  \n\n\nWe can also interrogate the data frame for information about its dimensions; remembering that str(gapminder) said there were 1704 observations of 6 variables in gapminder, what do you think the following will produce, and why?\n\nlength(gapminder)\n\n[1] 6\n\n\nA fair guess would have been to say that the length of a data frame would be the number of rows it has (1704), but this is not the case; remember, a data frame is a list of vectors. When length gave us 6, it’s because gapminder is built out of a list of 6 vectors. To get the number of rows and columns in our dataset, try:\n\nnrow(gapminder)\n\n[1] 1704\n\nncol(gapminder)\n\n[1] 6\n\n\nOr, both at once:\n\ndim(gapminder)\n\n[1] 1704    6\n\n\nWe’ll also likely want to know what the titles of all the columns are, so we can ask for them later:\n\ncolnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nAt this stage, it’s important to ask ourselves if the structure R is reporting matches our intuition or expectations; do the basic data types reported for each column make sense? If not, we need to sort any problems out now before they turn into bad surprises down the road, using what we’ve learned about how R interprets data, and the importance of strict consistency in how we record our data.\n\n\n\n\n\n\nChallenge 3\n\n\n\nIt’s good practice to also check the last few lines of your data and some in the middle. How would you do this? Searching for ones specifically in the middle isn’t too hard, but we could ask for a few lines at random. How would you code this?\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nTo check the last few lines it’s relatively simple as R already has a function for this:\n\ntail(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\ntail(gapminder, n = 15)\n\n      country year      pop continent lifeExp gdpPercap\n1690   Zambia 1997  9417789    Africa  40.238 1071.3538\n1691   Zambia 2002 10595811    Africa  39.193 1071.6139\n1692   Zambia 2007 11746035    Africa  42.384 1271.2116\n1693 Zimbabwe 1952  3080907    Africa  48.451  406.8841\n1694 Zimbabwe 1957  3646340    Africa  50.469  518.7643\n1695 Zimbabwe 1962  4277736    Africa  52.358  527.2722\n1696 Zimbabwe 1967  4995432    Africa  53.995  569.7951\n1697 Zimbabwe 1972  5861135    Africa  55.635  799.3622\n1698 Zimbabwe 1977  6642107    Africa  57.674  685.5877\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\n\nWhat about a few arbitrary rows just in case something is odd in the middle?\n\n5.6 Tip: There are several ways to achieve this.\nThe solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!\nRemember my_dataframe[rows, cols] will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don’t know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.\n\ngapminder[sample(nrow(gapminder), 5), ]\n\n               country year     pop continent lifeExp gdpPercap\n1394           Somalia 1957 2780415    Africa  34.977 1258.1474\n931             Malawi 1982 6502825    Africa  45.642  632.8039\n559             Gambia 1982  715523    Africa  45.580  835.8096\n491  Equatorial Guinea 2002  495627    Africa  49.348 7703.4959\n201       Burkina Faso 1992 8878303    Africa  50.260  931.7528\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nIt’s good practice to also check the last few lines of your data too. How would you do this?\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nTo check the last few lines it’s relatively simple as R already has a function for this:\n\ntail(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\ntail(gapminder, n = 15)\n\n      country year      pop continent lifeExp gdpPercap\n1690   Zambia 1997  9417789    Africa  40.238 1071.3538\n1691   Zambia 2002 10595811    Africa  39.193 1071.6139\n1692   Zambia 2007 11746035    Africa  42.384 1271.2116\n1693 Zimbabwe 1952  3080907    Africa  48.451  406.8841\n1694 Zimbabwe 1957  3646340    Africa  50.469  518.7643\n1695 Zimbabwe 1962  4277736    Africa  52.358  527.2722\n1696 Zimbabwe 1967  4995432    Africa  53.995  569.7951\n1697 Zimbabwe 1972  5861135    Africa  55.635  799.3622\n1698 Zimbabwe 1977  6642107    Africa  57.674  685.5877\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nGo to file -> new file -> R script, and write an R script called load.R which contains R code that loads the gapminder dataset. Save load.R in the functions/ directory.\nRun the script in a chunk in your quarto document using the source() function, using the file path as its argument:\n\nsource(\"functions/load.R\")"
  },
  {
    "objectID": "04-data-structures-part1.html",
    "href": "04-data-structures-part1.html",
    "title": "4  Data Structures",
    "section": "",
    "text": "5 Names\nWith names, we can give meaning to elements. It is the first time that we do not only have the data, but also explaining information. It is metadata that can be stuck to the object like a label. In R, this is called an attribute. Some attributes enable us to do more with our object, for example, like here, accessing an element by a self-defined name.\nWe introduced data frames at the very beginning of this lesson, they represent a table of data. Recall our cats data frame:\nColumns of a data frame are vectors of different types, but of the same length, that are organized by belonging to the same table.\nIn our cats example, we have an character, a numeric, and a logical column/variable. As we have seen already, each column of data.frame is a vector."
  },
  {
    "objectID": "04-data-structures-part1.html#data-types",
    "href": "04-data-structures-part1.html#data-types",
    "title": "4  Data Structures",
    "section": "4.1 Data Types",
    "text": "4.1 Data Types\nIf you guessed that the last command will return an error because 2.1 plus \"black\" is nonsense, you’re right - and you already have some intuition for an important concept in programming called data types. We can ask what type or “class” of data something is:\n\nclass(cats$weight)\n\n[1] \"numeric\"\n\n\nYou will typically encounter the following main types: numeric (which encompasses double and integer), logical, character (and factor, but we won’t encounter these until later). There are others too (such as complex), but you’re unlikely to encounter them in your data analysis journeys.\nLet’s identify the class of several values:\n\nclass(3.14)\n\n[1] \"numeric\"\n\nclass(TRUE)\n\n[1] \"logical\"\n\nclass(\"banana\")\n\n[1] \"character\"\n\n\nNo matter how complicated our analyses become, all data in R is interpreted as one of these basic data types. This strictness has some really important consequences.\nA user has added details of another cat. This information is in the file data/feline-data_v2.csv.\n\nfile.show(\"data/feline-data_v2.csv\")\n\n\ncoat,weight,likes_string\ncalico,2.1,1\nblack,5.0,0\ntabby,3.2,1\ntabby,2.3 or 2.4,1\n\nLoad the new cats data like before, and check what type of data we find in the weight column:\n\ncats_v2 <- read.csv(file=\"data/feline-data_v2.csv\")\nclass(cats_v2$weight)\n\n[1] \"character\"\n\n\nOh no, our weights aren’t the numeric class anymore! If we try to do the same math we did on them before, we run into trouble:\n\ncats_v2$weight + 2\n\nError in cats_v2$weight + 2: non-numeric argument to binary operator\n\n\nWhat happened?\nThe cats data we are working with is something called a data frame. Data frames are one of the most common and versatile types of data structures we will work with in R.\nA given column in a data frame can only contain one single data type (but each column can be of a different type).\nIn this case, R does not read everything in the data frame column weight as numeric (specifically, R reads the entry 2.3 or 2.4 as a character), therefore the entire column data type changes to something that is suitable for everything in the column.\nWhen R reads a csv file, it reads it in as a data frame. Thus, when we loaded the cats csv file, it is stored as a data frame. We can recognize data frames by the first row that is written by the str() function:\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\"\n $ weight      : num  2.1 5 3.2\n $ likes_string: int  1 0 1\n\n\nData frames are composed of rows and columns, where each column has the same number of rows. Different columns in a data frame can be made up of different data types (this is what makes them so versatile), but everything in a given column needs to be the same type (e.g., numeric, character, logical, etc).\nLet’s explore more about different data structures and how they behave. For now, let’s go back to working with the original feline-data.csv file while we investigate this behavior further:\nfeline-data.csv:\ncoat,weight,likes_string\ncalico,2.1,1\nblack,5.0,0\ntabby,3.2,1\n\ncats <- read.csv(file = \"data/feline-data.csv\")\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1"
  },
  {
    "objectID": "04-data-structures-part1.html#vectors-and-type-coercion",
    "href": "04-data-structures-part1.html#vectors-and-type-coercion",
    "title": "4  Data Structures",
    "section": "4.2 Vectors and Type Coercion",
    "text": "4.2 Vectors and Type Coercion\nTo better understand this behavior, let’s learn more about the vector. A vector in R is essentially an ordered collection of values, with the special condition that everything in the vector must be the same basic data type.\nA vector can be created with the c() “combine” function:\n\nc(1, 8, 1.2)\n\n[1] 1.0 8.0 1.2\n\n\nThe columns of a data frame are also vectors:\n\ncats$weight\n\n[1] 2.1 5.0 3.2\n\n\nThe fact that everything in a vector must be the same type is the root of why R forces everything in a column to be the same basic data type.\n\n4.2.1 Coercion by combining vectors\nBecause all entries in a vector must have the same type, c() will coerce the type of each element to a common type. Given what we’ve learned so far, what do you think the following will produce?\n\nquiz_vector <- c(2, 6, '3')\n\nThis is something called type coercion, and it is the source of many surprises and the reason why we need to be aware of the basic data types and how R will interpret them. When R encounters a mix of types (here numeric and character) to be combined into a single vector, it will force them all to be the same type. Consider:\n\ncoercion_vector <- c('a', TRUE)\ncoercion_vector\n\n[1] \"a\"    \"TRUE\"\n\nanother_coercion_vector <- c(0, TRUE)\nanother_coercion_vector\n\n[1] 0 1\n\n\n\n\n4.2.2 The type hierarchy\nThe coercion rules go: logical -> numeric -> character, where -> can be read as “are transformed into”. For example, combining logical and character transforms the result to character:\n\nc('a', TRUE)\n\n[1] \"a\"    \"TRUE\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nA quick way to recognize character vectors is by the quotes that enclose them when they are printed.\n\n\nYou can try to force coercion against this flow using the as. functions:\n\ncharacter_vector_example <- c('0', '2', '4')\ncharacter_vector_example\n\n[1] \"0\" \"2\" \"4\"\n\ncharacter_coerced_to_numeric <- as.numeric(character_vector_example)\ncharacter_coerced_to_numeric\n\n[1] 0 2 4\n\nnumeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)\nnumeric_coerced_to_logical\n\n[1] FALSE  TRUE  TRUE\n\n\nAs you can see, some surprising things can happen when R forces one basic data type into another! Nitty-gritty of type coercion aside, the point is: if your data doesn’t look like what you thought it was going to look like, type coercion may well be to blame; make sure everything is the same type in your vectors and your columns of data.frames, or you will get nasty surprises!\nBut coercion can also be very useful! For example, in our cats data likes_string is numeric, but we know that the 1s and 0s actually represent TRUE and FALSE (a common way of representing them). We should use the logical datatype here, which has two states: TRUE or FALSE, which is exactly what our data represents. We can ‘coerce’ this column to be logical by using the as.logical function:\n\ncats$likes_string\n\n[1] 1 0 1\n\ncats$likes_string <- as.logical(cats$likes_string)\ncats$likes_string\n\n[1]  TRUE FALSE  TRUE\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nAn important part of every data analysis is cleaning the input data. If you know that the input data is all of the same format, (e.g. numbers), your analysis is much easier! In this exercise, you will clean the cat data set from the chapter about type coercion.\n\n4.2.3 Copy the code template\nIn your quarto file in RStudio, start a new code chunk and copy and paste the following code. Then move on to the tasks below, which will help you to fill in the gaps (______).\n\n# Read data\ncats <- read.csv(\"data/feline-data_v2.csv\")\n# 1. Print the data\n_____\n\n# 2. Show an overview of the table that prints out the type of each column\n_____(cats)\n\n# 3. The \"weight\" column has the incorrect data type __________.\n#    The correct data type is: ____________.\n\n# 4. Correct the 4th weight data point with the mean of the two given values\ncats$weight[4] <- 2.35\n#    print the data again to see the effect\ncats\n\n# 5. Convert the weight to the right data type\ncats$weight <- ______________(cats$weight)\n\n#    Calculate the mean to test yourself\nmean(cats$weight)\n\n# If you see the correct mean value (and not NA), you did the exercise\n# correctly!\n\n\n\n4.3 Instructions for the tasks\n\n4.3.1 1. Print the data\nExecute the first statement (read.csv(...)). Then print the data to the console\n\n\n\n\n\n\nTip 1.1\n\n\n\nPrint the contents of any variable by typing its name.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.1\n\n\n\n\n\nTwo correct solutions:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\nprint(cats)\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\n\n\n\n\n\n\n4.3.2 2. Overview of the data types\nUse a function we saw earlier to print out the “type” of all columns of the cats table.\n\n\n\n\n\n\nTip 1.2\n\n\n\nIn the chapter “Data types” we saw two functions that can show data types. One printed just a single word, the data type name. The other printed a short form of the data type, and the first few values. We recommend the second here.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.2\n\n\n\n\n\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\"\n $ weight      : num  2.1 5 3.2\n $ likes_string: logi  TRUE FALSE TRUE\n\n\n\n\n\n\n\n4.3.3 3. Which data type do we need?\nThe shown data type is not the right one for this data (weight of a cat). Which data type do we need?\n\nWhy did the read.csv() function not choose the correct data type?\nFill in the gap in the comment with the correct data type for cat weight!\n\n\n\n\n\n\n\nTip 1.3\n\n\n\nScroll up to the section about the type hierarchy to review the available data types\n\n\n\n\n\n\n\n\nSolution to Challenge 1.3\n\n\n\n\nWeight is expressed on a continuous scale (real numbers). The R data type for this is “numeric”.\nThe fourth row has the value “2.3 or 2.4”. That is not a number but two, and an english word. Therefore, the “character” data type is chosen. The whole column is now text, because all values in the same columns have to be the same data type.\n\n\n\n\n\n4.3.4 4. Correct the problematic value\nThe code to assign a new weight value to the problematic fourth row is given. Think first and then execute it: What will be the data type after assigning a number like in this example? You can check the data type after executing to see if you were right.\n\n\n\n\n\n\nTip 1.4\n\n\n\nRevisit the hierarchy of data types when two different data types are combined.\n\n\n\n\n\n\n\n\nSolution to challenge 1.4\n\n\n\n\n\nThe data type of the column “weight” is “character”. The assigned data type is “numeric”. Combining two data types yields the data type that is higher in the following hierarchy:\n\nlogical < numeric < character\n\nTherefore, the column is still of type character! We need to manually convert it to “numeric”.\n\n\n\n\n\n4.3.5 5. Convert the column “weight” to the correct data type\nCat weight are numbers. But the column does not have this data type yet. Coerce the column to floating point numbers.\n\n\n\n\n\n\nTip 1.5\n\n\n\nThe functions to convert data types start with as.. You can look for the function further up in the manuscript or use the RStudio auto-complete function: Type “as.” and then press the TAB key.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.5\n\n\n\n\n\n\ncats$weight <- as.numeric(cats$weight)"
  },
  {
    "objectID": "04-data-structures-part1.html#instructions-for-the-tasks",
    "href": "04-data-structures-part1.html#instructions-for-the-tasks",
    "title": "4  Data Structures",
    "section": "4.3 Instructions for the tasks",
    "text": "4.3 Instructions for the tasks\n\n4.3.1 1. Print the data\nExecute the first statement (read.csv(...)). Then print the data to the console\n\n\n\n\n\n\nTip 1.1\n\n\n\nPrint the contents of any variable by typing its name.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.1\n\n\n\n\n\nTwo correct solutions:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\nprint(cats)\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\n\n\n\n\n\n\n4.3.2 2. Overview of the data types\nUse a function we saw earlier to print out the “type” of all columns of the cats table.\n\n\n\n\n\n\nTip 1.2\n\n\n\nIn the chapter “Data types” we saw two functions that can show data types. One printed just a single word, the data type name. The other printed a short form of the data type, and the first few values. We recommend the second here.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.2\n\n\n\n\n\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\"\n $ weight      : num  2.1 5 3.2\n $ likes_string: logi  TRUE FALSE TRUE\n\n\n\n\n\n\n\n4.3.3 3. Which data type do we need?\nThe shown data type is not the right one for this data (weight of a cat). Which data type do we need?\n\nWhy did the read.csv() function not choose the correct data type?\nFill in the gap in the comment with the correct data type for cat weight!\n\n\n\n\n\n\n\nTip 1.3\n\n\n\nScroll up to the section about the type hierarchy to review the available data types\n\n\n\n\n\n\n\n\nSolution to Challenge 1.3\n\n\n\n\nWeight is expressed on a continuous scale (real numbers). The R data type for this is “numeric”.\nThe fourth row has the value “2.3 or 2.4”. That is not a number but two, and an english word. Therefore, the “character” data type is chosen. The whole column is now text, because all values in the same columns have to be the same data type.\n\n\n\n\n\n4.3.4 4. Correct the problematic value\nThe code to assign a new weight value to the problematic fourth row is given. Think first and then execute it: What will be the data type after assigning a number like in this example? You can check the data type after executing to see if you were right.\n\n\n\n\n\n\nTip 1.4\n\n\n\nRevisit the hierarchy of data types when two different data types are combined.\n\n\n\n\n\n\n\n\nSolution to challenge 1.4\n\n\n\n\n\nThe data type of the column “weight” is “character”. The assigned data type is “numeric”. Combining two data types yields the data type that is higher in the following hierarchy:\n\nlogical < numeric < character\n\nTherefore, the column is still of type character! We need to manually convert it to “numeric”.\n\n\n\n\n\n4.3.5 5. Convert the column “weight” to the correct data type\nCat weight are numbers. But the column does not have this data type yet. Coerce the column to floating point numbers.\n\n\n\n\n\n\nTip 1.5\n\n\n\nThe functions to convert data types start with as.. You can look for the function further up in the manuscript or use the RStudio auto-complete function: Type “as.” and then press the TAB key.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.5\n\n\n\n\n\n\ncats$weight <- as.numeric(cats$weight)"
  },
  {
    "objectID": "04-data-structures-part1.html#some-basic-functions-for-creating-vectors",
    "href": "04-data-structures-part1.html#some-basic-functions-for-creating-vectors",
    "title": "4  Data Structures",
    "section": "4.5 Some basic functions for creating vectors",
    "text": "4.5 Some basic functions for creating vectors\nThe combine function, c(), can also be used both to create a new vector as well as to append things to an existing vector:\n\nab_vector <- c('a', 'b')\nab_vector\n\n[1] \"a\" \"b\"\n\ncombine_example <- c(ab_vector, 'z')\ncombine_example\n\n[1] \"a\" \"b\" \"z\"\n\n\nYou can also make series of numbers using the : syntax as well as the seq() function:\n\nmySeries <- 1:10\nmySeries\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10, by = 0.1)\n\n [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4\n[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9\n[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4\n[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9\n[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4\n[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9\n[91] 10.0\n\n\nThe head() and tail() functions show the first and last few entries of a vector, respectively.\n\nsequence_example <- 20:25\nhead(sequence_example, n = 2)\n\n[1] 20 21\n\ntail(sequence_example, n = 4)\n\n[1] 22 23 24 25\n\n\nThe length() function computes the number of entries in the vector:\n\nlength(sequence_example)\n\n[1] 6\n\n\nAnd the class() function reports the class/type of the values in the vector:\n\nclass(sequence_example)\n\n[1] \"integer\"\n\n\nWe can extract individual elements of a vector by using the square bracket notation:\n\nfirst_element <- sequence_example[1]\nfirst_element\n\n[1] 20\n\n\nTo change a single element, use the bracket on the other side of the arrow:\n\nsequence_example[1] <- 30\nsequence_example\n\n[1] 30 21 22 23 24 25\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nStart by making a vector with the numbers 5 through 26. Then:\n\nPrint out the first three entries of the vector\nExtract the fourth entry of the vector\nMultiply the vector by 2.\n\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nx <- 5:26\nhead(x, 3)\n\n[1] 5 6 7\n\nx[4]\n\n[1] 8\n\nx <- x * 2\nx\n\n [1] 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52"
  },
  {
    "objectID": "04-data-structures-part1.html#accessing-vectors-by-name",
    "href": "04-data-structures-part1.html#accessing-vectors-by-name",
    "title": "4  Data Structures",
    "section": "5.1 Accessing vectors by name",
    "text": "5.1 Accessing vectors by name\nEach element of a vector can be given a name:\n\npizza_price <- c(pizzasubito = 5.64, pizzafresh = 6.60, callapizza = 4.50)\n\nTo retrieve a specific named entry from a vector, we can use the square bracket notation:\n\npizza_price[\"pizzasubito\"]\n\npizzasubito \n       5.64 \n\n\nwhich is equivalent to extracting the first entry of the vector:\n\npizza_price[1]\n\npizzasubito \n       5.64"
  },
  {
    "objectID": "04-data-structures-part1.html#accessing-and-changing-names",
    "href": "04-data-structures-part1.html#accessing-and-changing-names",
    "title": "4  Data Structures",
    "section": "5.2 Accessing and changing names",
    "text": "5.2 Accessing and changing names\nIf you want to extract just the names of an object, use the names() function:\n\nnames(pizza_price)\n\n[1] \"pizzasubito\" \"pizzafresh\"  \"callapizza\" \n\n\nWe have seen how to access and change single elements of a vector. The same is possible for names:\n\nnames(pizza_price)[3]\n\n[1] \"callapizza\"\n\nnames(pizza_price)[3] <- \"call-a-pizza\"\npizza_price\n\n pizzasubito   pizzafresh call-a-pizza \n        5.64         6.60         4.50 \n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nWhat is the data type of the names of pizza_price? You can find out using the str() or class() functions.\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nYou get the names of an object by wrapping the object name inside names(...). Similarly, you get the data type of the names by again wrapping the whole code in class(...):\n\nclass(names(pizza_price))\n\n[1] \"character\"\n\n\nalternatively, use a new variable if this is easier for you to read:\n\nnames <- names(pizza_price)\nclass(names)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nInstead of just changing the names of each element of a vector individually, you can also set all names of an object by writing code like (replace ALL CAPS text):\n\nnames( OBJECT ) <-  CHARACTER_VECTOR\n\nCreate a vector that gives the number for each letter in the alphabet!\n\nGenerate a vector called letter_no with the sequence of numbers from 1 to 26\nR has a built-in object called LETTERS (type LETTERS in the console. It is a 26-character vector of uppercase letters from A to Z. Set the names of letter_no to these 26 letters\nTest yourself by calling letter_no[\"B\"], which should give you the number 2!\n\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\n\nletter_no <- 1:26   # or seq(1,26)\nnames(letter_no) <- LETTERS\nletter_no[\"B\"]\n\nB \n2"
  },
  {
    "objectID": "04-data-structures-part1.html#extracting-information-from-a-data-frame",
    "href": "04-data-structures-part1.html#extracting-information-from-a-data-frame",
    "title": "4  Data Structures",
    "section": "6.1 Extracting information from a data frame",
    "text": "6.1 Extracting information from a data frame\nThere are several ways to extract an individual column in a data frame, including using the $ notation that we used above:\n\ncats$coat\n\n[1] calico black  tabby \nLevels: black calico tabby\n\n\nBut a column can also be accessed using the square bracket notation:\n\ncats[, 1]\n\n[1] calico black  tabby \nLevels: black calico tabby\n\n\nwhich returns the column as a vector.\nThe syntax df[i, j] to extract the entry in the ith row and the jth column from the data frame called df. For example, df[3, 1] will extract the single entry in the third row and first column.\nA blank i or j this tells R to extract all of the rows or columns, respectively. That is, df[, 1] will extract all rows for the 1st column, and df[2, ] will extract the second row across all columns.\n\n6.1.1 The square bracket syntax [ ]\n\ndf[, j] will extract the jth column from the data frame called df as a vector.\ndf[i, ] will extract the ith row from the data frame called df as a data frame.\n\nFor example the following code extracts the data from the second column of cats as a vector\n\ncats[, 2]\n\n[1] 2.1 5.0 3.2\n\n\nand the following code extracts the second row of cats as a data frame:\n\ncats[2, ]\n\n   coat weight likes_string\n2 black      5        FALSE\n\n\nNote, to extract the \\(j\\)th column from a data frame as a single-column data frame, you can use the single-dimension square bracket syntax: df[j].\n\ncats[2]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\nThis syntax also works with named indexing.\n\ncats[\"weight\"]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\nWe will explain a bit more about this momentarily.\n\n\n\n\n\n\nChallenge 5\n\n\n\nThere are several subtly different ways to call variables, observations and elements from data.frames:\n\ncats[1]\ncats$coat\ncats[\"coat\"]\ncats[1, 1]\ncats[, 1]\ncats[1, ]\n\nTry out these examples and explain what is returned by each one.\nHint: Use the function class() to examine what is returned in each case.\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\n\ncats[1]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nWe can think of a data frame as a list of vectors. The single brace [1] returns the first slice of the list, as another list. In this case it is the first column of the data frame.\n\ncats$coat\n\n[1] calico black  tabby \nLevels: black calico tabby\n\n\nThis example uses the $ character to address items by name. coat is the first column of the data frame, again a vector of type character.\n\ncats[\"coat\"]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nHere we are using a single brace [\"coat\"] replacing the index number with the column name. Like example 1, the returned object is a list.\n\ncats[1, 1]\n\n[1] calico\nLevels: black calico tabby\n\n\nThis example uses a single brace, but this time we provide row and column coordinates. The returned object is the value in row 1, column 1. The object is a vector of type character.\n\ncats[, 1]\n\n[1] calico black  tabby \nLevels: black calico tabby\n\n\nLike the previous example we use single braces and provide row and column coordinates. The row coordinate is not specified, R interprets this missing value as all the elements in this column and returns them as a vector.\n\ncats[1, ]\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n\n\nAgain we use the single brace with row and column coordinates. The column coordinate is not specified. The return value is a list containing all the values in the first row.\n\n\n\n\n\n\n\n\n\n\n\nTip: Renaming data frame columns\n\n\n\nLike vectors, data frames have column names, which can be accessed with the names() function.\n\nnames(cats)\n\n[1] \"coat\"         \"weight\"       \"likes_string\"\n\n\nIf you want to rename the second column of cats, you can assign a new name to the second element of names(cats).\n\nnames(cats)[2] <- \"weight_kg\"\ncats\n\n    coat weight_kg likes_string\n1 calico       2.1         TRUE\n2  black       5.0        FALSE\n3  tabby       3.2         TRUE"
  },
  {
    "objectID": "04-data-structures-part1.html#lists",
    "href": "04-data-structures-part1.html#lists",
    "title": "4  Data Structures",
    "section": "6.2 Lists",
    "text": "6.2 Lists\nAnother data structure is the list.\nList are very flexible because you can put anything you want in it: unlike a vector, the elements of a list can have different data types. For example:\n\nlist_example <- list(1, \"a\", TRUE)\nlist_example\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n\nLike a vector, the “length” of a list corresponds to how many entries it contains:\n\nlength(list_example)\n\n[1] 3\n\n\nWhen printing the object structure with str(), we see the data types of all elements:\n\nstr(list_example)\n\nList of 3\n $ : num 1\n $ : chr \"a\"\n $ : logi TRUE\n\n\nTo retrieve one of the elements of a list, we use the double bracket notation:\n\nlist_example[[2]]\n\n[1] \"a\"\n\n\nThe elements of lists also can have names, they can be given by prepending them to the values, separated by an equals sign:\n\nanother_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE)\nanother_list\n\n$title\n[1] \"Numbers\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n[1] TRUE\n\n\nThis results in a named list. Now we have a new function of our object! We can access single elements by an additional way!\n\nanother_list$title\n\n[1] \"Numbers\"\n\n\nas well as using named indexing in the double square bracket notation.\n\nanother_list[[\"title\"]]\n\n[1] \"Numbers\"\n\n\nLists, it turns out, can become a lot more complicated than vectors. While each entry of a vector is just a single value, each entry of a list can be any type of object, including vectors and data frames. For example, the following list of length three contains three entries: a numeric vector, a data frame, and a single character value:\n\ncomplicated_list <- list(vec = c(1, 2, 9),\n                         dataframe = cats, \n                         single_value = \"a\")\ncomplicated_list\n\n$vec\n[1] 1 2 9\n\n$dataframe\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n$single_value\n[1] \"a\"\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nCreate a list of length two containing a character vector containing the letters “x”, “y”, “z” and a data frame with two columns that looks like this.\n\n\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\nYour list output should look like this:\n\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\nSolution to Challenge 6\n\n\n\n\n\n\nlist(c(\"x\", \"y\", \"z\"),\n     data.frame(name = c(\"Henry\", \"Hannah\", \"Harvey\"), grade = c(\"A\", \"B\", \"C\")))\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\n6.2.1 Data frames as a special case of a list\nIt turns out that a data frame is a special kind of a list. Specifically, a data frame is a list of vectors of the same length.\nThis is why you can extract vector columns from a data frame using the double brackets notation:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\n\ncats[[\"coat\"]]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nNote that the df[i, j] index notation is specific to data frames (and does not work for lists).\nYou will learn more about extracting information from vectors, lists and data frames in the advanced subsetting lesson."
  },
  {
    "objectID": "03-r-intro.html#introduction",
    "href": "03-r-intro.html#introduction",
    "title": "3  Introduction to R",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\nIn this lesson you’ll receive your first taste of the R programming language. Specifically you’ll learn how to use R as a calculator, and the basics of variables, functions, and packages."
  },
  {
    "objectID": "03-r-intro.html#using-r-as-a-calculator",
    "href": "03-r-intro.html#using-r-as-a-calculator",
    "title": "3  Introduction to R",
    "section": "3.2 Using R as a calculator",
    "text": "3.2 Using R as a calculator\nWhen using R as a calculator, the order of operations is the same as you would have learned back in school.\nFrom highest to lowest precedence:\n\nParentheses: (, )\nExponents: ^ or **\nMultiply: *\nDivide: /\nAdd: +\nSubtract: -\n\n\n3 + 5 * 2\n\n[1] 13\n\n\nUse parentheses to group operations in order to force the order of evaluation if it differs from the default, or to make clear what you intend.\n\n(3 + 5) * 2\n\n[1] 16\n\n\nThis can get unwieldy when not needed, but clarifies your intentions. Remember that others may later read your code.\n\n(3 + (5 * (2 ^ 2))) # hard to read\n3 + 5 * 2 ^ 2       # clear, if you remember the rules\n3 + 5 * (2 ^ 2)     # if you forget some rules, this might help\n\nThe text after each line of code is called a “comment”. Anything that follows after the hash (or octothorpe) symbol # is ignored by R when it executes code. (Note the difference between a code comment and a quarto chunk option specified with |#)\nReally small or large numbers get a scientific notation:\n\n2/10000\n\n[1] 2e-04\n\n\nWhich is shorthand for “multiplied by 10^XX”. So 2e-4 is shorthand for 2 * 10^(-4).\nYou can write numbers in scientific notation too:\n\n5e3  # Note the lack of minus here\n\n[1] 5000"
  },
  {
    "objectID": "03-r-intro.html#mathematical-functions",
    "href": "03-r-intro.html#mathematical-functions",
    "title": "3  Introduction to R",
    "section": "3.3 Mathematical functions",
    "text": "3.3 Mathematical functions\nR has many built in mathematical functions. To call a function, we can type its name, followed by open and closing parentheses. Functions take arguments as inputs, anything we type inside the parentheses of a function is considered an argument.\nDepending on the function, the number of arguments can vary from none to multiple. For example:\n\ngetwd() #returns an absolute filepath\n\ndoesn’t require an argument, whereas for the next set of mathematical functions we will need to supply the function a value in order to compute the result.\n\nsin(1)  # trigonometry functions\n\n[1] 0.841471\n\n\n\nlog(1)  # natural logarithm\n\n[1] 0\n\n\n\nlog10(10) # base-10 logarithm\n\n[1] 1\n\n\n\nexp(0.5) # e^(1/2)\n\n[1] 1.648721\n\n\nDon’t worry about trying to remember every function in R. You can look them up on Google, or if you can remember the start of the function’s name, use the tab completion in RStudio.\nThis is one advantage that RStudio has over R on its own, it has auto-completion abilities that allow you to more easily look up functions, their arguments, and the values that they take.\n\n3.3.1 Help files\nTyping a ? before the name of a command will open the help page for that command. When using RStudio, this will open the ‘Help’ pane; if using R in the terminal, the help page will open in your browser. The help page will include a detailed description of the command and how it works. Scrolling to the bottom of the help page will usually show a collection of code examples which illustrate command usage. We’ll go through an example later.\n\n\n\n\n\n\nChallenge 1\n\n\n\nLook at the help page for the log() function by typing ?log in the console. What arguments does log() take? Which arguments have a default value set?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nThe log() function takes arguments\n\nx (the value we want to take the logarithm of) and\nbase (the base of the logarithm calculation).\n\nThere is no default value for x, but the default value for base is exp(1), which means that you don’t need to specify base."
  },
  {
    "objectID": "03-r-intro.html#comparing-things",
    "href": "03-r-intro.html#comparing-things",
    "title": "3  Introduction to R",
    "section": "3.4 Comparing things",
    "text": "3.4 Comparing things\nWe can also do comparisons in R:\n\n1 == 1  # equality (note two equals signs, read as \"is equal to\")\n\n[1] TRUE\n\n\n\n1 != 2  # inequality (read as \"is not equal to\")\n\n[1] TRUE\n\n\n\n1 < 2  # less than\n\n[1] TRUE\n\n\n\n1 <= 1  # less than or equal to\n\n[1] TRUE\n\n\n\n1 > 0  # greater than\n\n[1] TRUE\n\n\n\n1 >= -9 # greater than or equal to\n\n[1] TRUE"
  },
  {
    "objectID": "03-r-intro.html#variables-and-assignment",
    "href": "03-r-intro.html#variables-and-assignment",
    "title": "3  Introduction to R",
    "section": "3.5 Variables and assignment",
    "text": "3.5 Variables and assignment\nWe can store values in variables using the assignment operator <-, like this:\n\nx <- 1/40\n\nNotice that assignment does not print a value. Instead, we stored it for later in something called a variable. x now contains the value 0.025:\n\nx\n\n[1] 0.025\n\n\nLook for the Environment tab in the top right panel of RStudio, and you will see that x and its value have appeared. Our variable x can be used in place of a number in any calculation that expects a number:\n\nlog(x)\n\n[1] -3.688879\n\n\nNotice also that variables can be reassigned:\n\nx <- 100\n\nx used to contain the value 0.025 and now it has the value 100.\nAssignment values can contain the variable being assigned to:\n\nx <- x + 1 #notice how RStudio updates its description of x on the top right tab\ny <- x * 2\n\nThe right hand side of the assignment can be any valid R expression. The right hand side is fully evaluated before the assignment occurs.\nVariable names can contain letters, numbers, underscores and periods but no spaces. They must start with a letter.\nIt is recommended to use a consistent variable naming syntax, such as\n\nunderscores_between_words\n\nNote that it is also possible to use the = operator for assignment:\n\nx = 1/40\n\nBut this is much less common among R users and the general recommendation is to use <-.\n\n\n\n\n\n\nChallenge 2\n\n\n\nWhich of the following are valid R variable names?\n\nmin_height\nmax.height\n_age\n.mass\nMaxLength\nmin-length\n2widths\ncelsius2kelvin\n\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\nThe following variable names are valid:\n\nmin_height\nmax.height\nMaxLength\ncelsius2kelvin\n\nBut only the first one is in the recommended format.\nThe following creates a hidden variable:\n\n.mass"
  },
  {
    "objectID": "03-r-intro.html#vectors",
    "href": "03-r-intro.html#vectors",
    "title": "3  Introduction to R",
    "section": "3.6 Vectors",
    "text": "3.6 Vectors\nNote that a variable can contain many values at once. For example, a vector in R corresponds to a collection of values stored in a certain order and that have the same data type. There are many ways to create vectors. Some examples include:\n\nc(1, 4, 2)\n\n[1] 1 4 2\n\n1:5\n\n[1] 1 2 3 4 5\n\n2^(1:5)\n\n[1]  2  4  8 16 32\n\nx <- 1:5\n2^x\n\n[1]  2  4  8 16 32\n\n\nThis is incredibly powerful; we will discuss this further in an upcoming lesson."
  },
  {
    "objectID": "03-r-intro.html#managing-your-environment",
    "href": "03-r-intro.html#managing-your-environment",
    "title": "3  Introduction to R",
    "section": "3.7 Managing your environment",
    "text": "3.7 Managing your environment\nThere are a few useful commands you can use to interact with the R session.\nls will list all of the variables and functions stored in the global environment (your working R session):\n\nls()\n\n\n\n[1] \"x\" \"y\"\n\n\nNote here that we didn’t give any arguments to ls, but we still needed to give the parentheses to tell R to call the function.\nIf we type ls by itself, R prints a bunch of code instead of a listing of objects.\n\nls\n\nfunction (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, \n    pattern, sorted = TRUE) \n{\n    if (!missing(name)) {\n        pos <- tryCatch(name, error = function(e) e)\n        if (inherits(pos, \"error\")) {\n            name <- substitute(name)\n            if (!is.character(name)) \n                name <- deparse(name)\n            warning(gettextf(\"%s converted to character string\", \n                sQuote(name)), domain = NA)\n            pos <- name\n        }\n    }\n    all.names <- .Internal(ls(envir, all.names, sorted))\n    if (!missing(pattern)) {\n        if ((ll <- length(grep(\"[\", pattern, fixed = TRUE))) && \n            ll != length(grep(\"]\", pattern, fixed = TRUE))) {\n            if (pattern == \"[\") {\n                pattern <- \"\\\\[\"\n                warning(\"replaced regular expression pattern '[' by  '\\\\\\\\['\")\n            }\n            else if (length(grep(\"[^\\\\\\\\]\\\\[<-\", pattern))) {\n                pattern <- sub(\"\\\\[<-\", \"\\\\\\\\\\\\[<-\", pattern)\n                warning(\"replaced '[<-' by '\\\\\\\\[<-' in regular expression pattern\")\n            }\n        }\n        grep(pattern, all.names, value = TRUE)\n    }\n    else all.names\n}\n<bytecode: 0x105a73848>\n<environment: namespace:base>\n\n\nWhat’s going on here?\nLike everything in R, ls is the name of an object, and entering the name of an object by itself prints the contents of the object. The object x that we created earlier contains 1, 2, 3, 4, 5:\n\nx\n\n[1] 1 2 3 4 5\n\n\nThe object ls contains the R code that makes the ls function work! We’ll talk more about how functions work and start writing our own later.\nYou can use rm to delete objects you no longer need:\n\nrm(x)\n\nIf you have lots of things in your environment and want to delete all of them, you can pass the results of ls to the rm function (or you can click the “broom” icon in the environment panel):\n\nrm(list = ls())\n\nIn this case we’ve combined the two. Like the order of operations, anything inside the innermost parentheses is evaluated first, and so on.\nIn this case we’ve specified that the results of ls should be used for the list argument in rm. When assigning values to arguments by name, you must use the = operator!!\nIf instead we use <-, there will be unintended side effects, or you may get an error message:\n\nrm(list <- ls())\n\nError in rm(list <- ls()): ... must contain names or character strings\n\n\n\n\n\n\n\n\nTip: Warnings vs. Errors\n\n\n\nPay attention when R does something unexpected! Errors, like above, are thrown when R cannot proceed with a calculation.\nWarnings on the other hand usually mean that the function has run, but it probably hasn’t worked as expected.\nIn both cases, the message that R prints out usually give you clues how to fix a problem."
  },
  {
    "objectID": "03-r-intro.html#r-packages",
    "href": "03-r-intro.html#r-packages",
    "title": "3  Introduction to R",
    "section": "3.8 R Packages",
    "text": "3.8 R Packages\nIt is possible to add functions to R by writing a package, or by obtaining a package written by someone else. As of this writing, there are over 10,000 packages available on CRAN (the comprehensive R archive network). R and RStudio have functionality for managing packages:\n\nYou can install packages by typing install.packages(\"packagename\"), where packagename is the package name, in quotes.\nYou can update installed packages by typing update.packages()\nYou can make a package available for use with library(packagename)\n\nPackages can also be viewed, loaded, and detached in the Packages tab of the lower right panel in RStudio. Clicking on this tab will display all of the installed packages with a checkbox next to them. If the box next to a package name is checked, the package is loaded and if it is empty, the package is not loaded. Click an empty box to load that package and click a checked box to detach that package.\nPackages can be installed and updated from the Package tab with the Install and Update buttons at the top of the tab.\n\n\n\n\n\n\nChallenge 3\n\n\n\nWhat will be the value of each variable after each line in the following code?\n\nmass <- 47.5\nage <- 122\nmass <- mass * 2.3\nage <- age - 20\n\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\nmass <- 47.5\n\nThis will give a value of 47.5 for the variable mass\n\nage <- 122\n\nThis will give a value of 122 for the variable age\n\nmass <- mass * 2.3\n\nThis will multiply the existing value of 47.5 by 2.3 to give a new value of 109.25 to the variable mass.\n\nage <- age - 20\n\nThis will subtract 20 from the existing value of 122 to give a new value of 102 to the variable age.\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nRun the code from the previous challenge, and write a command to compare mass to age. Is mass larger than age?\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nOne way of answering this question in R is to use the > to set up the following:\n\nmass > age\n\n[1] TRUE\n\n\nThis should yield a boolean value of TRUE since 109.25 is greater than 102.\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nClean up your working environment by deleting the mass and age variables.\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nWe can use the rm command to accomplish this task\n\nrm(age, mass)\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nInstall the following packages: tidyverse, gapminder\n\n\n\n\n\n\nSolution to Challenge 6\n\n\n\n\n\nWe can use the install.packages() command to install the required packages.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"gapminder\")\n\nAn alternate solution, to install multiple packages with a single install.packages() command is:\n\ninstall.packages(c(\"tidyverse\", \"gapminder\"))"
  },
  {
    "objectID": "02-project-intro.html#introduction",
    "href": "02-project-intro.html#introduction",
    "title": "2  Project Management With RStudio",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nThe scientific process is naturally incremental, and many projects start life as random notes, some code, then a manuscript, and eventually everything is a bit mixed together.\n\n\nManaging your projects in a reproducible fashion doesn’t just make your science reproducible, it makes your life easier.\n\n— Vince Buffalo (@vsbuffalo) April 15, 2013\n\n\nMost people tend to organize their projects like this:\n\n\n\nScreenshot of file manager demonstrating bad project organisation\n\n\nThere are many reasons why we should avoid this:\n\nIt is really hard to tell which version of your data is the original and which is the modified;\nIt gets really messy because it mixes files with various extensions together;\nIt probably takes you a lot of time to actually find things, and relate the correct figures to the exact code that has been used to generate it;\n\nA good project layout will ultimately make your life easier:\n\nIt will help ensure the integrity of your data;\nIt makes it simpler to share your code with someone else (a lab-mate, collaborator, or supervisor);\nIt allows you to easily upload your code with your manuscript submission;\nIt makes it easier to pick the project back up after a break."
  },
  {
    "objectID": "02-project-intro.html#a-possible-solution",
    "href": "02-project-intro.html#a-possible-solution",
    "title": "2  Project Management With RStudio",
    "section": "2.2 A possible solution",
    "text": "2.2 A possible solution\nFortunately, there are tools and packages which can help you manage your work effectively.\nOne of the most powerful and useful aspects of RStudio is its project management functionality. We’ll be using this today to create a self-contained, reproducible project.\n\n\n\n\n\n\nChallenge 1: Creating a self-contained project\n\n\n\nCreate a new project in RStudio:\n\nClick the “File” menu button, then “New Project”.\nClick “New Directory”.\nClick “New Project”.\nType in the name of the directory to store your project, e.g. “my_project”.\nClick the “Create Project” button.\n\n\n\nThe simplest way to open an RStudio project once it has been created is to click through your file system to get to the directory where it was saved and double click on the .Rproj file. This will open RStudio and start your R session in the same directory as the .Rproj file. All your data, plots and scripts will now be relative to the project directory. RStudio projects have the added benefit of allowing you to open multiple projects at the same time each open to its own project directory. This allows you to keep multiple projects open without them interfering with each other.\n\n\n\n\n\n\nChallenge 2: Opening an RStudio project through the file system\n\n\n\n\nExit RStudio.\nNavigate to the directory where you created a project in Challenge 1.\nDouble click on the .Rproj file in that directory."
  },
  {
    "objectID": "02-project-intro.html#best-practices-for-project-organization",
    "href": "02-project-intro.html#best-practices-for-project-organization",
    "title": "2  Project Management With RStudio",
    "section": "2.3 Best practices for project organization",
    "text": "2.3 Best practices for project organization\nOne of the more effective ways to work with R is to start by writing the code you want to run directly in the code chunks of a quarto document (or in an .R script), and then running the selected lines (either using the keyboard shortcuts in RStudio or clicking the “Run” button) in the interactive R console.\nHowever, it is important to save all of the code that led to your final results, e.g., in quarto documents and R scripts.\nAlthough there is no “best” way to lay out a project, there are some general principles to adhere to that will make project management easier:\n\n2.3.1 Treat data as read only\nThis is probably the most important goal of setting up a project. Data is typically time consuming and/or expensive to collect. Working with them interactively (e.g., in Excel) where they can be modified means you are never sure of where the data came from, or how it has been modified since collection. It is therefore a good idea to treat your data as “read-only”.\nYou should keep an un-modified (read-only) copy of the raw data in a data/ folder.\n\n\n\n\n\n\nChallenge 3: download the gapminder data\n\n\n\nDownload the gapminder data from here.\n\nDownload the file (right mouse click on the link above -> “Save link as” / “Save file as”, or click on the link and after the page loads, press Ctrl+S or choose File -> “Save page as”)\nMake sure it’s saved under the name gapminder_data.csv\nSave the file in the data/ folder within your project.\n\nWe will load and inspect these data later.\n\n\n\n\n2.3.2 Data Cleaning\nIn many cases your data will be “dirty”: it will need significant preprocessing to get into a format R (or any other programming language) will find useful. This task is sometimes called “data munging” or “data cleaning”. Writing a data cleaning function and and saving this function in a standalone R script can help with reproducibility.\n\n\n2.3.3 Writing functions\nHowever, when you have multiple quarto analysis files, you often want to run the same code (e.g., to load and clean the data) in each quarto file. Rather than repeating your code, it is a good idea to save re-usable code as functions in separate R scripts that can be stored in a functions/ folder.\n\n\n2.3.4 Treat generated output as disposable\nAnything generated by your scripts should be treated as disposable: it should all be able to be regenerated from re-compiling your analysis files.\n\n\n\n\n\n\nTip: Project structure\n\n\n\n\nPut each project in its own directory, which is named after the project.\nPut text documents associated with the project in the doc/ directory.\nPut raw data and metadata in the data/ directory, and files generated during cleanup and analysis in a results/ directory.\nPut any scripts containing re-usable functions in the functions/ directory.\nName all files to reflect their content or function and provide numeric prefixes to indicate any underlying ordering of the files.\n\n\n\n\n\n2.3.5 Working directory\nKnowing R’s current working directory is important because when you need to access other files (for example, to import a data file), R will look for them relative to the current working directory.\nEach time you create a new RStudio Project, it will create a new directory for that project. When you open an existing .Rproj file, it will open that project and set R’s working directory to the folder that file is in.\n\n\n\n\n\n\nChallenge 4: working directory\n\n\n\nYou can check the current working directory with the getwd() command, or by using the menus in RStudio.\n\nIn the console, type getwd() (“wd” is short for “working directory”) and hit Enter.\nIn the Files pane, double click on the data folder to open it (or navigate to any other folder you wish). To get the Files pane back to the current working directory, click “More” and then select “Go To Working Directory”.\n\nYou can change the working directory with setwd(), or by using RStudio menus.\n\nIn the console, type setwd(\"data\") and hit Enter. Type getwd() and hit Enter to see the new working directory.\nIn the menus at the top of the RStudio window, click the “Session” menu button, and then select “Set Working Directory” and then “Choose Directory”.\nIn the windows navigator that opens, navigate back to the project directory, and click “Open”. Note that a setwd command will automatically appear in the console.\n\n\n\n\n\n\n\n\n\nTip: File does not exist errors\n\n\n\nWhen you’re attempting to reference a file in your R code and you’re getting errors saying the file doesn’t exist, it’s a good idea to check your working directory.\nYou need to either provide an absolute path to the file, or you need to make sure the file is saved in the working directory (or a subfolder of the working directory) and provide a relative path."
  },
  {
    "objectID": "04-data-structures-part1.html#factors",
    "href": "04-data-structures-part1.html#factors",
    "title": "4  Data Structures",
    "section": "4.4 Factors",
    "text": "4.4 Factors\nLet’s consider a new data type: the factor.\nFor an object containing the data type factor, each different value represents what is called a level, and is often how categorical variables/columns whose values can have a finite set of options will be formatted.\nCan you identify any categorical variables in the cats data frame? What about the coat variables?\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThe coat variable is currently formatted as a character variable\n\nclass(cats$coat)\n\n[1] \"character\"\n\n\nbut we can convert it to a factor using the as.factor() function:\n\ncats$coat <- as.factor(cats$coat)\nclass(cats$coat)\n\n[1] \"factor\"\n\n\nLet’s take a look at the factor-formatted coat column:\n\ncats$coat\n\n[1] calico black  tabby \nLevels: black calico tabby\n\n\nIt looks very similar to the character format, but now our output tells us that there are four “levels”: “black”, “calico”, “tabby”, and “tortoiseshell”.\nOne common pitfall occurs when converting numerically coded factors to numeric type.\nIf we convert a coat to a numeric type, it replaces each level with a number in the order that the levels are defined (the default is alphabetical order):\n\nas.numeric(cats$coat)\n\n[1] 2 1 3\n\n\nBut if the factor levels are themselves numbers,\n\nfactor_weight <- as.factor(cats$weight)\nfactor_weight\n\n[1] 2.1 5   3.2\nLevels: 2.1 3.2 5\n\n\nand we convert this numeric factor to a numeric type, the numeric information will be lost:\n\nas.numeric(factor_weight)\n\n[1] 1 3 2\n\n\nFortunately, factor and character types behave fairly similarly across most applications, so it usually won’t matter which format your categorical variables are encoded as, but it is important to be aware of factors as you will undoubtedly encounter them in your R journey."
  },
  {
    "objectID": "05-data-structures-part2.html#removing-rows-by-index",
    "href": "05-data-structures-part2.html#removing-rows-by-index",
    "title": "5  Adding/removing data from data frames",
    "section": "5.2 Removing rows by index",
    "text": "5.2 Removing rows by index\n\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4 tortoiseshell    3.3            1   9\n\n\nWe now know how to add rows and columns to our data frame in R, but how do we remove rows. For instance, if we wanted to now remove the “tortoiseshell” row, we can ask for a data frame minus this offending row using the - syntax:\n\ncats[-4, ]\n\n    coat weight likes_string age\n1 calico    2.1            1   2\n2  black    5.0            0   3\n3  tabby    3.2            1   5\n\n\nNotice the comma with nothing after it to indicate that we want to drop the entire fourth row.\nNote: we could also remove both new rows at once by putting the row numbers inside of a vector using c(): cats[c(-4,-5), ]"
  },
  {
    "objectID": "06-data-subsetting.html#combining-logical-conditions",
    "href": "06-data-subsetting.html#combining-logical-conditions",
    "title": "6  Advanced subsetting",
    "section": "6.5 Combining logical conditions",
    "text": "6.5 Combining logical conditions\nWe often want to combine multiple logical criteria. For example, we might want to find all the countries that are located in Asia or Europe and have life expectancies within a certain range. Several operations for combining logical vectors exist in R:\n\n&, the “logical AND” operator: returns TRUE if both the left and right are TRUE.\n|, the “logical OR” operator: returns TRUE, if either the left or right (or both) are TRUE.\n\nYou may sometimes see && and || instead of & and |. These two-character operators only look at the first element of each vector and ignore the remaining elements. In general you should not use the two-character operators in data analysis.\n\n!, the “logical NOT” operator: converts TRUE to FALSE and FALSE to TRUE. It can negate a single logical condition (eg !TRUE becomes FALSE), or a whole vector of conditions(eg !c(TRUE, FALSE) becomes c(FALSE, TRUE)).\n\nAdditionally, you can compare the elements within a single vector using the all function (which returns TRUE if every element of the vector is TRUE) and the any function (which returns TRUE if one or more elements of the vector are TRUE).\nFor example, the following code will only return the values of x that are equal to either 5.4 or 7 (since there is no value equal to 7, only the value equal to 5.4 will be returned):\n\n(x == 5.4) | (x == 7)\n\n    a     b     c     d     e \n TRUE FALSE FALSE FALSE FALSE \n\nx[(x == 5.4) | (x == 7)]\n\n  a \n5.4"
  },
  {
    "objectID": "06-data-subsetting.html#challenge-2",
    "href": "06-data-subsetting.html#challenge-2",
    "title": "6  Advanced subsetting",
    "section": "6.6 Challenge 2",
    "text": "6.6 Challenge 2\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nprint(x)\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nWrite a subsetting command to return the values in x that are greater than 4 and less than 7.\n\n\n\n\n\n\nSolution to challenge 2\n\n\n\n\n\n\nx[x < 7 & x > 4]\n\n  a   b   d \n5.4 6.2 4.8 \n\n\n\n\n\n:::\n\n\n\n\n\n\nTip: Non-unique names\n\n\n\nYou should be aware that it is possible for multiple elements in a vector to have the same name. (For a data frame, columns can have the same name — although R tries to avoid this — but row names must be unique.) Consider these examples:\n\nx <- 1:3\nx\n\n[1] 1 2 3\n\nnames(x) <- c('a', 'a', 'a')\nx\n\na a a \n1 2 3 \n\nx['a']  # only returns first value\n\na \n1 \n\nx[names(x) == 'a']  # returns all three values\n\na a a \n1 2 3 \n\n\n\n\n\n\n\n\n\n\nTip: Getting help for operators\n\n\n\nRemember you can search for help on operators by wrapping them in quotes: help(\"%in%\") or ?\"%in%\"."
  },
  {
    "objectID": "06-data-subsetting.html#the-in-operator-in",
    "href": "06-data-subsetting.html#the-in-operator-in",
    "title": "6  Advanced subsetting",
    "section": "6.6 The in operator %in%",
    "text": "6.6 The in operator %in%\nAnother way to do this is to ask R to subset the values of x that are “in” a vector of values.\n\nx %in% c(5.4, 7)\n\n[1]  TRUE FALSE FALSE FALSE FALSE\n\nx[x %in% c(5.4, 7)]\n\n  a \n5.4 \n\n\n\n\n\n\n\n\nTip: Getting help for operators\n\n\n\nRemember you can search for help on operators by wrapping them in quotes: help(\"%in%\") or ?\"%in%\".\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nprint(x)\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nWrite a subsetting command to return the values in x that are greater than 4 and less than 7.\n\n\n\n\n\n\nSolution to challenge 2\n\n\n\n\n\n\nx[x < 7 & x > 4]\n\n  a   b   d \n5.4 6.2 4.8 \n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Non-unique names\n\n\n\nIt is possible for multiple elements in a vector to have the same name. (For a data frame, columns can have the same name too.) Consider these examples:\n\nx <- 1:3\nx\n\n[1] 1 2 3\n\nnames(x) <- c('a', 'a', 'a')\nx\n\na a a \n1 2 3 \n\nx['a']  # only returns first value\n\na \n1 \n\nx[names(x) == 'a']  # returns all three values\n\na a a \n1 2 3"
  },
  {
    "objectID": "05-data-frames.html#adding-columns-and-rows-in-data-frames",
    "href": "05-data-frames.html#adding-columns-and-rows-in-data-frames",
    "title": "5  Adding/removing data from data frames",
    "section": "5.1 Adding columns and rows in data frames",
    "text": "5.1 Adding columns and rows in data frames\nWe already learned that the columns of a data frame are vectors, so that our data are consistent in type throughout the columns. As such, if we want to add a new column, we can start by making a new vector:\n\n\n\n\nage <- c(2, 3, 5)\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\nWe can then add this as a column using:\n\ncats$age <- age\ncats\n\n    coat weight likes_string age\n1 calico    2.1            1   2\n2  black    5.0            0   3\n3  tabby    3.2            1   5\n\n\nWe can alternatively use the cbind() function:\n\n# reset the cats data frame\ncats <- read.csv(\"data/feline-data.csv\")\ncbind(cats, age)\n\n    coat weight likes_string age\n1 calico    2.1            1   2\n2  black    5.0            0   3\n3  tabby    3.2            1   5\n\n\nNote that if we tried to add a vector of ages with a different number of entries than the number of rows in the data frame, it would fail:\n\nage <- c(2, 3, 5, 12)\ncbind(cats, age)\n\nError in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 3, 4\n\nage <- c(2, 3)\ncbind(cats, age)\n\nError in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 3, 2\n\n\nWhy didn’t this work? Of course, R wants to see one element in our new column for every row in the table:\n\nnrow(cats)\n\n[1] 3\n\nlength(age)\n\n[1] 2\n\n\nSo for it to work we need to have nrow(cats) == length(age). Let’s overwrite the content of cats with our new data frame.\n\nage <- c(2, 3, 5)\ncats <- cbind(cats, age)\n\n\n\n\n\n\n\nTip: mutate\n\n\n\nIn the dplyr lesson, you will learn another method of adding a column to a data frame using the mutate() function from the dplyr package in the tidyverse suite.\n\n\nNow how about adding rows? Since each row is itself a data frame, to add a new row, we need to create a data frame containing the new information.\n\nnewRow <- data.frame(coat = \"tortoiseshell\", weight = 3.3, likes_string = TRUE, age = 9)\ncats <- rbind(cats, newRow)\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4 tortoiseshell    3.3            1   9\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nLet’s imagine that 1 cat year is equivalent to 7 human years.\n\nCreate a vector called human_age by multiplying cats$age by 7.\nConvert human_age to a factor.\nConvert human_age back to a numeric vector using the as.numeric() function. Now divide it by 7 to get the original ages back. Explain what happened.\n\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\nhuman_age <- cats$age * 7\nhuman_age <- factor(human_age). as.factor(human_age) works just as well.\nas.numeric(human_age) yields 1 2 3 4 4 because factors are stored as integers (here, 1:4), each of which is associated with a label (here, 28, 35, 56, and 63). Converting the factor to a numeric vector gives us the underlying integers, not the labels. If we want the original numbers, we need to convert human_age to a character vector (using as.character(human_age)) and then to a numeric vector (why does this work?). This comes up in real life when we accidentally include a character somewhere in a column of a .csv file supposed to only contain numbers, and set stringsAsFactors=TRUE when we read in the data."
  },
  {
    "objectID": "05-data-frames.html#removing-rows-by-index",
    "href": "05-data-frames.html#removing-rows-by-index",
    "title": "5  Adding/removing data from data frames",
    "section": "5.2 Removing rows by index",
    "text": "5.2 Removing rows by index\n\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4 tortoiseshell    3.3            1   9\n\n\nWe now know how to add rows and columns to our data frame in R, but how do we remove rows. For instance, if we wanted to now remove the “tortoiseshell” row, we can ask for a data frame minus this offending row using the - syntax:\n\ncats[-4, ]\n\n    coat weight likes_string age\n1 calico    2.1            1   2\n2  black    5.0            0   3\n3  tabby    3.2            1   5\n\n\nNotice the comma with nothing after it to indicate that we want to drop the entire fourth row.\nNote: we could also remove both new rows at once by putting the row numbers inside of a vector using c(): cats[c(-4,-5), ]"
  },
  {
    "objectID": "05-data-frames.html#removing-columns",
    "href": "05-data-frames.html#removing-columns",
    "title": "5  Adding/removing data from data frames",
    "section": "5.3 Removing columns",
    "text": "5.3 Removing columns\nWe can also remove columns in our data frame. What if we want to remove the column “age”. We can remove it by index:\n\ncats[, -4]\n\n           coat weight likes_string\n1        calico    2.1            1\n2         black    5.0            0\n3         tabby    3.2            1\n4 tortoiseshell    3.3            1\n\n\nNotice the comma with nothing before it, indicating we want to keep all of the rows.\nHowever, using the column name syntax doesn’t work here:\n\ncats[, -\"age\"]\n\nError in -\"age\": invalid argument to unary operator\n\n\nTo drop a column using the column name, we can instead use the %in% operator. The %in% operator goes through each element of its left argument, in this case the names of cats, and asks, “Does this element occur in the second argument?”\n\ndrop <- names(cats) %in% c(\"age\")\ncats[, !drop]\n\n           coat weight likes_string\n1        calico    2.1            1\n2         black    5.0            0\n3         tabby    3.2            1\n4 tortoiseshell    3.3            1\n\n\nWe will cover subsetting with logical operators like %in% in more detail in the next lesson."
  },
  {
    "objectID": "05-data-frames.html#appending-to-a-data-frame",
    "href": "05-data-frames.html#appending-to-a-data-frame",
    "title": "5  Adding/removing data from data frames",
    "section": "5.4 Appending to a data frame",
    "text": "5.4 Appending to a data frame\nThe key to remember when adding data to a data frame is that columns are vectors and rows are data frames. We can also glue two data frames together with rbind:\n\ncats <- rbind(cats, cats)\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4 tortoiseshell    3.3            1   9\n5        calico    2.1            1   2\n6         black    5.0            0   3\n7         tabby    3.2            1   5\n8 tortoiseshell    3.3            1   9\n\n\nYou can create a new data frame right from within R with the following syntax:\n\ndf <- data.frame(id = c(\"a\", \"b\", \"c\"),\n                x = 1:3,\n                y = c(TRUE, TRUE, FALSE))\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nMake a data frame that holds the following information for yourself:\n\nYour first name\nYour last name\nThe year you were born\n\nThen use rbind to add an entry for the people sitting beside you. Finally, use cbind to add a column with each person’s answer to the question, “Do you like piezza?”\nYour final data frame should look something like this:\n\n\n  first   last year pizza\n1 Grace Hopper 1906  TRUE\n2 Marie  Curie 1867 FALSE\n\n\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\ndf <- data.frame(first = c(\"Grace\"),\n                last = c(\"Hopper\"),\n                year = 1906)\ndf <- rbind(df, data.frame(first = \"Marie\", last = \"Curie\", year = 1867) )\ndf <- cbind(df, pizza = c(TRUE, FALSE))\ndf\n\n  first   last year pizza\n1 Grace Hopper 1906  TRUE\n2 Marie  Curie 1867 FALSE"
  },
  {
    "objectID": "05-data-frames.html#data-example",
    "href": "05-data-frames.html#data-example",
    "title": "5  Adding/removing data from data frames",
    "section": "5.5 Data example",
    "text": "5.5 Data example\nSo far, you have seen the basics of manipulating data frames with our cat data; now let’s use those skills to digest a more realistic dataset. Let’s read in the gapminder dataset that we downloaded previously:\n\ngapminder <- read.csv(\"data/gapminder_data.csv\")\n\n\n\n\n\n\n\nTip: Loading files from the internet\n\n\n\nYou can also read in files directly into R from the Internet by replacing the file paths with a web address in read.csv. Note that in doing this no local copy of the csv file is first saved onto your computer. For example,\n\ngapminder <- read.csv(\"<INSERT URL HERE>\")\n\n\n\n\n\n\n\n\n\nTip: Loading excel files\n\n\n\nYou can read directly from excel spreadsheets using the readxl package.\n\n\nLet’s investigate gapminder a bit; the first thing we should always do is check out what the data looks like with head() and str():\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\nAn additional method for examining the structure of gapminder is to use the summary() function. summary yields a numeric, tabular, or descriptive summary of each column. Factor columns are summarized by the number of items in each level, numeric or integer columns by the descriptive statistics (quartiles and mean), and character columns by its length, class, and mode.\n\nsummary(gapminder)\n\n   country               year           pop             continent        \n Length:1704        Min.   :1952   Min.   :6.001e+04   Length:1704       \n Class :character   1st Qu.:1966   1st Qu.:2.794e+06   Class :character  \n Mode  :character   Median :1980   Median :7.024e+06   Mode  :character  \n                    Mean   :1980   Mean   :2.960e+07                     \n                    3rd Qu.:1993   3rd Qu.:1.959e+07                     \n                    Max.   :2007   Max.   :1.319e+09                     \n    lifeExp        gdpPercap       \n Min.   :23.60   Min.   :   241.2  \n 1st Qu.:48.20   1st Qu.:  1202.1  \n Median :60.71   Median :  3531.8  \n Mean   :59.47   Mean   :  7215.3  \n 3rd Qu.:70.85   3rd Qu.:  9325.5  \n Max.   :82.60   Max.   :113523.1  \n\n\nWe can also interrogate the data frame for information about its dimensions; remembering that str(gapminder) said there were 1704 observations of 6 variables in gapminder, what do you think the following will produce, and why?\n\nlength(gapminder)\n\n[1] 6\n\n\nA fair guess would have been to say that the length of a data frame would be the number of rows it has (1704), but this is not the case; remember, a data frame is a list of vectors. When length gave us 6, it’s because gapminder is built out of a list of 6 vectors. To get the number of rows and columns in our dataset, try:\n\nnrow(gapminder)\n\n[1] 1704\n\nncol(gapminder)\n\n[1] 6\n\n\nOr, both at once:\n\ndim(gapminder)\n\n[1] 1704    6\n\n\nWe’ll also likely want to know what the titles of all the columns are, so we can ask for them later:\n\ncolnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nAt this stage, it’s important to ask ourselves if the structure R is reporting matches our intuition or expectations; do the basic data types reported for each column make sense? If not, we need to sort any problems out now before they turn into bad surprises down the road, using what we’ve learned about how R interprets data, and the importance of strict consistency in how we record our data.\n\n\n\n\n\n\nChallenge 3\n\n\n\nIt’s good practice to also check the last few lines of your data and some in the middle. How would you do this? Searching for ones specifically in the middle isn’t too hard, but we could ask for a few lines at random. How would you code this?\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nTo check the last few lines it’s relatively simple as R already has a function for this:\n\ntail(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\ntail(gapminder, n = 15)\n\n      country year      pop continent lifeExp gdpPercap\n1690   Zambia 1997  9417789    Africa  40.238 1071.3538\n1691   Zambia 2002 10595811    Africa  39.193 1071.6139\n1692   Zambia 2007 11746035    Africa  42.384 1271.2116\n1693 Zimbabwe 1952  3080907    Africa  48.451  406.8841\n1694 Zimbabwe 1957  3646340    Africa  50.469  518.7643\n1695 Zimbabwe 1962  4277736    Africa  52.358  527.2722\n1696 Zimbabwe 1967  4995432    Africa  53.995  569.7951\n1697 Zimbabwe 1972  5861135    Africa  55.635  799.3622\n1698 Zimbabwe 1977  6642107    Africa  57.674  685.5877\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\n\nWhat about a few arbitrary rows just in case something is odd in the middle?\n\n5.6 Tip: There are several ways to achieve this.\nThe solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!\nRemember my_dataframe[rows, cols] will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don’t know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.\n\ngapminder[sample(nrow(gapminder), 5), ]\n\n           country year       pop continent lifeExp  gdpPercap\n1321       Senegal 1952   2755589    Africa  37.278  1450.3570\n123          Benin 1962   2151895    Africa  42.618   949.4991\n1508        Taiwan 1987  19757799      Asia  73.400 11054.5618\n1612 United States 1967 198712000  Americas  70.760 19530.3656\n121          Benin 1952   1738315    Africa  38.223  1062.7522\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nIt’s good practice to also check the last few lines of your data too. How would you do this?\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nTo check the last few lines it’s relatively simple as R already has a function for this:\n\ntail(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\ntail(gapminder, n = 15)\n\n      country year      pop continent lifeExp gdpPercap\n1690   Zambia 1997  9417789    Africa  40.238 1071.3538\n1691   Zambia 2002 10595811    Africa  39.193 1071.6139\n1692   Zambia 2007 11746035    Africa  42.384 1271.2116\n1693 Zimbabwe 1952  3080907    Africa  48.451  406.8841\n1694 Zimbabwe 1957  3646340    Africa  50.469  518.7643\n1695 Zimbabwe 1962  4277736    Africa  52.358  527.2722\n1696 Zimbabwe 1967  4995432    Africa  53.995  569.7951\n1697 Zimbabwe 1972  5861135    Africa  55.635  799.3622\n1698 Zimbabwe 1977  6642107    Africa  57.674  685.5877\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nGo to file -> new file -> R script, and write an R script called load.R which contains R code that loads the gapminder dataset. Save load.R in the functions/ directory.\nRun the script in a chunk in your quarto document using the source() function, using the file path as its argument:\n\nsource(\"functions/load.R\")"
  },
  {
    "objectID": "05-data-frames.html#tip-there-are-several-ways-to-achieve-this.",
    "href": "05-data-frames.html#tip-there-are-several-ways-to-achieve-this.",
    "title": "5  Adding/removing data from data frames",
    "section": "5.6 Tip: There are several ways to achieve this.",
    "text": "5.6 Tip: There are several ways to achieve this.\nThe solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!\nRemember my_dataframe[rows, cols] will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don’t know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.\n\ngapminder[sample(nrow(gapminder), 5), ]\n\n           country year       pop continent lifeExp  gdpPercap\n1321       Senegal 1952   2755589    Africa  37.278  1450.3570\n123          Benin 1962   2151895    Africa  42.618   949.4991\n1508        Taiwan 1987  19757799      Asia  73.400 11054.5618\n1612 United States 1967 198712000  Americas  70.760 19530.3656\n121          Benin 1952   1738315    Africa  38.223  1062.7522"
  },
  {
    "objectID": "04-vectors_types.html",
    "href": "04-vectors_types.html",
    "title": "4  Vectors and types",
    "section": "",
    "text": "5 Names\nWith names, we can give meaning to elements. It is the first time that we do not only have the data, but also explaining information. It is metadata that can be stuck to the object like a label. In R, this is called an attribute. Some attributes enable us to do more with our object, for example, like here, accessing an element by a self-defined name."
  },
  {
    "objectID": "04-vectors_types.html#data-types",
    "href": "04-vectors_types.html#data-types",
    "title": "4  Vectors and types",
    "section": "4.1 Data Types",
    "text": "4.1 Data Types\nIf you guessed that the last command will return an error because 2.1 plus \"black\" is nonsense, you’re right - and you already have some intuition for an important concept in programming called data types. We can ask what type or “class” or “type” of data something is:\n\nclass(cats$weight)\n\n[1] \"numeric\"\n\n\nYou will typically encounter the following main types: numeric (which encompasses double and integer), logical, character (and factor, but we won’t encounter these until later). There are others too (such as complex), but you’re unlikely to encounter them in your data analysis journeys.\nLet’s identify the class of several values:\n\nclass(3.14)\n\n[1] \"numeric\"\n\nclass(TRUE)\n\n[1] \"logical\"\n\nclass(\"banana\")\n\n[1] \"character\"\n\n\nNo matter how complicated our analyses become, all data in R is interpreted as one of these basic data types. This strictness has some really important consequences.\nA user has added details of another cat. This information is in the file data/feline-data_v2.csv.\n\nfile.show(\"data/feline-data_v2.csv\")\n\n\ncoat,weight,likes_string\ncalico,2.1,1\nblack,5.0,0\ntabby,3.2,1\ntabby,2.3 or 2.4,1\n\nLoad the new cats data like before, and check what type of data we find in the weight column:\n\ncats_v2 <- read.csv(file=\"data/feline-data_v2.csv\")\nclass(cats_v2$weight)\n\n[1] \"character\"\n\n\nOh no, our weights aren’t the numeric class anymore! If we try to do the same math we did on them before, we run into trouble:\n\ncats_v2$weight + 2\n\nError in cats_v2$weight + 2: non-numeric argument to binary operator\n\n\nWhat happened?\nThe cats data we are working with is something called a data frame. Data frames are one of the most common and versatile types of data structures we will work with in R.\nA given column in a data frame can only contain one single data type (but each column can be of a different type).\nIn this case, R does not read everything in the data frame column weight as numeric (specifically, R reads the entry 2.3 or 2.4 as a character), therefore the entire column data type changes to something that is suitable for everything in the column.\nWhen R reads a csv file, it reads it in as a data frame. Thus, when we loaded the cats csv file, it is stored as a data frame. We can recognize data frames by the first row that is written by the str() function:\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\"\n $ weight      : num  2.1 5 3.2\n $ likes_string: int  1 0 1\n\n\nData frames are composed of rows and columns, where each column is a vector of the same length. Different columns in a data frame can be made up of different data types (this is what makes them so versatile), but everything in a given column needs to be the same type (e.g., numeric, character, logical, etc).\nLet’s explore more about different data structures and how they behave. For now, let’s go back to working with the original feline-data.csv file while we investigate this behavior further:\nfeline-data.csv:\ncoat,weight,likes_string\ncalico,2.1,1\nblack,5.0,0\ntabby,3.2,1\n\ncats <- read.csv(file = \"data/feline-data.csv\")\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1"
  },
  {
    "objectID": "04-vectors_types.html#vectors-and-type-coercion",
    "href": "04-vectors_types.html#vectors-and-type-coercion",
    "title": "4  Vectors and types",
    "section": "4.2 Vectors and Type Coercion",
    "text": "4.2 Vectors and Type Coercion\nTo better understand this behavior, let’s learn more about the vector. A vector in R is essentially an ordered collection of values, with the special condition that everything in the vector must be the same basic data type.\nA vector can be created with the c() “combine” function:\n\nc(1, 8, 1.2)\n\n[1] 1.0 8.0 1.2\n\n\nThe columns of a data frame are also vectors:\n\ncats$weight\n\n[1] 2.1 5.0 3.2\n\n\nThe fact that everything in a vector must be the same type is the root of why R forces everything in a column to be the same basic data type.\n\n4.2.1 Coercion by combining vectors\nBecause all entries in a vector must have the same type, c() will coerce the type of each element to a common type. Given what we’ve learned so far, what do you think the following will produce?\n\nquiz_vector <- c(2, 6, '3')\n\nThis is something called type coercion, and it is the source of many surprises and the reason why we need to be aware of the basic data types and how R will interpret them. When R encounters a mix of types (here numeric and character) to be combined into a single vector, it will force them all to be the same type. Consider:\n\ncoercion_vector <- c('a', TRUE)\ncoercion_vector\n\n[1] \"a\"    \"TRUE\"\n\nanother_coercion_vector <- c(0, TRUE)\nanother_coercion_vector\n\n[1] 0 1\n\n\n\n\n4.2.2 The type hierarchy\nThe coercion rules go: logical -> numeric -> character, where -> can be read as “are transformed into”. For example, combining logical and character transforms the result to character:\n\nc('a', TRUE)\n\n[1] \"a\"    \"TRUE\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nA quick way to recognize character vectors is by the quotes that enclose them when they are printed.\n\n\nYou can try to force coercion against this flow using the as. functions:\n\ncharacter_vector_example <- c('0', '2', '4')\ncharacter_vector_example\n\n[1] \"0\" \"2\" \"4\"\n\ncharacter_coerced_to_numeric <- as.numeric(character_vector_example)\ncharacter_coerced_to_numeric\n\n[1] 0 2 4\n\nnumeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)\nnumeric_coerced_to_logical\n\n[1] FALSE  TRUE  TRUE\n\n\nAs you can see, some surprising things can happen when R forces one basic data type into another! Nitty-gritty of type coercion aside, the point is: if your data doesn’t look like what you thought it was going to look like, type coercion may well be to blame; make sure everything is the same type in your vectors and your columns of data.frames, or you will get nasty surprises!\nBut coercion can also be very useful! For example, in our cats data likes_string is numeric, but we know that the 1s and 0s actually represent TRUE and FALSE (a common way of representing them). We should use the logical datatype here, which has two states: TRUE or FALSE, which is exactly what our data represents. We can ‘coerce’ this column to be logical by using the as.logical function:\n\ncats$likes_string\n\n[1] 1 0 1\n\ncats$likes_string <- as.logical(cats$likes_string)\ncats$likes_string\n\n[1]  TRUE FALSE  TRUE\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nAn important part of every data analysis is cleaning the input data. If you know that the input data is all of the same format, (e.g. numbers), your analysis is much easier! In this exercise, you will clean the cat data set from the chapter about type coercion.\n\n4.2.3 Copy the code template\nIn your quarto file in RStudio, start a new code chunk and copy and paste the following code. Then move on to the tasks below, which will help you to fill in the gaps (______).\n\n# Read data\ncats <- read.csv(\"data/feline-data_v2.csv\")\n# 1. Print the data\n_____\n\n# 2. Show an overview of the table that prints out the type of each column\n_____(cats)\n\n# 3. The \"weight\" column has the incorrect data type __________.\n#    The correct data type is: ____________.\n\n# 4. Correct the 4th weight data point with the mean of the two given values\ncats$weight[4] <- 2.35\n#    print the data again to see the effect\ncats\n\n# 5. Convert the weight to the right data type\ncats$weight <- ______________(cats$weight)\n\n#    Calculate the mean to test yourself\nmean(cats$weight)\n\n# If you see the correct mean value (and not NA), you did the exercise\n# correctly!\n\n\n\n4.3 Instructions for the tasks\n\n4.3.1 1. Print the data\nExecute the first statement (read.csv(...)). Then print the data to the console\n\n\n\n\n\n\nTip 1.1\n\n\n\nPrint the contents of any variable by typing its name.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.1\n\n\n\n\n\nTwo correct solutions:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\nprint(cats)\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\n\n\n\n\n\n\n4.3.2 2. Overview of the data types\nUse a function we saw earlier to print out the “type” of all columns of the cats table.\n\n\n\n\n\n\nTip 1.2\n\n\n\nIn the chapter “Data types” we saw two functions that can show data types. One printed just a single word, the data type name. The other printed a short form of the data type, and the first few values. We recommend the second here.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.2\n\n\n\n\n\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\"\n $ weight      : num  2.1 5 3.2\n $ likes_string: logi  TRUE FALSE TRUE\n\n\n\n\n\n\n\n4.3.3 3. Which data type do we need?\nThe shown data type is not the right one for this data (weight of a cat). Which data type do we need?\n\nWhy did the read.csv() function not choose the correct data type?\nFill in the gap in the comment with the correct data type for cat weight!\n\n\n\n\n\n\n\nTip 1.3\n\n\n\nScroll up to the section about the type hierarchy to review the available data types\n\n\n\n\n\n\n\n\nSolution to Challenge 1.3\n\n\n\n\nWeight is expressed on a continuous scale (real numbers). The R data type for this is “numeric”.\nThe fourth row has the value “2.3 or 2.4”. That is not a number but two, and an english word. Therefore, the “character” data type is chosen. The whole column is now text, because all values in the same columns have to be the same data type.\n\n\n\n\n\n4.3.4 4. Correct the problematic value\nThe code to assign a new weight value to the problematic fourth row is given. Think first and then execute it: What will be the data type after assigning a number like in this example? You can check the data type after executing to see if you were right.\n\n\n\n\n\n\nTip 1.4\n\n\n\nRevisit the hierarchy of data types when two different data types are combined.\n\n\n\n\n\n\n\n\nSolution to challenge 1.4\n\n\n\n\n\nThe data type of the column “weight” is “character”. The assigned data type is “numeric”. Combining two data types yields the data type that is higher in the following hierarchy:\n\nlogical < numeric < character\n\nTherefore, the column is still of type character! We need to manually convert it to “numeric”.\n\n\n\n\n\n4.3.5 5. Convert the column “weight” to the correct data type\nCat weight are numbers. But the column does not have this data type yet. Coerce the column to floating point numbers.\n\n\n\n\n\n\nTip 1.5\n\n\n\nThe functions to convert data types start with as.. You can look for the function further up in the manuscript or use the RStudio auto-complete function: Type “as.” and then press the TAB key.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.5\n\n\n\n\n\n\ncats$weight <- as.numeric(cats$weight)"
  },
  {
    "objectID": "04-vectors_types.html#instructions-for-the-tasks",
    "href": "04-vectors_types.html#instructions-for-the-tasks",
    "title": "4  Vectors and types",
    "section": "4.3 Instructions for the tasks",
    "text": "4.3 Instructions for the tasks\n\n4.3.1 1. Print the data\nExecute the first statement (read.csv(...)). Then print the data to the console\n\n\n\n\n\n\nTip 1.1\n\n\n\nPrint the contents of any variable by typing its name.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.1\n\n\n\n\n\nTwo correct solutions:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\nprint(cats)\n\n    coat weight likes_string\n1 calico    2.1         TRUE\n2  black    5.0        FALSE\n3  tabby    3.2         TRUE\n\n\n\n\n\n\n\n4.3.2 2. Overview of the data types\nUse a function we saw earlier to print out the “type” of all columns of the cats table.\n\n\n\n\n\n\nTip 1.2\n\n\n\nIn the chapter “Data types” we saw two functions that can show data types. One printed just a single word, the data type name. The other printed a short form of the data type, and the first few values. We recommend the second here.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.2\n\n\n\n\n\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\"\n $ weight      : num  2.1 5 3.2\n $ likes_string: logi  TRUE FALSE TRUE\n\n\n\n\n\n\n\n4.3.3 3. Which data type do we need?\nThe shown data type is not the right one for this data (weight of a cat). Which data type do we need?\n\nWhy did the read.csv() function not choose the correct data type?\nFill in the gap in the comment with the correct data type for cat weight!\n\n\n\n\n\n\n\nTip 1.3\n\n\n\nScroll up to the section about the type hierarchy to review the available data types\n\n\n\n\n\n\n\n\nSolution to Challenge 1.3\n\n\n\n\nWeight is expressed on a continuous scale (real numbers). The R data type for this is “numeric”.\nThe fourth row has the value “2.3 or 2.4”. That is not a number but two, and an english word. Therefore, the “character” data type is chosen. The whole column is now text, because all values in the same columns have to be the same data type.\n\n\n\n\n\n4.3.4 4. Correct the problematic value\nThe code to assign a new weight value to the problematic fourth row is given. Think first and then execute it: What will be the data type after assigning a number like in this example? You can check the data type after executing to see if you were right.\n\n\n\n\n\n\nTip 1.4\n\n\n\nRevisit the hierarchy of data types when two different data types are combined.\n\n\n\n\n\n\n\n\nSolution to challenge 1.4\n\n\n\n\n\nThe data type of the column “weight” is “character”. The assigned data type is “numeric”. Combining two data types yields the data type that is higher in the following hierarchy:\n\nlogical < numeric < character\n\nTherefore, the column is still of type character! We need to manually convert it to “numeric”.\n\n\n\n\n\n4.3.5 5. Convert the column “weight” to the correct data type\nCat weight are numbers. But the column does not have this data type yet. Coerce the column to floating point numbers.\n\n\n\n\n\n\nTip 1.5\n\n\n\nThe functions to convert data types start with as.. You can look for the function further up in the manuscript or use the RStudio auto-complete function: Type “as.” and then press the TAB key.\n\n\n\n\n\n\n\n\nSolution to Challenge 1.5\n\n\n\n\n\n\ncats$weight <- as.numeric(cats$weight)"
  },
  {
    "objectID": "04-vectors_types.html#factors",
    "href": "04-vectors_types.html#factors",
    "title": "4  Vectors and types",
    "section": "4.5 Factors",
    "text": "4.5 Factors\nLet’s consider a new data type: the factor.\nFor an object containing the data type factor, each different value represents what is called a level, and is often how categorical variables/columns whose values can have a finite set of options will be formatted.\nCan you identify any categorical variables in the cats data frame? What about the coat variables?\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThe coat variable is currently formatted as a character variable\n\nclass(cats$coat)\n\n[1] \"character\"\n\n\nbut we can convert it to a factor using the as.factor() function:\n\ncats$coat <- as.factor(cats$coat)\nclass(cats$coat)\n\n[1] \"factor\"\n\n\nLet’s take a look at the factor-formatted coat column:\n\ncats$coat\n\n[1] calico black  tabby \nLevels: black calico tabby\n\n\nIt looks very similar to the character format, but now our output tells us that there are four “levels”: “black”, “calico”, “tabby”, and “tortoiseshell”.\nOne common pitfall occurs when converting numerically coded factors to numeric type.\nIf we convert a coat to a numeric type, it replaces each level with a number in the order that the levels are defined (the default is alphabetical order):\n\nas.numeric(cats$coat)\n\n[1] 2 1 3\n\n\nBut if the factor levels are themselves numbers,\n\nfactor_weight <- as.factor(cats$weight)\nfactor_weight\n\n[1] 2.1 5   3.2\nLevels: 2.1 3.2 5\n\n\nand we convert this numeric factor to a numeric type, the numeric information will be lost:\n\nas.numeric(factor_weight)\n\n[1] 1 3 2\n\n\nFortunately, factor and character types behave fairly similarly across most applications, so it usually won’t matter which format your categorical variables are encoded as, but it is important to be aware of factors as you will undoubtedly encounter them in your R journey."
  },
  {
    "objectID": "04-vectors_types.html#some-basic-functions-for-creating-vectors",
    "href": "04-vectors_types.html#some-basic-functions-for-creating-vectors",
    "title": "4  Vectors and types",
    "section": "4.4 Some basic functions for creating vectors",
    "text": "4.4 Some basic functions for creating vectors\nThe combine function, c(), can also be used both to create a new vector as well as to append things to an existing vector:\n\nab_vector <- c('a', 'b')\nab_vector\n\n[1] \"a\" \"b\"\n\ncombine_example <- c(ab_vector, 'z')\ncombine_example\n\n[1] \"a\" \"b\" \"z\"\n\n\nYou can also make series of numbers using the : syntax as well as the seq() function:\n\nmySeries <- 1:10\nmySeries\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10, by = 0.1)\n\n [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4\n[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9\n[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4\n[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9\n[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4\n[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9\n[91] 10.0\n\n\nThe head() and tail() functions show the first and last few entries of a vector, respectively.\n\nsequence_example <- 20:25\nhead(sequence_example, n = 2)\n\n[1] 20 21\n\ntail(sequence_example, n = 4)\n\n[1] 22 23 24 25\n\n\nThe length() function computes the number of entries in the vector:\n\nlength(sequence_example)\n\n[1] 6\n\n\nAnd the class() function reports the class/type of the values in the vector:\n\nclass(sequence_example)\n\n[1] \"integer\""
  },
  {
    "objectID": "04-vectors_types.html#accessing-vectors-by-name",
    "href": "04-vectors_types.html#accessing-vectors-by-name",
    "title": "4  Vectors and types",
    "section": "5.1 Accessing vectors by name",
    "text": "5.1 Accessing vectors by name\nEach element of a vector can be given a name:\n\npizza_price <- c(pizzasubito = 5.64, pizzafresh = 6.60, callapizza = 4.50)\n\nTo retrieve a specific named entry from a vector, we can use the square bracket notation:\n\npizza_price[\"pizzasubito\"]\n\npizzasubito \n       5.64 \n\n\nwhich is equivalent to extracting the first entry of the vector:\n\npizza_price[1]\n\npizzasubito \n       5.64 \n\n\nIf you want to extract just the names of an object, use the names() function:\n\nnames(pizza_price)\n\n[1] \"pizzasubito\" \"pizzafresh\"  \"callapizza\" \n\n\nWe have seen how to access and change single elements of a vector. The same is possible for names:\n\nnames(pizza_price)[3]\n\n[1] \"callapizza\"\n\nnames(pizza_price)[3] <- \"call-a-pizza\"\npizza_price\n\n pizzasubito   pizzafresh call-a-pizza \n        5.64         6.60         4.50 \n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nDefine the following vector, y, and extract the “a” and “c” entries:\n\n\n\n\ny\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\ny <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we can name a vector 'on the fly'\ny[c(\"a\", \"c\")]\n\n  a   c \n5.4 7.1 \n\n\nThis is usually a much more reliable way to subset objects: the position of various elements can often change when chaining together subsetting operations, but the names will always remain the same!\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nWhat is the data type of the names of pizza_price? You can find out using the str() or class() functions.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nYou get the names of an object by wrapping the object name inside names(...). Similarly, you get the data type of the names by again wrapping the whole code in class(...):\n\nclass(names(pizza_price))\n\n[1] \"character\"\n\n\nalternatively, use a new variable if this is easier for you to read:\n\nnames <- names(pizza_price)\nclass(names)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nInstead of just changing the names of each element of a vector individually, you can also set all names of an object by writing code like (replace ALL CAPS text):\n\nnames( OBJECT ) <-  CHARACTER_VECTOR\n\nCreate a vector that gives the number for each letter in the alphabet!\n\nGenerate a vector called letter_no with the sequence of numbers from 1 to 26\nR has a built-in object called LETTERS (type LETTERS in the console. It is a 26-character vector of uppercase letters from A to Z. Set the names of letter_no to these 26 letters\nTest yourself by calling letter_no[\"B\"], which should give you the number 2!\n\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\n\nletter_no <- 1:26   # or seq(1,26)\nnames(letter_no) <- LETTERS\nletter_no[\"B\"]\n\nB \n2"
  },
  {
    "objectID": "04-vectors_types.html#accessing-and-changing-vector-names",
    "href": "04-vectors_types.html#accessing-and-changing-vector-names",
    "title": "4  Vectors and types",
    "section": "5.2 Accessing and changing vector names",
    "text": "5.2 Accessing and changing vector names\nIf you want to extract just the names of an object, use the names() function:\n\nnames(pizza_price)\n\n[1] \"pizzasubito\" \"pizzafresh\"  \"callapizza\" \n\n\nWe have seen how to access and change single elements of a vector. The same is possible for names:\n\nnames(pizza_price)[3]\n\n[1] \"callapizza\"\n\nnames(pizza_price)[3] <- \"call-a-pizza\"\npizza_price\n\n pizzasubito   pizzafresh call-a-pizza \n        5.64         6.60         4.50 \n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nWhat is the data type of the names of pizza_price? You can find out using the str() or class() functions.\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nYou get the names of an object by wrapping the object name inside names(...). Similarly, you get the data type of the names by again wrapping the whole code in class(...):\n\nclass(names(pizza_price))\n\n[1] \"character\"\n\n\nalternatively, use a new variable if this is easier for you to read:\n\nnames <- names(pizza_price)\nclass(names)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nInstead of just changing the names of each element of a vector individually, you can also set all names of an object by writing code like (replace ALL CAPS text):\n\nnames( OBJECT ) <-  CHARACTER_VECTOR\n\nCreate a vector that gives the number for each letter in the alphabet!\n\nGenerate a vector called letter_no with the sequence of numbers from 1 to 26\nR has a built-in object called LETTERS (type LETTERS in the console. It is a 26-character vector of uppercase letters from A to Z. Set the names of letter_no to these 26 letters\nTest yourself by calling letter_no[\"B\"], which should give you the number 2!\n\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\n\nletter_no <- 1:26   # or seq(1,26)\nnames(letter_no) <- LETTERS\nletter_no[\"B\"]\n\nB \n2"
  },
  {
    "objectID": "05-vectorization.html#vectorization",
    "href": "05-vectorization.html#vectorization",
    "title": "5  Vectorization",
    "section": "5.1 Vectorization",
    "text": "5.1 Vectorization\nMost of R’s functions are vectorized, meaning that the function will operate on all elements of a vector without needing to loop through and act on each element one at a time. This makes writing code more concise, easy to read, and less error prone.\nFor example, applying multiplication to a vector will conduct the operation element-wise:\n\nx <- 1:4\nx * 2\n\n[1] 2 4 6 8\n\n\nWe can also add two vectors together:\n\ny <- 6:9\nx + y\n\n[1]  7  9 11 13\n\n\nEach element of x was added to its corresponding element of y:\n\nx:  1  2  3  4\n    +  +  +  +\ny:  6  7  8  9\n---------------\n    7  9 11 13\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nLet’s try this on the weight column of the cats dataset. Make a new column in the cats data frame that contains a “calibrated” weight measurement, corresponding to the original weight measurement weight minus 0.5.\nCheck the head or tail of the data frame to make sure it worked.\nTo define the cats data frame, run\n\ncats <- read.csv(file = \"data/feline-data.csv\")\n\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\n\ncats$weight_calibrated <- cats$weight - 0.5\nhead(cats)\n\n    coat weight likes_string weight_calibrated\n1 calico    2.1            1               1.6\n2  black    5.0            0               4.5\n3  tabby    3.2            1               2.7\n\n\n\n\n\n\n\nComparison operators, logical operators, and many functions are also vectorized:\n\n5.1.1 Comparison operators\nComparison operators applied to a vector will produce a boolean vector\n\nx\n\n[1] 1 2 3 4\n\nx > 2\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\n\n\n5.1.2 Functions\nMost functions also operate element-wise on vectors:\n\nx <- 1:4\nx\n\n[1] 1 2 3 4\n\nlog(x)\n\n[1] 0.0000000 0.6931472 1.0986123 1.3862944\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nWe’re interested in looking at the sum of the following sequence of fractions:\n\nx = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)\n\nThis would be tedious to type out, and impossible for high values of n. Use vectorization to compute x when n = 100. What is the sum when n = 10,000?\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\n\nsum(1/(1:100)^2)\n\n[1] 1.634984\n\nsum(1/(1:1e04)^2)\n\n[1] 1.644834\n\n\nWe could do this for a general n using:\n\nn <- 10000\nsum(1/(1:n)^2)\n\n[1] 1.644834\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Operations on vectors of unequal length\n\n\n\nOperations can also be performed on vectors of unequal length, through a process known as recycling. This process automatically repeats the smaller vector until it matches the length of the larger vector. R will provide a warning if the larger vector is not a multiple of the smaller vector.\n\nx <- c(1, 2, 3)\ny <- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 5 7 9 8\n\n\nVector x was recycled to match the length of vector y\n\nx:  1  2  3  1  2  3  1\n    +  +  +  +  +  +  +\ny:  1  2  3  4  5  6  7\n-----------------------\n    2  4  6  5  7  9  8"
  },
  {
    "objectID": "05-vectorization.html#subsetting",
    "href": "05-vectorization.html#subsetting",
    "title": "5  Vectorization",
    "section": "5.2 Subsetting",
    "text": "5.2 Subsetting\nLet’s start with the workhorse of R: a simple numeric vector.\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nx\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nSo now that we’ve created a toy vector to play with, how do we get at its contents?"
  },
  {
    "objectID": "05-vectorization.html#accessing-elements-using-their-indices",
    "href": "05-vectorization.html#accessing-elements-using-their-indices",
    "title": "5  Vectorization",
    "section": "5.3 Accessing elements using their indices",
    "text": "5.3 Accessing elements using their indices\nTo extract elements of a vector we can give their corresponding index, starting from one:\n\nx[1]\n\n  a \n5.4 \n\n\n\nx[4]\n\n  d \n4.8 \n\n\nThe square brackets operator is a function. For vectors, it means “get me the nth element”.\nWe can ask for multiple elements at once by providing a vector if indices:\n\nx[c(1, 3)]\n\n  a   c \n5.4 7.1 \n\n\nOr “slices” of the vector using a sequential integer vector index:\n\nx[1:4]\n\n  a   b   c   d \n5.4 6.2 7.1 4.8 \n\n\nRecall that the : operator creates a sequence of numbers from the left element to the right.\n\n1:4\n\n[1] 1 2 3 4\n\nc(1, 2, 3, 4)\n\n[1] 1 2 3 4\n\n\nWe can ask for the same element multiple times:\n\nx[c(1,1,3)]\n\n  a   a   c \n5.4 5.4 7.1 \n\n\nIf we ask for an index beyond the length of the vector, R will return a missing value:\n\nx[6]\n\n<NA> \n  NA \n\n\nThis is a vector of length one containing an NA, whose name is also NA.\nIf we ask for the 0th element, we get an empty vector:\n\nx[0]\n\nnamed numeric(0)\n\n\n\n\n\n\n\n\nVector numbering in R starts at 1\n\n\n\nIn many programming languages (C and Python, for example), the first element of a vector has an index of 0. In R, the first element is 1."
  },
  {
    "objectID": "05-vectorization.html#skipping-and-removing-elements",
    "href": "05-vectorization.html#skipping-and-removing-elements",
    "title": "5  Vectorization",
    "section": "5.4 Skipping and removing elements",
    "text": "5.4 Skipping and removing elements\nIf we use a negative number as the index of a vector, R will return every element except for the one specified:\n\nx[-2]\n\n  a   c   d   e \n5.4 7.1 4.8 7.5 \n\n\nWe can skip multiple elements:\n\nx[c(-1, -5)]  # or x[-c(1,5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\n\n\n\n\n\nOrder of operations\n\n\n\nA common trip up for novices occurs when trying to skip slices of a vector. It’s natural to try to negate a sequence like so:\n\nx[-1:3]\n\nThis gives a somewhat cryptic error:\n\n\nError in x[-1:3]: only 0's may be mixed with negative subscripts\n\n\nBut remember the order of operations. : is really a function. It takes its first argument as -1, and its second as 3, so generates the sequence of numbers: c(-1, 0, 1, 2, 3). The correct solution is to wrap that function call in brackets, so that the - operator applies to the result:\n\nx[-(1:3)]\n\n  d   e \n4.8 7.5 \n\n\n\n\nTo remove elements from a vector, we need to re-assign the variable to our result:\n\nx <- x[-4]\nx\n\n  a   b   c   e \n5.4 6.2 7.1 7.5 \n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nprint(x)\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nCome up with at least 2 different commands that will produce the following output:\n\n\n  b   c   d \n6.2 7.1 4.8 \n\n\nAfter you find 2 different commands, compare notes with your neighbour. Did you have different strategies?\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\n\nx[2:4]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[-c(1, 5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(2, 3, 4)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(\"b\", \"c\", \"d\")]\n\n  b   c   d \n6.2 7.1 4.8"
  },
  {
    "objectID": "05-vectorization.html#subsetting-by-name",
    "href": "05-vectorization.html#subsetting-by-name",
    "title": "5  Vectorization",
    "section": "5.5 Subsetting by name",
    "text": "5.5 Subsetting by name\nWe can extract elements by using their name, instead of extracting by index:\n\nx <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we can name a vector 'on the fly'\nx[c(\"a\", \"c\")]\n\n  a   c \n5.4 7.1 \n\n\nThis is usually a much more reliable way to subset objects: the position of various elements can often change when chaining together subsetting operations, but the names will always remain the same!"
  },
  {
    "objectID": "05-vectorization.html#subsetting-through-other-logical-operations",
    "href": "05-vectorization.html#subsetting-through-other-logical-operations",
    "title": "5  Vectorization",
    "section": "5.6 Subsetting through other logical operations ",
    "text": "5.6 Subsetting through other logical operations \nWe can also use any logical vector to subset:\n\nx[c(FALSE, FALSE, TRUE, FALSE, TRUE)]\n\n  c   e \n7.1 7.5 \n\n\nSince comparison operators (e.g. >, <, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one.\n\nx[x > 7]\n\n  c   e \n7.1 7.5 \n\n\nBreaking it down, this statement first evaluates x>7, generating a logical vector c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x corresponding to the TRUE values.\nWe can use == to mimic the previous method of indexing by name (remember you have to use == rather than = for comparisons):\n\nnames(x) == \"a\"\n\n[1]  TRUE FALSE FALSE FALSE FALSE\n\nx[names(x) == \"a\"]\n\n  a \n5.4"
  },
  {
    "objectID": "05-vectorization.html#combining-logical-conditions",
    "href": "05-vectorization.html#combining-logical-conditions",
    "title": "5  Vectorization",
    "section": "5.3 Combining logical conditions",
    "text": "5.3 Combining logical conditions\nWe often want to combine multiple logical criteria. For example, we might want to find all the countries that are located in Asia or Europe and have life expectancies within a certain range. Several operations for combining logical vectors exist in R:\n\n&, the “logical AND” operator: returns TRUE if both the left and right are TRUE.\n|, the “logical OR” operator: returns TRUE, if either the left or right (or both) are TRUE.\n\nYou may sometimes see && and || instead of & and |. These two-character operators only look at the first element of each vector and ignore the remaining elements. In general you should not use the two-character operators in data analysis.\n\n!, the “logical NOT” operator: converts TRUE to FALSE and FALSE to TRUE. It can negate a single logical condition (eg !TRUE becomes FALSE), or a whole vector of conditions(eg !c(TRUE, FALSE) becomes c(FALSE, TRUE)).\n\nAdditionally, you can compare the elements within a single vector using the all function (which returns TRUE if every element of the vector is TRUE) and the any function (which returns TRUE if one or more elements of the vector are TRUE).\nFor example, the following code will only return the values of x that are equal to either 5.4 or 7 (since there is no value equal to 7, only the value equal to 5.4 will be returned):\n\n(x == 5.4) | (x == 7)\n\n[1] FALSE FALSE FALSE\n\nx[(x == 5.4) | (x == 7)]\n\nnumeric(0)"
  },
  {
    "objectID": "05-vectorization.html#the-in-operator-in",
    "href": "05-vectorization.html#the-in-operator-in",
    "title": "5  Vectorization",
    "section": "5.4 The in operator %in%",
    "text": "5.4 The in operator %in%\nAnother way to do this is to ask R to subset the values of x that are “in” a vector of values.\n\nx %in% c(5.4, 7)\n\n[1] FALSE FALSE FALSE\n\nx[x %in% c(5.4, 7)]\n\nnumeric(0)\n\n\n\n\n\n\n\n\nTip: Getting help for operators\n\n\n\nRemember you can search for help on operators by wrapping them in quotes: help(\"%in%\") or ?\"%in%\".\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nprint(x)\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nWrite a subsetting command to return the values in x that are greater than 4 and less than 7.\n\n\n\n\n\n\nSolution to challenge 2\n\n\n\n\n\n\nx[x < 7 & x > 4]\n\n  a   b   d \n5.4 6.2 4.8 \n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Non-unique names\n\n\n\nIt is possible for multiple elements in a vector to have the same name. (For a data frame, columns can have the same name too.) Consider these examples:\n\nx <- 1:3\nx\n\n[1] 1 2 3\n\nnames(x) <- c('a', 'a', 'a')\nx\n\na a a \n1 2 3 \n\nx['a']  # only returns first value\n\na \n1 \n\nx[names(x) == 'a']  # returns all three values\n\na a a \n1 2 3"
  },
  {
    "objectID": "05-vectorization.html#removing-named-elements",
    "href": "05-vectorization.html#removing-named-elements",
    "title": "5  Vectorization",
    "section": "5.5 Removing named elements",
    "text": "5.5 Removing named elements\nRemoving named elements is a little harder. If we try to remove one named element by negating the string, R complains (slightly obscurely) that it doesn’t know how to take the negative of a string:\n\nx <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we start again by naming a vector 'on the fly'\nx[-\"a\"]\n\nError in -\"a\": invalid argument to unary operator\n\n\nHowever, we can use the != (not-equals) operator to construct a logical vector that will do what we want:\n\nx[names(x) != \"a\"]\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nSkipping multiple named indices is a little bit harder still. Suppose we want to drop the \"a\" and \"c\" elements, so we try this:\n\nx[names(x) != c(\"a\", \"c\")]\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nR did something, but it gave us a warning that we ought to pay attention to - and it apparently gave us the wrong answer (the \"c\" element is still included in the vector)!\nSo what does != actually do in this case? That’s an excellent question.\n\n5.5.1 Recycling\nLet’s take a look at the comparison component of this code:\n\nnames(x) != c(\"a\", \"c\")\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nWhy does R give TRUE as the third element of this vector, when names(x)[3] != \"c\" is obviously false? When you use !=, R tries to compare each element of the left argument with the corresponding element of its right argument. What happens when you compare vectors of different lengths?\n\n\n\nInequality testing\n\n\nWhen one vector is shorter than the other, it gets recycled:\n\n\n\nInequality testing: results of recycling\n\n\nIn this case R repeats c(\"a\", \"c\") as many times as necessary to match names(x), i.e. we get c(\"a\",\"c\",\"a\",\"c\",\"a\"). Since the recycled \"a\" doesn’t match the third element of names(x), the value of != is TRUE. Because in this case the longer vector length (5) isn’t a multiple of the shorter vector length (2), R printed a warning message. If we had been unlucky and names(x) had contained six elements, R would silently have done the wrong thing (i.e., not what we intended it to do). This recycling rule can can introduce hard-to-find and subtle bugs!\nThe way to get R to do what we really want (match each element of the left argument with all of the elements of the right argument) it to use the %in% operator. The %in% operator goes through each element of its left argument, in this case the names of x, and asks, “Does this element occur in the second argument?”. Here, since we want to exclude values, we also need a ! operator to change “in” to “not in”:\n\nx[!(names(x) %in% c(\"a\", \"c\"))]\n\n  b   d   e \n6.2 4.8 7.5"
  },
  {
    "objectID": "06-data-frames.html",
    "href": "06-data-frames.html",
    "title": "6  Data frames",
    "section": "",
    "text": "7 Data frames\nWe introduced data frames at the very beginning of this lesson, they represent a table of data. Recall our cats data frame:\nColumns of a data frame are vectors of different types, each of the same length, that are organized by belonging to the same table.\nIn our cats example, we have an character, a numeric, and a logical column/variable. As we have seen already, each column of data.frame is a vector."
  },
  {
    "objectID": "06-data-frames.html#extracting-information-from-a-data-frame",
    "href": "06-data-frames.html#extracting-information-from-a-data-frame",
    "title": "6  Data frames",
    "section": "7.1 Extracting information from a data frame",
    "text": "7.1 Extracting information from a data frame\nThere are several ways to extract an individual column in a data frame, including using the $ notation that we used above:\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nBut a column can also be accessed using the square bracket notation:\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nwhich returns the column as a vector.\nThe syntax df[i, j] to extract the entry in the ith row and the jth column from the data frame called df. For example, df[3, 1] will extract the single entry in the third row and first column.\nA blank i or j this tells R to extract all of the rows or columns, respectively. That is, df[, 1] will extract all rows for the 1st column, and df[2, ] will extract the second row across all columns.\n\n7.1.1 The square bracket syntax [ ]\n\ndf[, j] will extract the jth column from the data frame called df as a vector.\ndf[i, ] will extract the ith row from the data frame called df as a data frame.\n\nFor example the following code extracts the data from the second column of cats as a vector\n\ncats[, 2]\n\n[1] 2.1 5.0 3.2\n\n\nand the following code extracts the second row of cats as a data frame:\n\ncats[2, ]\n\n   coat weight likes_string\n2 black      5            0\n\n\nNote, to extract the \\(j\\)th column from a data frame as a single-column data frame, you can use the single-dimension square bracket syntax: df[j].\n\ncats[2]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\nThis syntax also works with named indexing.\n\ncats[\"weight\"]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nThere are several subtly different ways to extract observations and elements from data.frames:\n\ncats[1]\ncats$coat\ncats[\"coat\"]\ncats[1, 1]\ncats[, 1]\ncats[1, ]\n\nTry out these examples and explain what is returned by each one.\nHint: Use the function class() to examine what is returned in each case.\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\n\ncats[1]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nWe can think of a data frame as a list of vectors. The single brace [1] returns the first slice of the list, as another list. In this case it is the first column of the data frame.\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThis example uses the $ character to address items by name. coat is the first column of the data frame, again a vector of type character.\n\ncats[\"coat\"]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nHere we are using a single brace [\"coat\"] replacing the index number with the column name. Like example 1, the returned object is a list.\n\ncats[1, 1]\n\n[1] \"calico\"\n\n\nThis example uses a single brace, but this time we provide row and column coordinates. The returned object is the value in row 1, column 1. The object is a vector of type character.\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nLike the previous example we use single braces and provide row and column coordinates. The row coordinate is not specified, R interprets this missing value as all the elements in this column and returns them as a vector.\n\ncats[1, ]\n\n    coat weight likes_string\n1 calico    2.1            1\n\n\nAgain we use the single brace with row and column coordinates. The column coordinate is not specified. The return value is a list containing all the values in the first row.\n\n\n\n\n\n\n\n\n\n\n\nTip: Renaming data frame columns\n\n\n\nLike vectors, data frames have column names, which can be accessed with the names() function.\n\nnames(cats)\n\n[1] \"coat\"         \"weight\"       \"likes_string\"\n\n\nIf you want to rename the second column of cats, you can assign a new name to the second element of names(cats).\n\nnames(cats)[2] <- \"weight_kg\"\ncats\n\n    coat weight_kg likes_string\n1 calico       2.1            1\n2  black       5.0            0\n3  tabby       3.2            1\n\n\n\n\nLet’s move away from cats to a more interesting data example: gapminder\n\ngapminder <- read.csv(\"data/gapminder_data.csv\")\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSelecting elements of a vector that match “any of” a list of components is a very common data analysis task.\nSuppose we want to pull out information from Southeast Asia, which includes the countries of Myanmar, Thailand, Cambodia, Vietnam, and Laos.\nYour task is to subset the data just to the rows that include the countries in Southeast Asia\n\nDefine a logical vector that is TRUE for all of the countries in southeast Asia and FALSE otherwise.\nUse this logical vector to extract just the rows for Southeast Asia from the gapminder dataset.\n\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\n\nse_asia = gapminder$country %in% c(\"Myanmar\", \"Thailand\", \"Cambodia\", \"Vietnam\", \"Laos\")\ngapminder[se_asia, ]\n\n      country year      pop continent lifeExp gdpPercap\n217  Cambodia 1952  4693836      Asia  39.417  368.4693\n218  Cambodia 1957  5322536      Asia  41.366  434.0383\n219  Cambodia 1962  6083619      Asia  43.415  496.9136\n220  Cambodia 1967  6960067      Asia  45.415  523.4323\n221  Cambodia 1972  7450606      Asia  40.317  421.6240\n222  Cambodia 1977  6978607      Asia  31.220  524.9722\n223  Cambodia 1982  7272485      Asia  50.957  624.4755\n224  Cambodia 1987  8371791      Asia  53.914  683.8956\n225  Cambodia 1992 10150094      Asia  55.803  682.3032\n226  Cambodia 1997 11782962      Asia  56.534  734.2852\n227  Cambodia 2002 12926707      Asia  56.752  896.2260\n228  Cambodia 2007 14131858      Asia  59.723 1713.7787\n1045  Myanmar 1952 20092996      Asia  36.319  331.0000\n1046  Myanmar 1957 21731844      Asia  41.905  350.0000\n1047  Myanmar 1962 23634436      Asia  45.108  388.0000\n1048  Myanmar 1967 25870271      Asia  49.379  349.0000\n1049  Myanmar 1972 28466390      Asia  53.070  357.0000\n1050  Myanmar 1977 31528087      Asia  56.059  371.0000\n1051  Myanmar 1982 34680442      Asia  58.056  424.0000\n1052  Myanmar 1987 38028578      Asia  58.339  385.0000\n1053  Myanmar 1992 40546538      Asia  59.320  347.0000\n1054  Myanmar 1997 43247867      Asia  60.328  415.0000\n1055  Myanmar 2002 45598081      Asia  59.908  611.0000\n1056  Myanmar 2007 47761980      Asia  62.069  944.0000\n1525 Thailand 1952 21289402      Asia  50.848  757.7974\n1526 Thailand 1957 25041917      Asia  53.630  793.5774\n1527 Thailand 1962 29263397      Asia  56.061 1002.1992\n1528 Thailand 1967 34024249      Asia  58.285 1295.4607\n1529 Thailand 1972 39276153      Asia  60.405 1524.3589\n1530 Thailand 1977 44148285      Asia  62.494 1961.2246\n1531 Thailand 1982 48827160      Asia  64.597 2393.2198\n1532 Thailand 1987 52910342      Asia  66.084 2982.6538\n1533 Thailand 1992 56667095      Asia  67.298 4616.8965\n1534 Thailand 1997 60216677      Asia  67.521 5852.6255\n1535 Thailand 2002 62806748      Asia  68.564 5913.1875\n1536 Thailand 2007 65068149      Asia  70.616 7458.3963\n1645  Vietnam 1952 26246839      Asia  40.412  605.0665\n1646  Vietnam 1957 28998543      Asia  42.887  676.2854\n1647  Vietnam 1962 33796140      Asia  45.363  772.0492\n1648  Vietnam 1967 39463910      Asia  47.838  637.1233\n1649  Vietnam 1972 44655014      Asia  50.254  699.5016\n1650  Vietnam 1977 50533506      Asia  55.764  713.5371\n1651  Vietnam 1982 56142181      Asia  58.816  707.2358\n1652  Vietnam 1987 62826491      Asia  62.820  820.7994\n1653  Vietnam 1992 69940728      Asia  67.662  989.0231\n1654  Vietnam 1997 76048996      Asia  70.672 1385.8968\n1655  Vietnam 2002 80908147      Asia  73.017 1764.4567\n1656  Vietnam 2007 85262356      Asia  74.249 2441.5764\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: filter\n\n\n\nIn the dplyr lesson, you will learn another method of filtering to rows of a data frame that satisfy a certain condition using the filter() function from the dplyr package in the tidyverse suite.\n\n\n\n\n7.1.2 Data frame subsetting\n[ with one argument is one way to extract a single column, but the resulting object will be a data frame with one column:\n\nhead(gapminder[3])\n\n       pop\n1  8425333\n2  9240934\n3 10267083\n4 11537966\n5 13079460\n6 14880372\n\n\n[[, however, will act to extract a single column as a vector:\n\nhead(gapminder[[3]])\n\n[1]  8425333  9240934 10267083 11537966 13079460 14880372\n\n\nNotice the difference in the way the two results are presented (the first is a data frame, the second is a vector)\n\nhead(gapminder[[\"lifeExp\"]])\n\n[1] 28.801 30.332 31.997 34.020 36.088 38.438\n\n\nAnd $ provides a convenient shorthand to extract columns by name:\n\nhead(gapminder$year)\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nWith two arguments, [ behaves lets us extract multiple rows and columns:\n\ngapminder[1:3, ]\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nIf we subset a single row, the result will be a data frame (because the elements are mixed types, they can’t be a vector):\n\ngapminder[3, ]\n\n      country year      pop continent lifeExp gdpPercap\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nFor a single column the result will be a vector (this can be changed with the third argument, drop = FALSE).\n\nhead(gapminder[, 2])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nwhich is equivalent to\n\nhead(gapminder[[2]])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nEach of the following pieces of code are incorrect. Identify the error and fix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\ngapminder[gapminder$year = 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\ngapminder[, -1:4]\n\n\nExtract the rows where the life expectancy is longer the 80 years\n\n\ngapminder[gapminder$lifeExp > 80]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\ngapminder[1, 4, 5]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\ngapminder[gapminder$year == 2002 | 2007, ]\n\n\n\n\n\n\n\nSolution to challenge 6\n\n\n\n\n\nFix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\n# gapminder[gapminder$year = 1957, ]\ngapminder[gapminder$year == 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\n# gapminder[, -1:4]\ngapminder[, -c(1:4)]\n\n\nExtract the rows where the life expectancy is longer than 80 years\n\n\n# gapminder[gapminder$lifeExp > 80]\ngapminder[gapminder$lifeExp > 80, ]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\n# gapminder[1, 4, 5]\ngapminder[1, c(4, 5)]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\n# gapminder[gapminder$year == 2002 | 2007, ]\ngapminder[gapminder$year == 2002 | gapminder$year == 2007, ]\n# or\ngapminder[gapminder$year %in% c(2002, 2007), ]\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 7\n\n\n\n\nWhy does gapminder[1:20] return an error? How does it differ from gapminder[1:20, ]?\nCreate a new data.frame called gapminder_subset that only contains rows 1 through 9 and rows 19 through 23.\n\n\n\n\n\n\n\nSolution to challenge 7\n\n\n\n\n\n\ngapminder[1:20] tries to extract the first 20 columns, but there are not 20 columns. gapminder[1:20, ] subsets the data to give the first 20 rows and all columns.\n\n\n\ngapminder_subset <- gapminder[c(1:9, 19:23), ]"
  },
  {
    "objectID": "06-data-frames.html#lists",
    "href": "06-data-frames.html#lists",
    "title": "6  Data frames",
    "section": "7.2 Lists",
    "text": "7.2 Lists\nAnother data structure is the list.\nList are very flexible because you can put anything you want in it: unlike a vector, the elements of a list can have different data types. For example:\n\nlist_example <- list(1, \"a\", TRUE)\nlist_example\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n\nLike a vector, the “length” of a list corresponds to how many entries it contains:\n\nlength(list_example)\n\n[1] 3\n\n\nWhen printing the object structure with str(), we see the data types of all elements:\n\nstr(list_example)\n\nList of 3\n $ : num 1\n $ : chr \"a\"\n $ : logi TRUE\n\n\nTo retrieve one of the elements of a list, we use the double bracket notation:\n\nlist_example[[2]]\n\n[1] \"a\"\n\n\nThe elements of lists also can have names, they can be given by prepending them to the values, separated by an equals sign:\n\nanother_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE)\nanother_list\n\n$title\n[1] \"Numbers\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n[1] TRUE\n\n\nThis results in a named list. Now we have a new function of our object! We can access single elements by an additional way!\n\nanother_list$title\n\n[1] \"Numbers\"\n\n\nas well as using named indexing in the double square bracket notation.\n\nanother_list[[\"title\"]]\n\n[1] \"Numbers\"\n\n\nLists, it turns out, can become a lot more complicated than vectors. While each entry of a vector is just a single value, each entry of a list can be any type of object, including vectors and data frames. For example, the following list of length three contains three entries: a numeric vector, a data frame, and a single character value:\n\ncomplicated_list <- list(vec = c(1, 2, 9),\n                         dataframe = cats, \n                         single_value = \"a\")\ncomplicated_list\n\n$vec\n[1] 1 2 9\n\n$dataframe\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n$single_value\n[1] \"a\"\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nCreate a list of length two containing a character vector containing the letters “x”, “y”, “z” and a data frame with two columns that looks like this.\n\n\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\nYour list output should look like this:\n\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\nSolution to Challenge 6\n\n\n\n\n\n\nlist(c(\"x\", \"y\", \"z\"),\n     data.frame(name = c(\"Henry\", \"Hannah\", \"Harvey\"), grade = c(\"A\", \"B\", \"C\")))\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\n7.2.1 Data frames as a special case of a list\nIt turns out that a data frame is a special kind of a list. Specifically, a data frame is a list of vectors of the same length.\nThis is why you can extract vector columns from a data frame using the double brackets notation:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\n\ncats[[\"coat\"]]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nNote that the df[i, j] index notation is specific to data frames (and does not work for lists).\nYou will learn more about extracting information from vectors, lists and data frames in the advanced subsetting lesson.\n\n\n7.2.2 List subsetting\nNow we’ll introduce some new subsetting operators. There are three functions used to subset lists. We’ve already seen these when learning about atomic vectors and matrices: [, [[, and $.\nUsing [ will always return a list. If you want to subset a list, but not extract an element, then you will likely use [.\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist[1]\n\n$a\n[1] \"Software Carpentry\"\n\n\nThis returns a list with one element.\nWe can subset elements of a list exactly the same way as atomic vectors using [. Comparison operations however won’t work as they’re not recursive, they will try to condition on the data structures in each element of the list, not the individual elements within those data structures.\n\nxlist[1:2]\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nTo extract individual elements of a list, you need to use the double-square bracket function: [[.\n\nxlist[[1]]\n\n[1] \"Software Carpentry\"\n\n\nNotice that now the result is a vector, not a list.\nYou can’t extract more than one element at once:\n\nxlist[[1:2]]\n\nError in xlist[[1:2]]: subscript out of bounds\n\n\nNor use it to skip elements:\n\nxlist[[-1]]\n\nError in xlist[[-1]]: invalid negative subscript in get1index <real>\n\n\nBut you can use names to both subset and extract elements:\n\nxlist[[\"a\"]]\n\n[1] \"Software Carpentry\"\n\n\nThe $ function is a shorthand way for extracting elements by name:\n\nxlist$data\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nGiven the following list:\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nUsing list and vector subsetting, extract the second entry in the second element of the list (i.e., extract the number 2 from the b entry from xlist`). There are several ways to do this. Compare your answer with your neighbor. Did you do it the same way?\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\n\nxlist$b[2]\n\n[1] 2\n\n\n\nxlist[[2]][2]\n\n[1] 2\n\n\n\nxlist[[\"b\"]][2]\n\n[1] 2"
  },
  {
    "objectID": "07-dplyr.html#the-dplyr-package",
    "href": "07-dplyr.html#the-dplyr-package",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.1 The dplyr package",
    "text": "7.1 The dplyr package\nLuckily, the dplyr package provides a number of very useful functions for manipulating data frames in a way that will reduce the above repetition, reduce the probability of making errors, and probably even save you some typing. As an added bonus, you might even find the dplyr grammar easier to read.\n\n\n\n\n\n\nTip: Tidyverse\n\n\n\ndplyr package belongs to a broader family of opinionated R packages designed for data science called the “Tidyverse”. These packages are specifically designed to work harmoniously together. Some of these packages will be covered along this course, but you can find more complete information here: https://www.tidyverse.org/.\n\n\nHere we’re going to cover 5 of the most commonly used functions as well as using pipes (|>) to combine them.\n\nselect()\nfilter()\ngroup_by()\nsummarize()\nmutate()\n\nIf you have have not installed this package earlier, please do so:\n\ninstall.packages('dplyr')\n\nNow let’s load the package:\n\nlibrary(dplyr)\n\nAlternatively, you can load the tidyverse package, which will also install ggplot2 and other related packages:\n\ninstall.packages('tidyverse')\n\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "07-dplyr.html#using-select",
    "href": "07-dplyr.html#using-select",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.2 Using select()",
    "text": "7.2 Using select()\nIf, for example, we wanted to move forward with only a few of the variables in our data frame we could use the select() function. This will keep only the variables you select.\n\nyear_country_gdp <- select(gapminder, year, country, gdpPercap)\n\n If we want to remove one column only from the gapminder data, for example, removing the continent column.\n\nsmaller_gapminder_data <- select(gapminder, -continent)\n\nIf we open up year_country_gdp we’ll see that it only contains the year, country and gdpPercap. Above we used ‘normal’ grammar, but the strengths of dplyr lie in combining several functions using pipes. Since the pipes grammar is unlike anything we’ve seen in R before, let’s repeat what we’ve done above using pipes.\n\nyear_country_gdp <- gapminder |> select(year, country, gdpPercap)\n\nTo help you understand why we wrote that in that way, let’s walk through it step by step. First we summon the gapminder data frame and pass it on, using the pipe symbol |>, to the next step, which is the select() function. In this case we don’t specify which data object we use in the select() function since in gets that from the previous pipe. Fun Fact: There is a good chance you have encountered pipes before in the shell. In R, a pipe symbol is |> while in the shell it is | but the concept is the same!\n\n\n\n\n\n\nTip: Renaming data frame columns in dplyr\n\n\n\nIn Chapter 4 we covered how you can rename columns with base R by assigning a value to the output of the names() function. Just like select, this is a bit cumbersome, but thankfully dplyr has a rename() function. Within a pipeline, the syntax is rename(new_name = old_name). For example, we may want to rename the gdpPercap column name from our select() statement above.\n\ntidy_gdp <- year_country_gdp |> rename(gdp_per_capita = gdpPercap)\nhead(tidy_gdp)\n\n  year     country gdp_per_capita\n1 1952 Afghanistan       779.4453\n2 1957 Afghanistan       820.8530\n3 1962 Afghanistan       853.1007\n4 1967 Afghanistan       836.1971\n5 1972 Afghanistan       739.9811\n6 1977 Afghanistan       786.1134"
  },
  {
    "objectID": "07-dplyr.html#using-filter",
    "href": "07-dplyr.html#using-filter",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.3 Using filter()",
    "text": "7.3 Using filter()\nIf we now want to move forward with the above, but only with European countries, we can combine select and filter\n\nyear_country_gdp_euro <- gapminder |>\n  filter(continent == \"Europe\") |>\n  select(year, country, gdpPercap)\n\nIf we now want to show life expectancy of European countries but only for a specific year (e.g., 2007), we can do as below.\n\neurope_lifeExp_2007 <- gapminder |>\n  filter(continent == \"Europe\", year == 2007) |>\n  select(country, lifeExp)\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nWrite a single command (which can span multiple lines and includes pipes) that will produce a data frame that has the African values for lifeExp, country and year, but not for other Continents. How many rows does your data frame have and why?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\nyear_country_lifeExp_Africa <- gapminder |>\n  filter(continent == \"Africa\") |>\n  select(year, country, lifeExp)\n\n\n\n\n\n\nAs with last time, first we pass the gapminder data frame to the filter() function, then we pass the filtered version of the gapminder data frame to the select() function. Note: The order of operations is very important in this case. If we used ‘select’ first, filter would not be able to find the variable continent since we would have removed it in the previous step."
  },
  {
    "objectID": "07-dplyr.html#using-group_by",
    "href": "07-dplyr.html#using-group_by",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.4 Using group_by()",
    "text": "7.4 Using group_by()\nNow, we were supposed to be reducing the error prone repetitiveness of what can be done with base R, but up to now we haven’t done that since we would have to repeat the above for each continent. Instead of filter(), which will only pass observations that meet your criteria (in the above: continent == \"Europe\"), we can use group_by(), which will essentially use every unique criteria that you could have used in filter.\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\nstr(gapminder |> group_by(continent))\n\ngropd_df [1,704 × 6] (S3: grouped_df/tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num [1:1704] 8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n - attr(*, \"groups\")= tibble [5 × 2] (S3: tbl_df/tbl/data.frame)\n  ..$ continent: chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...\n  ..$ .rows    : list<int> [1:5] \n  .. ..$ : int [1:624] 25 26 27 28 29 30 31 32 33 34 ...\n  .. ..$ : int [1:300] 49 50 51 52 53 54 55 56 57 58 ...\n  .. ..$ : int [1:396] 1 2 3 4 5 6 7 8 9 10 ...\n  .. ..$ : int [1:360] 13 14 15 16 17 18 19 20 21 22 ...\n  .. ..$ : int [1:24] 61 62 63 64 65 66 67 68 69 70 ...\n  .. ..@ ptype: int(0) \n  ..- attr(*, \".drop\")= logi TRUE\n\n\nYou will notice that the structure of the data frame where we used group_by() (grouped_df) is not the same as the original gapminder (data.frame). A grouped_df can be thought of as a list where each item in the listis a data.frame which contains only the rows that correspond to the a particular value continent (at least in the example above).\n\n\n\nDiagram illustrating how the group by function oraganizes a data frame into groups"
  },
  {
    "objectID": "07-dplyr.html#using-summarize",
    "href": "07-dplyr.html#using-summarize",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.5 Using summarize()",
    "text": "7.5 Using summarize()\nThe above was a bit on the uneventful side but group_by() is much more exciting in conjunction with summarize(). This will allow us to create new variable(s) by using functions that repeat for each of the continent-specific data frames. That is to say, using the group_by() function, we split our original data frame into multiple pieces, then we can run functions (e.g. mean() or sd()) within summarize().\n\ngdp_bycontinents <- gapminder |>\n  group_by(continent) |>\n  summarize(mean_gdpPercap = mean(gdpPercap))\n\n\n\n\nDiagram illustrating the use of group by and summarize together to create a new variable\n\n\n\ncontinent mean_gdpPercap\n<fctr>          <dbl>\n  1    Africa       2193.755\n2  Americas       7136.110\n3      Asia       7902.150\n4    Europe      14469.476\n5   Oceania      18621.609\n\nThat allowed us to calculate the mean gdpPercap for each continent, but it gets even better.\n\n\n\n\n\n\nChallenge 2\n\n\n\nCalculate the average life expectancy per country. Which has the longest average life expectancy and which has the shortest average life expectancy?\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nlifeExp_bycountry <- gapminder |>\n  group_by(country) |>\n  summarize(mean_lifeExp = mean(lifeExp))\nlifeExp_bycountry |>\n  filter(mean_lifeExp == min(mean_lifeExp) | mean_lifeExp == max(mean_lifeExp))\n\n# A tibble: 2 × 2\n  country      mean_lifeExp\n  <chr>               <dbl>\n1 Iceland              76.5\n2 Sierra Leone         36.8\n\n\nAnother way to do this is to use the dplyr function arrange(), which arranges the rows in a data frame according to the order of one or more variables from the data frame. It has similar syntax to other functions from the dplyr package. You can use desc() inside arrange() to sort in descending order.\n\nlifeExp_bycountry |>\n  arrange(mean_lifeExp) |>\n  head(1)\n\n# A tibble: 1 × 2\n  country      mean_lifeExp\n  <chr>               <dbl>\n1 Sierra Leone         36.8\n\nlifeExp_bycountry |>\n  arrange(desc(mean_lifeExp)) |>\n  head(1)\n\n# A tibble: 1 × 2\n  country mean_lifeExp\n  <chr>          <dbl>\n1 Iceland         76.5\n\n\nAlphabetical order works too\n\nlifeExp_bycountry |>\n  arrange(desc(country)) |>\n  head(1)\n\n# A tibble: 1 × 2\n  country  mean_lifeExp\n  <chr>           <dbl>\n1 Zimbabwe         52.7\n\n\n\n\n\n\n\nThe function group_by() allows us to group by multiple variables. Let’s group by year and continent.\n\ngdp_bycontinents_byyear <- gapminder |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\nThat is already quite powerful, but it gets even better! You’re not limited to defining 1 new variable in summarize().\n\ngdp_pop_bycontinents_byyear <- gapminder |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            sd_gdpPercap = sd(gdpPercap),\n            mean_pop = mean(pop),\n            sd_pop = sd(pop))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "07-dplyr.html#count-and-n",
    "href": "07-dplyr.html#count-and-n",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.6 count() and n()",
    "text": "7.6 count() and n()\nA very common operation is to count the number of observations for each group. The dplyr package comes with two related functions that help with this.\nFor instance, if we wanted to check the number of countries included in the dataset for the year 2002, we can use the count() function. It takes the name of one or more columns that contain the groups we are interested in, and we can optionally sort the results in descending order by adding sort=TRUE:\n\ngapminder |>\n  filter(year == 2002) |>\n  count(continent, sort = TRUE)\n\n  continent  n\n1    Africa 52\n2      Asia 33\n3    Europe 30\n4  Americas 25\n5   Oceania  2\n\n\nIf we need to use the number of observations in calculations, the n() function is useful. It will return the total number of observations in the current group rather than counting the number of observations in each group within a specific column. For instance, if we wanted to get the standard error of the life expectency per continent:\n\ngapminder |>\n  group_by(continent) |>\n  summarize(se_le = sd(lifeExp)/sqrt(n()))\n\n# A tibble: 5 × 2\n  continent se_le\n  <chr>     <dbl>\n1 Africa    0.366\n2 Americas  0.540\n3 Asia      0.596\n4 Europe    0.286\n5 Oceania   0.775\n\n\nYou can also chain together several summary operations; in this case calculating the minimum, maximum, mean and se of each continent’s per-country life-expectancy:\n\ngapminder |>\n  group_by(continent) |>\n  summarize(\n    mean_le = mean(lifeExp),\n    min_le = min(lifeExp),\n    max_le = max(lifeExp),\n    se_le = sd(lifeExp)/sqrt(n()))\n\n# A tibble: 5 × 5\n  continent mean_le min_le max_le se_le\n  <chr>       <dbl>  <dbl>  <dbl> <dbl>\n1 Africa       48.9   23.6   76.4 0.366\n2 Americas     64.7   37.6   80.7 0.540\n3 Asia         60.1   28.8   82.6 0.596\n4 Europe       71.9   43.6   81.8 0.286\n5 Oceania      74.3   69.1   81.2 0.775"
  },
  {
    "objectID": "07-dplyr.html#using-mutate",
    "href": "07-dplyr.html#using-mutate",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.7 Using mutate()",
    "text": "7.7 Using mutate()\nWe can also create new variables prior to (or even after) summarizing information using mutate().\n\ngdp_pop_bycontinents_byyear <- gapminder |>\n  mutate(gdp_billion = gdpPercap * pop / 10^9) |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            sd_gdpPercap = sd(gdpPercap),\n            mean_pop = mean(pop),\n            sd_pop = sd(pop),\n            mean_gdp_billion = mean(gdp_billion),\n            sd_gdp_billion = sd(gdp_billion))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "07-dplyr.html#connect-mutate-with-logical-filtering-ifelse",
    "href": "07-dplyr.html#connect-mutate-with-logical-filtering-ifelse",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.8 Connect mutate with logical filtering: ifelse",
    "text": "7.8 Connect mutate with logical filtering: ifelse\nWhen creating new variables, we can hook this with a logical condition. A simple combination of mutate() and ifelse() facilitates filtering right where it is needed: in the moment of creating something new. This easy-to-read statement is a fast and powerful way of discarding certain data (even though the overall dimension of the data frame will not change) or for updating values depending on this given condition.\n\n## keeping all data but \"filtering\" after a certain condition\n# calculate GDP only for people with a life expectation above 25\ngdp_pop_bycontinents_byyear_above25 <- gapminder |>\n  mutate(gdp_billion = ifelse(lifeExp > 25, gdpPercap * pop / 10^9, NA)) |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            sd_gdpPercap = sd(gdpPercap),\n            mean_pop = mean(pop),\n            sd_pop = sd(pop),\n            mean_gdp_billion = mean(gdp_billion),\n            sd_gdp_billion = sd(gdp_billion))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n## updating only if certain condition is fullfilled\n# for life expectations above 40 years, the gpd to be expected in the future is scaled\ngdp_future_bycontinents_byyear_high_lifeExp <- gapminder |>\n  mutate(gdp_futureExpectation = ifelse(lifeExp > 40, gdpPercap * 1.5, gdpPercap)) |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_gdpPercap_expected = mean(gdp_futureExpectation))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\nAdvanced Challenge\n\n\n\nCalculate the average life expectancy in 2002 of 2 randomly selected countries for each continent. Then arrange the continent names in reverse order. Hint: Use the dplyr functions arrange() and sample_n(), they have similar syntax to other dplyr functions.\n\n\n\n\n\n\nSolution to Advanced Challenge\n\n\n\n\n\n\nlifeExp_2countries_bycontinents <- gapminder |>\n  filter(year == 2002) |>\n  group_by(continent) |>\n  sample_n(2) |>\n  summarize(mean_lifeExp = mean(lifeExp)) |>\n  arrange(desc(mean_lifeExp))"
  },
  {
    "objectID": "07-dplyr.html#other-great-resources",
    "href": "07-dplyr.html#other-great-resources",
    "title": "7  Data Frame Manipulation with dplyr",
    "section": "7.9 Other great resources",
    "text": "7.9 Other great resources\n\nR for Data Science\nData Wrangling Cheat sheet\nIntroduction to dplyr\nData wrangling with R and RStudio"
  },
  {
    "objectID": "08-functions.html#defining-a-function",
    "href": "08-functions.html#defining-a-function",
    "title": "8  Functions Explained",
    "section": "8.1 Defining a function",
    "text": "8.1 Defining a function\nLet’s open a new R script file in the functions/ directory and call it functions-lesson.R.\nThe general structure of a function is:\n\nmy_function <- function(parameters) {\n  # perform action\n  # return value\n}\n\nLet’s define a function fahr_to_kelvin() that converts temperatures from Fahrenheit to Kelvin:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nWe define fahr_to_kelvin() by assigning it to the output of function. The list of argument names are contained within parentheses. Next, the body of the function–the statements that are executed when it runs–is contained within curly braces ({}). The statements in the body are indented by two spaces. This makes the code easier to read but does not affect how the code operates.\nIt is useful to think of creating functions like writing a cookbook. First you define the “ingredients” that your function needs. In this case, we only need one ingredient to use our function: “temp”. After we list our ingredients, we then say what we will do with them, in this case, we are taking our ingredient and applying a set of mathematical operators to it.\nWhen we call the function, the values we pass to it as arguments are assigned to those variables so that we can use them inside the function. Inside the function, we use a return statement to send a result back to whoever asked for it.\n\n\n\n\n\n\nReturn statements\n\n\n\nOne feature unique to R is that the return statement is not required. R automatically returns whichever variable is on the last line of the body of the function. But for clarity, we will explicitly define the return statement.\n\n\nLet’s try running our function. Calling our own function is no different from calling any other function:\n\n# freezing point of water\nfahr_to_kelvin(32)\n\n[1] 273.15\n\n\n\n# boiling point of water\nfahr_to_kelvin(212)\n\n[1] 373.15\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nWrite a function called kelvin_to_celsius() that takes a temperature in Kelvin and returns that temperature in Celsius. Hint: To convert from Kelvin to Celsius you subtract 273.15\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\nWrite a function called kelvin_to_celsius that takes a temperature in Kelvin and returns that temperature in Celsius\n\nkelvin_to_celsius <- function(temp) {\ncelsius <- temp - 273.15\nreturn(celsius)\n}"
  },
  {
    "objectID": "08-functions.html#combining-functions",
    "href": "08-functions.html#combining-functions",
    "title": "8  Functions Explained",
    "section": "8.2 Combining functions",
    "text": "8.2 Combining functions\nThe real power of functions comes from mixing, matching and combining them into ever-larger chunks to get the effect we want.\nLet’s define two functions that will convert temperature from Fahrenheit to Kelvin, and Kelvin to Celsius:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nkelvin_to_celsius <- function(temp) {\n  celsius <- temp - 273.15\n  return(celsius)\n}\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nDefine the function to convert directly from Fahrenheit to Celsius, by reusing the two functions above (or using your own functions if you prefer).\n\n\n\n\n\n\nSolution to challenge 2\n\n\n\n\n\nDefine the function to convert directly from Fahrenheit to Celsius, by reusing these two functions above\n\nfahr_to_celsius <- function(temp) {\n temp_k <- fahr_to_kelvin(temp)\n result <- kelvin_to_celsius(temp_k)\n return(result)\n}"
  },
  {
    "objectID": "08-functions.html#interlude-defensive-programming",
    "href": "08-functions.html#interlude-defensive-programming",
    "title": "8  Functions Explained",
    "section": "8.3 Interlude: Defensive Programming",
    "text": "8.3 Interlude: Defensive Programming\nNow that we’ve begun to appreciate how writing functions provides an efficient way to make R code re-usable and modular, we should note that it is important to ensure that functions only work in their intended use-cases. Checking function parameters is related to the concept of defensive programming. Defensive programming encourages us to frequently check conditions and throw an error if something is wrong. These checks are referred to as assertion statements because we want to assert some condition is TRUE before proceeding. They make it easier to debug because they give us a better idea of where the errors originate.\n\n8.3.1 Checking conditions with stopifnot()\nLet’s start by re-examining fahr_to_kelvin(), our function for converting temperatures from Fahrenheit to Kelvin. It was defined like so:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nFor this function to work as intended, the argument temp must be a numeric value; otherwise, the mathematical procedure for converting between the two temperature scales will not work. To create an error, we can use the function stop(). For example, since the argument temp must be a numeric vector, we could check for this condition with an if statement and throw an error if the condition was violated. We could augment our function above like so:\n\nfahr_to_kelvin <- function(temp) {\n  if (!is.numeric(temp)) {\n    stop(\"temp must be a numeric vector.\")\n  }\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nIf we had multiple conditions or arguments to check, it would take many lines of code to check all of them. Luckily R provides the convenience function stopifnot(). We can list as many requirements that should evaluate to TRUE; stopifnot() throws an error if it finds one that is FALSE. Listing these conditions also serves a secondary purpose as extra documentation for the function.\nLet’s try out defensive programming with stopifnot() by adding assertions to check the input to our function fahr_to_kelvin().\nWe want to assert the following: temp is a numeric vector. We may do that like so:\n\nfahr_to_kelvin <- function(temp) {\n  stopifnot(is.numeric(temp))\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nIt still works when given proper input.\n\n# freezing point of water\nfahr_to_kelvin(temp = 32)\n\n[1] 273.15\n\n\nBut fails instantly if given improper input.\n\n# Metric is a factor instead of numeric\nfahr_to_kelvin(temp = as.factor(32))\n\nError in fahr_to_kelvin(temp = as.factor(32)): is.numeric(temp) is not TRUE\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nUse defensive programming to ensure that our fahr_to_celsius() function throws an error immediately if the argument temp is specified inappropriately.\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nExtend our previous definition of the function by adding in an explicit call to stopifnot(). Since fahr_to_celsius() is a composition of two other functions, checking inside here makes adding checks to the two component functions redundant.\n\nfahr_to_celsius <- function(temp) {\n stopifnot(is.numeric(temp))\n temp_k <- fahr_to_kelvin(temp)\n result <- kelvin_to_celsius(temp_k)\n return(result)\n}"
  },
  {
    "objectID": "08-functions.html#more-on-combining-functions",
    "href": "08-functions.html#more-on-combining-functions",
    "title": "8  Functions Explained",
    "section": "8.4 More on combining functions",
    "text": "8.4 More on combining functions\nNow, we’re going to define a function that calculates the Gross Domestic Product of a nation from the data available in our dataset:\n\n# Takes a dataset and multiplies the population column\n# with the GDP per capita column.\ncalcGDP <- function(dat) {\n  gdp <- dat$pop * dat$gdpPercap\n  return(gdp)\n}\n\nWe define calcGDP() by assigning it to the output of function. The list of argument names are contained within parentheses. Next, the body of the function – the statements executed when you call the function – is contained within curly braces ({}).\nWe’ve indented the statements in the body by two spaces. This makes the code easier to read but does not affect how it operates.\nWhen we call the function, the values we pass to it are assigned to the arguments, which become variables inside the body of the function.\nInside the function, we use the return() function to send back the result. This return() function is optional: R will automatically return the results of whatever command is executed on the last line of the function.\n\ncalcGDP(head(gapminder))\n\n[1]  6567086330  7585448670  8758855797  9648014150  9678553274 11697659231\n\n\nThat’s not very informative. Let’s add some more arguments so we can extract that per year and country.\n\n# Takes a dataset and multiplies the population column\n# with the GDP per capita column.\ncalcGDP <- function(dat, year=NULL, country=NULL) {\n  if(!is.null(year)) {\n    dat <- dat[dat$year %in% year, ]\n  }\n  if (!is.null(country)) {\n    dat <- dat[dat$country %in% country,]\n  }\n  gdp <- dat$pop * dat$gdpPercap\n\n  new <- cbind(dat, gdp=gdp)\n  return(new)\n}\n\nIf you’ve been writing these functions down into a separate R script (a good idea!), you can load in the functions into our R session by using the source() function:\n\nsource(\"functions/functions-lesson.R\")\n\nOk, so there’s a lot going on in this function now. In plain English, the function now subsets the provided data by year if the year argument isn’t empty, then subsets the result by country if the country argument isn’t empty. Then it calculates the GDP for whatever subset emerges from the previous two steps. The function then adds the GDP as a new column to the subsetted data and returns this as the final result. You can see that the output is much more informative than a vector of numbers.\nLet’s take a look at what happens when we specify the year:\n\nhead(calcGDP(gapminder, year = 2007))\n\n       country year      pop continent lifeExp  gdpPercap          gdp\n12 Afghanistan 2007 31889923      Asia  43.828   974.5803  31079291949\n24     Albania 2007  3600523    Europe  76.423  5937.0295  21376411360\n36     Algeria 2007 33333216    Africa  72.301  6223.3675 207444851958\n48      Angola 2007 12420476    Africa  42.731  4797.2313  59583895818\n60   Argentina 2007 40301927  Americas  75.320 12779.3796 515033625357\n72   Australia 2007 20434176   Oceania  81.235 34435.3674 703658358894\n\n\nOr for a specific country:\n\ncalcGDP(gapminder, country = \"Australia\")\n\n     country year      pop continent lifeExp gdpPercap          gdp\n61 Australia 1952  8691212   Oceania  69.120  10039.60  87256254102\n62 Australia 1957  9712569   Oceania  70.330  10949.65 106349227169\n63 Australia 1962 10794968   Oceania  70.930  12217.23 131884573002\n64 Australia 1967 11872264   Oceania  71.100  14526.12 172457986742\n65 Australia 1972 13177000   Oceania  71.930  16788.63 221223770658\n66 Australia 1977 14074100   Oceania  73.490  18334.20 258037329175\n67 Australia 1982 15184200   Oceania  74.740  19477.01 295742804309\n68 Australia 1987 16257249   Oceania  76.320  21888.89 355853119294\n69 Australia 1992 17481977   Oceania  77.560  23424.77 409511234952\n70 Australia 1997 18565243   Oceania  78.830  26997.94 501223252921\n71 Australia 2002 19546792   Oceania  80.370  30687.75 599847158654\n72 Australia 2007 20434176   Oceania  81.235  34435.37 703658358894\n\n\nOr both:\n\ncalcGDP(gapminder, year = 2007, country = \"Australia\")\n\n     country year      pop continent lifeExp gdpPercap          gdp\n72 Australia 2007 20434176   Oceania  81.235  34435.37 703658358894\n\n\nLet’s walk through the body of the function:\n\ncalcGDP <- function(dat, year = NULL, country = NULL) {\n\nHere we’ve added two arguments, year, and country. We’ve set default arguments for both as NULL using the = operator in the function definition. This means that those arguments will take on those values unless the user specifies otherwise.\n\n  if(!is.null(year)) {\n    dat <- dat[dat$year %in% year, ]\n  }\n  if (!is.null(country)) {\n    dat <- dat[dat$country %in% country,]\n  }\n\nHere, we check whether each additional argument is set to null, and whenever they’re not null overwrite the dataset stored in dat with a subset given by the non-null argument.\nBuilding these conditionals into the function makes it more flexible for later. Now, we can use it to calculate the GDP for:\n\nThe whole dataset;\nA single year;\nA single country;\nA single combination of year and country.\n\nBy using %in% instead, we can also give multiple years or countries to those arguments.\n\n\n\n\n\n\nTip: Pass by value\n\n\n\nFunctions in R almost always make copies of the data to operate on inside of a function body. When we modify dat inside the function we are modifying the copy of the gapminder dataset stored in dat, not the original variable we gave as the first argument. This is called “pass-by-value” and it makes writing code much safer: you can always be sure that whatever changes you make within the body of the function, stay inside the body of the function.\n\n\n\n\n\n\n\n\nTip: Function scope\n\n\n\nAnother important concept is scoping: any variables (or functions!) you create or modify inside the body of a function only exist for the lifetime of the function’s execution. When we call calcGDP(), the variables dat, gdp and new only exist inside the body of the function. Even if we have variables of the same name in our interactive R session, they are not modified in any way when executing a function.\n\n\n\n  gdp <- dat$pop * dat$gdpPercap\n  new <- cbind(dat, gdp=gdp)\n  return(new)\n}\n\nFinally, we calculated the GDP on our new subset, and created a new data frame with that column added. This means when we call the function later we can see the context for the returned GDP values, which is much better than in our first attempt where we got a vector of numbers.\n\n\n\n\n\n\nChallenge 4\n\n\n\nTest out your GDP function by calculating the GDP for New Zealand in 1987. How does this differ from New Zealand’s GDP in 1952?\n\n\n\n\n\n\nSolution to challenge 4\n\n\n\n\n\n\n calcGDP(gapminder, year = c(1952, 1987), country = \"New Zealand\")\n\nGDP for New Zealand in 1987: 65050008703 GDP for New Zealand in 1952: 21058193787\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nThe paste() function can be used to combine text together, e.g:\n\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\npaste(best_practice, collapse=\" \")\n\n[1] \"Write programs for people not computers\"\n\n\nWrite a function called fence() that takes two vectors as arguments, called text and wrapper, and prints out the text wrapped with the wrapper:\n\nfence(text=best_practice, wrapper=\"***\")\n\nNote: the paste() function has an argument called sep, which specifies the separator between text. The default is a space: ” “. The default for paste0() is no space”“.\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\nWrite a function called fence() that takes two vectors as arguments, called text and wrapper, and prints out the text wrapped with the wrapper:\n\nfence <- function(text, wrapper){\n text <- c(wrapper, text, wrapper)\n result <- paste(text, collapse = \" \")\n return(result)\n}\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\nfence(text=best_practice, wrapper=\"***\")\n\n[1] \"*** Write programs for people not computers ***\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nR has some unique aspects that can be exploited when performing more complicated operations. We will not be writing anything that requires knowledge of these more advanced concepts. In the future when you are comfortable writing functions in R, you can learn more by reading the R Language Manual or this chapter from Advanced R Programming by Hadley Wickham.\n\n\n\n\n\n\n\n\nTip: Testing and documenting\n\n\n\nIt’s important to both test functions and document them: Documentation helps you, and others, understand what the purpose of your function is, and how to use it, and its important to make sure that your function actually does what you think.\nWhen you first start out, your workflow will probably look a lot like this:\n\nWrite a function\nComment parts of the function to document its behaviour\nLoad in the source file\nExperiment with it in the console to make sure it behaves as you expect\nMake any necessary bug fixes\nRinse and repeat.\n\nFormal documentation for functions, written in separate .Rd files, gets turned into the documentation you see in help files. The roxygen2 package allows R coders to write documentation alongside the function code and then process it into the appropriate .Rd files. You will want to switch to this more formal method of writing documentation when you start writing more complicated R projects. In fact, packages are, in essence, bundles of functions with this formal documentation. Loading your own functions through source(\"functions.R\") is equivalent to loading someone else’s functions (or your own one day!) through library(\"package\").\nFormal automated tests can be written using the testthat package."
  },
  {
    "objectID": "09-control-flow.html#if-statements",
    "href": "09-control-flow.html#if-statements",
    "title": "9  Control Flow",
    "section": "9.1 “If” statements",
    "text": "9.1 “If” statements\nThere are several ways you can control flow in R. For conditional statements, the most commonly used approaches are the constructs:\n\n# if\nif (condition is true) {\n  perform action\n}\n\n# if ... else\nif (condition is true) {\n  perform action\n} else {  # that is, if the condition is false,\n  perform alternative action\n}\n\nSay, for example, that we want R to print a message if a variable x has a particular value:\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n}\n\nThe print statement does not appear in the console because x (8) is not greater than 10. To print a different message for numbers less than 10, we can add an else statement.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else {\n  print(\"x is less than 10\")\n}\n\n[1] \"x is less than 10\"\n\n\nYou can also test multiple conditions by using else if.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else if (x > 5) {\n  print(\"x is greater than 5, but less than 10\")\n} else {\n  print(\"x is less than 5\")\n}\n\n[1] \"x is greater than 5, but less than 10\"\n\n\nImportant: when R evaluates the condition inside if() statements, it is looking for a logical value (TRUE or FALSE).\n\n\n\n\n\n\nIf statements in functions\n\n\n\nIf statements might not seem all that useful on their own, but they are incredibly useful for writing functions (as we will learn in the next lesson).\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nUse an if() statement to print a suitable message reporting whether there are any records from 2002 in the gapminder dataset.\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nWe first obtain a logical vector describing which element of gapminder$year is equal to 2002:\n\nif (2002 %in% gapminder$year) {\n  print(\"Record(s) for the year 2002 found.\")\n}\n\n[1] \"Record(s) for the year 2002 found.\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: A common error with if() statements\n\n\n\nA common error with if() statements looks like:\n\n\nError in if (gapminder$year == 2012) {: the condition has length > 1\n\n\nThe if() function only accepts singular (of length 1) inputs, and therefore returns an error when you supply it with a vector.\nThe if() function will still run, but will only evaluate the condition in the first element of the vector.\nTherefore, to use the if() function, you need to make sure your input is a single value (of length 1), rather than a vector."
  },
  {
    "objectID": "09-control-flow.html#repeating-operations",
    "href": "09-control-flow.html#repeating-operations",
    "title": "9  Control Flow",
    "section": "9.2 Repeating operations",
    "text": "9.2 Repeating operations\nIf you want to iterate over a set of values, when the order of iteration is important, and perform the same operation on each, one way to do this is using a for() loop.\nIn general, the advice of many R users would be to learn about for() loops, but to avoid using for() loops unless the order of iteration is important: i.e. the calculation at each iteration depends on the results of previous iterations.\nThe basic structure of a for() loop is:\n\nfor (iterator in set of values) {\n  do a thing\n}\n\nFor example:\n\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\n\nx <- c()\nfor (i in 1:10) {\n  x[i] <- exp(i)\n}\nx\n\n [1]     2.718282     7.389056    20.085537    54.598150   148.413159\n [6]   403.428793  1096.633158  2980.957987  8103.083928 22026.465795\n\n\nThe 1:10 bit creates a vector on the fly; you can iterate over any other vector as well.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor loops are common in programming in general, for loops are rarely used in R, primarily due to their computational inefficiency.\nInstead, a much more efficient method for iterating in R is using the map() functions from the purrr R package. To load the purrr R package, you need to run the following code (if the purrr package is not installed, you will need to run the commented install.packages() line)\n\n# install.packages(\"purrr\")\nlibrary(purrr)\n\nThe first argument from the map() function is the object that we want to iterate over. The second argument is the function that we want to apply at each iteration. The output of the map() function is always a list.\nFor example, the following code will apply the exp() function to each entry in the vector 1:10 and return the results in a list:\n\nmap(1:10, exp)\n\n[[1]]\n[1] 2.718282\n\n[[2]]\n[1] 7.389056\n\n[[3]]\n[1] 20.08554\n\n[[4]]\n[1] 54.59815\n\n[[5]]\n[1] 148.4132\n\n[[6]]\n[1] 403.4288\n\n[[7]]\n[1] 1096.633\n\n[[8]]\n[1] 2980.958\n\n[[9]]\n[1] 8103.084\n\n[[10]]\n[1] 22026.47\n\n\nSince lists are unwieldy, there are several versions of the map() function, such as map_dbl() that specifies the type of your output. For instance, if you want your output to be a numeric “double” vector, you can use map_dbl():\n\nmap_dbl(1:10, exp)\n\n [1]     2.718282     7.389056    20.085537    54.598150   148.413159\n [6]   403.428793  1096.633158  2980.957987  8103.083928 22026.465795\n\n\nand if you want it to be a character vector, you can use map_chr():\n\nmap_chr(gapminder, class)\n\n    country        year         pop   continent     lifeExp   gdpPercap \n\"character\"   \"integer\"   \"numeric\" \"character\"   \"numeric\"   \"numeric\" \n\n\nHere, recall that the gapminder data frame is a list, and the map_ function is iterating over the elements of the list, which in this case is the columns.\nNote that the output of the function you are applying must match the map_ function that you use, else you will get an error:\n\nmap_dbl(1:10, class)\n\nError in `map_dbl()`:\nℹ In index: 1.\nCaused by error:\n! Can't coerce from a string to a double vector.\n\n\nThe true power from the map functions really comes once you learn how to write your own functions (see future lesson on functions).\n\n\n\n\n\n\nChallenge 2 (advanced)\n\n\n\nFor each numeric column in the gapminder dataset, print the number of unique entries using the length() and unique() function.\nDo this in two different ways: using a for loop and a map() function.\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nnumeric_columns <- is.numeric(gapminder)\nfor (i in 1:ncol(gapminder)) {\n  print(mean(gapminder[, i]))\n}\n\nWarning in mean.default(gapminder[, i]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n[1] 1979.5\n[1] 29601212\n\n\nWarning in mean.default(gapminder[, i]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n[1] 59.47444\n[1] 7215.327\n\n\n\nmap(gapminder, mean)\n\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n\n\n$country\n[1] NA\n\n$year\n[1] 1979.5\n\n$pop\n[1] 29601212\n\n$continent\n[1] NA\n\n$lifeExp\n[1] 59.47444\n\n$gdpPercap\n[1] 7215.327\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nModify the script from Challenge 3 to loop over each country. This time print out whether the life expectancy is smaller than 50, between 50 and 70, or greater than 70.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nWe modify our solution to Challenge 3 by now adding two thresholds, lowerThreshold and upperThreshold and extending our if-else statements:\n\nlowerThreshold <- 50\nupperThreshold <- 70\nfor (iCountry in unique(gapminder$country)) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if(tmp < lowerThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", lowerThreshold, \"\\n\")\n   } else if(tmp > lowerThreshold && tmp < upperThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is between\", lowerThreshold, \"and\", upperThreshold, \"\\n\")\n   } else {\n       cat(\"Average Life Expectancy in\", iCountry, \"is greater than\", upperThreshold, \"\\n\")\n   }\n   rm(tmp)\n}\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5 - Advanced\n\n\n\nWrite a script that loops over each country in the gapminder dataset, tests whether the country starts with a ‘B’, and graphs life expectancy against time as a line graph if the mean life expectancy is under 50 years.\n\n\n\n\n\n\nSolution for Challenge 5\n\n\n\n\n\nWe will use the grep() command that was introduced in the Unix Shell lesson to find countries that start with “B.” Lets understand how to do this first. Following from the Unix shell section we may be tempted to try the following\n\ngrep(\"^B\", unique(gapminder$country))\n\nBut when we evaluate this command it returns the indices of the factor variable country that start with “B.” To get the values, we must add the value = TRUE option to the grep() command:\n\ngrep(\"^B\", unique(gapminder$country), value = TRUE)\n\nWe will now store these countries in a variable called candidateCountries, and then loop over each entry in the variable. Inside the loop, we evaluate the average life expectancy for each country, and if the average life expectancy is less than 50 we use base-plot to plot the evolution of average life expectancy using with() and subset():\n\nthresholdValue <- 50\ncandidateCountries <- grep(\"^B\", unique(gapminder$country), value = TRUE)\nfor (iCountry in candidateCountries) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if (tmp < thresholdValue) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", thresholdValue, \"plotting life expectancy graph... \\n\")\n       with(subset(gapminder, country == iCountry),\n               plot(year, lifeExp,\n                    type = \"o\",\n                    main = paste(\"Life Expectancy in\", iCountry, \"over time\"),\n                    ylab = \"Life Expectancy\",\n                    xlab = \"Year\"\n                    ) # end plot\n            ) # end with\n   } # end if\n   rm(tmp)\n} # end for loop"
  },
  {
    "objectID": "10-plot-ggplot2.html#layers",
    "href": "10-plot-ggplot2.html#layers",
    "title": "10  Data visualization with ggplot2",
    "section": "10.1 Layers",
    "text": "10.1 Layers\nUsing a scatterplot probably isn’t the best for visualizing change over time. Instead, let’s tell ggplot to visualize the data as a line plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, color=continent)) +\n  geom_line()\n\n\n\n\nInstead of adding a geom_point layer, we’ve added a geom_line layer.\nHowever, the result doesn’t look quite as we might have expected: it seems to be jumping around a lot in each continent. Let’s try to separate the data by country, plotting one line for each country:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line()\n\n\n\n\nWe’ve added the group aesthetic, which tells ggplot to draw a line for each country.\nBut what if we want to visualize both lines and points on the plot? We can add another layer to the plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line() + geom_point()\n\n\n\n\nIt’s important to note that each layer is drawn on top of the previous layer. In this example, the points have been drawn on top of the lines. Here’s a demonstration:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_line(mapping = aes(color=continent)) + geom_point()\n\n\n\n\nIn this example, the aesthetic mapping of color has been moved from the global plot options in ggplot to the geom_line layer so it no longer applies to the points. Now we can clearly see that the points are drawn on top of the lines.\n\n\n\n\n\n\nTip: Setting an aesthetic to a value instead of a mapping\n\n\n\nSo far, we’ve seen how to use an aesthetic (such as color) as a mapping to a variable in the data. For example, when we use geom_line(mapping = aes(color=continent)), ggplot will give a different color to each continent. But what if we want to change the color of all lines to blue? You may think that geom_line(mapping = aes(color=\"blue\")) should work, but it doesn’t. Since we don’t want to create a mapping to a specific variable, we can move the color specification outside of the aes() function, like this: geom_line(color=\"blue\").\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSwitch the order of the point and line layers from the previous example. What happened?\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nThe lines now get drawn over the points!\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_point() + geom_line(mapping = aes(color=continent))\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The plot illustrates the possibilities for styling visualisations in ggplot2 with data points enlarged, coloured orange, and displayed without transparency."
  },
  {
    "objectID": "10-plot-ggplot2.html#transformations-and-statistics",
    "href": "10-plot-ggplot2.html#transformations-and-statistics",
    "title": "10  Data visualization with ggplot2",
    "section": "10.2 Transformations and statistics",
    "text": "10.2 Transformations and statistics\nggplot2 also makes it easy to overlay statistical models over the data. To demonstrate we’ll go back to our first example:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nCurrently it’s hard to see the relationship between the points due to some strong outliers in GDP per capita. We can change the scale of units on the x axis using the scale functions. These control the mapping between the data values and visual values of an aesthetic. We can also modify the transparency of the points, using the alpha function, which is especially helpful when you have a large amount of data which is very clustered.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10()\n\n\n\n\nScatterplot of GDP vs life expectancy showing logarithmic x-axis data spread\n\n\n\n\nThe scale_x_log10 function applied a transformation to the coordinate system of the plot, so that each multiple of 10 is evenly spaced from left to right. For example, a GDP per capita of 1,000 is the same horizontal distance away from a value of 10,000 as the 10,000 value is from 100,000. This helps to visualize the spread of the data along the x-axis.\n\n\n\n\n\n\nTip Reminder: Setting an aesthetic to a value instead of a mapping\n\n\n\nNotice that we used geom_point(alpha = 0.5). As the previous tip mentioned, using a setting outside of the aes() function will cause this value to be used for all points, which is what we want in this case. But just like any other aesthetic setting, alpha can also be mapped to a variable in the data. For example, we can give a different transparency to each continent with geom_point(mapping = aes(alpha = continent)).\n\n\nWe can fit a simple relationship to the data by adding another layer, geom_smooth:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a blue trend line summarising the relationship between variables, and gray shaded area indicating 95% confidence intervals for that trend line.\n\n\n\n\nWe can make the line thicker by setting the size aesthetic in the geom_smooth layer:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\", size=1.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The blue trend line is slightly thicker than in the previous figure.\n\n\n\n\nThere are two ways an aesthetic can be specified. Here we set the size aesthetic by passing it as an argument to geom_smooth. Previously in the lesson we’ve used the aes function to define a mapping between data variables and their visual representation.\n\n\n\n\n\n\nChallenge 4a\n\n\n\nModify the color and size of the points on the point layer in the previous example. Hint: do not use the aes function.\n\n\n\n\n\n\nSolution to challenge 4a\n\n\n\n\n\nHere a possible solution:\nNotice that the color argument is supplied outside of the aes() function. This means that it applies to all data points on the graph and is not related to a specific variable.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\ngeom_point(size = 3, color = \"orange\") + scale_x_log10() +\ngeom_smooth(method = \"lm\", size = 1.5)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4b\n\n\n\nModify your solution to Challenge 4a so that the points are now a different shape and are colored by continent with new trendlines. Hint: The color argument can be used inside the aesthetic.\n\n\n\n\n\n\nSolution to challenge 4b\n\n\n\n\n\nHere is a possible solution:\nNotice that supplying the color argument inside the aes() functions enables you to connect it to a certain variable. The shape argument, as you can see, modifies all data points the same way (it is outside the aes() call) while the color argument which is placed inside the aes() call modifies a point’s color based on its continent value.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\ngeom_point(size=3, shape=17) + scale_x_log10() +\ngeom_smooth(method=\"lm\", size=1.5)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "10-plot-ggplot2.html#multi-panel-figures",
    "href": "10-plot-ggplot2.html#multi-panel-figures",
    "title": "10  Data visualization with ggplot2",
    "section": "10.3 Multi-panel figures",
    "text": "10.3 Multi-panel figures\nEarlier we visualized the change in life expectancy over time across all countries in one plot. Alternatively, we can split this out over multiple panels by adding a layer of facet panels.\n\n\n\n\n\n\nTip\n\n\n\nWe start by making a subset of data including only countries located in the Americas. This includes 25 countries, which will begin to clutter the figure. Note that we apply a “theme” definition to rotate the x-axis labels to maintain readability. Nearly everything in ggplot2 is customizable.\n\n\n\namericas <- gapminder[gapminder$continent == \"Americas\",]\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThe facet_wrap layer took a “formula” as its argument, denoted by the tilde (~). This tells R to draw a panel for each unique value in the country column of the gapminder dataset."
  },
  {
    "objectID": "10-plot-ggplot2.html#modifying-text",
    "href": "10-plot-ggplot2.html#modifying-text",
    "title": "10  Data visualization with ggplot2",
    "section": "10.4 Modifying text",
    "text": "10.4 Modifying text\nTo clean this figure up for a publication we need to change some of the text elements. The x-axis is too cluttered, and the y axis should read “Life expectancy”, rather than the column name in the data frame.\nWe can do this by adding a couple of different layers. The theme layer controls the axis text, and overall text size. Labels for the axes, plot title and any legend can be set using the labs function. Legend titles are set using the same names we used in the aes specification. Thus below the color legend title is set using color = \"Continent\", while the title of a fill legend would be set using fill = \"MyTitle\".\n\nggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))"
  },
  {
    "objectID": "10-plot-ggplot2.html#exporting-the-plot",
    "href": "10-plot-ggplot2.html#exporting-the-plot",
    "title": "10  Data visualization with ggplot2",
    "section": "10.5 Exporting the plot",
    "text": "10.5 Exporting the plot\nThe ggsave() function allows you to export a plot created with ggplot. You can specify the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi) to create high quality graphics for publication. In order to save the plot from above, we first assign it to a variable lifeExp_plot, then tell ggsave to save that plot in png format to a directory called results. (Make sure you have a results/ folder in your working directory.)\n\n\n\n\nlifeExp_plot <- ggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\nggsave(filename = \"results/lifeExp.png\", plot = lifeExp_plot, width = 12, height = 10, dpi = 300, units = \"cm\")\n\nThere are two nice things about ggsave. First, it defaults to the last plot, so if you omit the plot argument it will automatically save the last plot you created with ggplot. Secondly, it tries to determine the format you want to save your plot in from the file extension you provide for the filename (for example .png or .pdf). If you need to, you can specify the format explicitly in the device argument.\nThis is a taste of what you can do with ggplot2. RStudio provides a really useful cheat sheet of the different layers available, and more extensive documentation is available on the ggplot2 website. Finally, if you have no idea how to change something, a quick Google search will usually send you to a relevant question and answer on Stack Overflow with reusable code to modify!\n\n\n\n\n\n\nChallenge 5\n\n\n\nGenerate boxplots to compare life expectancy between the different continents during the available years.\nAdvanced:\n\nRename y axis as Life Expectancy.\nRemove x axis labels.\n\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nHere a possible solution:\nxlab() and ylab() set labels for the x and y axes, respectively The axis title, text and ticks are attributes of the theme and must be modified within a theme() call.\n\nggplot(data = gapminder, mapping = aes(x = continent, y = lifeExp, fill = continent)) +\ngeom_boxplot() + facet_wrap(~year) +\nylab(\"Life Expectancy\") +\ntheme(axis.title.x=element_blank(),\n      axis.text.x = element_blank(),\n      axis.ticks.x = element_blank())"
  },
  {
    "objectID": "10-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "href": "10-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "title": "10  Data visualization with ggplot2",
    "section": "10.6 Combining dplyr and ggplot2",
    "text": "10.6 Combining dplyr and ggplot2\nNote, however, that if you installed and loaded the tidyverse above, then you will already have installed and loaded ggplot2.\nIn the plotting lesson we looked at how to make a multi-panel figure by adding a layer of facet panels using ggplot2. Here is the code we used (with some extra comments):\n\n# Filter countries located in the Americas\namericas <- gapminder[gapminder$continent == \"Americas\", ]\n# Make the plot\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThis code makes the right plot but it also creates an intermediate variable (americas) that we might not have any other uses for. Just as we used |> to pipe data along a chain of dplyr functions we can use it to pass data to ggplot(). Because |> replaces the first argument in a function we don’t need to specify the data = argument in the ggplot() function. By combining dplyr and ggplot2 functions we can make the same figure without creating any new variables or modifying the data.\n\ngapminder |>\n  # Filter countries located in the Americas\n  filter(continent == \"Americas\") |>\n  # Make the plot\n  ggplot(mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nMore examples of using the function mutate() and the ggplot2 package.\n\ngapminder |>\n  # extract first letter of country name into new column\n  mutate(startsWith = substr(country, 1, 1)) |>\n  # only keep countries starting with A or Z\n  filter(startsWith %in% c(\"A\", \"Z\")) |>\n  # plot lifeExp into facets\n  ggplot(aes(x = year, y = lifeExp, colour = continent)) +\n  geom_line() +\n  facet_wrap(vars(country)) +\n  theme_minimal()"
  },
  {
    "objectID": "11-tidyr.html#getting-started",
    "href": "11-tidyr.html#getting-started",
    "title": "11  Reshaping data frames with tidyr",
    "section": "11.1 Getting started",
    "text": "11.1 Getting started\nFirst install the packages if you haven’t already done so (you probably installed dplyr in the previous lesson):\n\n#install.packages(\"tidyverse\")\n\nLoad the packages\n\nlibrary(\"tidyverse\")\n\nFirst, lets look at the structure of our original gapminder data frame:\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nIs gapminder a purely long, purely wide, or some intermediate format?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nThe original gapminder data.frame is in an intermediate format. It is not purely long since it had multiple observation variables (pop,lifeExp,gdpPercap).\n\n\n\n\n\nSometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely ‘long’ and ‘wide’ data formats. We have 3 “ID variables” (continent, country, year) and 3 “Observation variables” (pop,lifeExp,gdpPercap). This intermediate format can be preferred despite not having ALL observations in 1 column given that all 3 observation variables have different units. There are few operations that would need us to make this data frame any longer (i.e. 4 ID variables and 1 Observation variable).\nWhile using many of the functions in R, which are often vector based, you usually do not want to do mathematical operations on values with different units. For example, using the purely long format, a single mean for all of the values of population, life expectancy, and GDP would not be meaningful since it would return the mean of values with 3 incompatible units. The solution is that we first manipulate the data either by grouping (see the lesson on dplyr), or we change the structure of the data frame. Note: Some plotting functions in R actually work better in the wide format data."
  },
  {
    "objectID": "11-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "href": "11-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "title": "11  Reshaping data frames with tidyr",
    "section": "11.2 From wide to long format with pivot_longer()",
    "text": "11.2 From wide to long format with pivot_longer()\nUntil now, we’ve been using the nicely formatted original gapminder dataset, but ‘real’ data (i.e. our own research data) will never be so well organized. Here let’s start with the wide formatted version of the gapminder dataset.\n\nDownload the wide version of the gapminder data from here and save it in your data folder.\n\nWe’ll load the data file and look at it. Note: we don’t want our continent and country columns to be factors, so we use the stringsAsFactors argument for read.csv() to disable that.\n\ngap_wide <- read.csv(\"data/gapminder_wide.csv\", stringsAsFactors = FALSE)\nstr(gap_wide)\n\n'data.frame':   142 obs. of  38 variables:\n $ continent     : chr  \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr  \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num  2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num  3014 3828 960 918 617 ...\n $ gdpPercap_1962: num  2551 4269 949 984 723 ...\n $ gdpPercap_1967: num  3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num  4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num  4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num  5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num  5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num  5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num  4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num  5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num  6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num  43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num  45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num  48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num  51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num  54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num  58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num  61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num  65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num  67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num  69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num  71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num  72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num  9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num  10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num  11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num  12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num  14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num  17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num  20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num  23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num  26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num  29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : int  31287142 10866106 7026113 1630347 12251209 7021078 15929988 4048013 8835739 614382 ...\n $ pop_2007      : int  33333216 12420476 8078314 1639131 14326203 8390505 17696293 4369038 10238807 710960 ...\n\n\n\n\n\nDiagram illustrating the wide format of the gapminder data frame\n\n\nTo change this very wide data frame layout back to our nice, intermediate (or longer) layout, we will use one of the two available pivot functions from the tidyr package. To convert from wide to a longer format, we will use the pivot_longer() function. pivot_longer() makes datasets longer by increasing the number of rows and decreasing the number of columns, or ‘lengthening’ your observation variables into a single variable.\n\n\n\nDiagram illustrating how pivot longer reorganizes a data frame from a wide to long format\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"pop_1952\" \"pop_1957\" \"pop_1962\" \"pop_1967\" ...\n $ obs_values  : num [1:5112] 9279525 10270856 11000948 12760499 14760787 ...\n\n\nHere we have used piping syntax which is similar to what we were doing in the previous lesson with dplyr. In fact, these are compatible and you can use a mix of tidyr and dplyr functions by piping them together.\nWe first provide to pivot_longer() a vector of column names that will be pivoted into longer format. We could type out all the observation variables, but as in the select() function (see dplyr lesson), we can use the starts_with() argument to select all variables that start with the desired character string. pivot_longer() also allows the alternative syntax of using the - symbol to identify which variables are not to be pivoted (i.e. ID variables).\nThe next arguments to pivot_longer() are names_to for naming the column that will contain the new ID variable (obstype_year) and values_to for naming the new amalgamated observation variable (obs_value). We supply these new column names as strings.\n\n\n\nDiagram illustrating the long format of the gapminder data\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(-continent, -country),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values  : num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nThat may seem trivial with this particular data frame, but sometimes you have 1 ID variable and 40 observation variables with irregular variable names. The flexibility is a huge time saver!\nNow obstype_year actually contains 2 pieces of information, the observation type (pop,lifeExp, or gdpPercap) and the year. We can use the separate() function to split the character strings into multiple variables\n\ngap_long <- gap_long %>% separate(obstype_year, into = c('obs_type', 'year'), sep = \"_\")\ngap_long$year <- as.integer(gap_long$year)\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nUsing gap_long, calculate the mean life expectancy, population, and gdpPercap for each continent. *Hint:** use the group_by() and summarize() functions we learned in the dplyr lesson\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\ngap_long %>% group_by(continent, obs_type) %>%\n    summarize(means=mean(obs_values))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 15 × 3\n# Groups:   continent [5]\n   continent obs_type       means\n   <chr>     <chr>          <dbl>\n 1 Africa    gdpPercap     2194. \n 2 Africa    lifeExp         48.9\n 3 Africa    pop        9916003. \n 4 Americas  gdpPercap     7136. \n 5 Americas  lifeExp         64.7\n 6 Americas  pop       24504795. \n 7 Asia      gdpPercap     7902. \n 8 Asia      lifeExp         60.1\n 9 Asia      pop       77038722. \n10 Europe    gdpPercap    14469. \n11 Europe    lifeExp         71.9\n12 Europe    pop       17169765. \n13 Oceania   gdpPercap    18622. \n14 Oceania   lifeExp         74.3\n15 Oceania   pop        8874672."
  },
  {
    "objectID": "11-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "href": "11-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "title": "11  Reshaping data frames with tidyr",
    "section": "11.3 From long to intermediate format with pivot_wider()",
    "text": "11.3 From long to intermediate format with pivot_wider()\nIt is always good to check work. So, let’s use the second pivot function, pivot_wider(), to ‘widen’ our observation variables back out. pivot_wider() is the opposite of pivot_longer(), making a dataset wider by increasing the number of columns and decreasing the number of rows. We can use pivot_wider() to pivot or reshape our gap_long to the original intermediate format or the widest format. Let’s start with the intermediate format.\nThe pivot_wider() function takes names_from and values_from arguments.\nTo names_from we supply the column name whose contents will be pivoted into new output columns in the widened data frame. The corresponding values will be added from the column named in the values_from argument.\n\ngap_normal <- gap_long %>%\n  pivot_wider(names_from = obs_type, values_from = obs_values)\ndim(gap_normal)\n\n[1] 1704    6\n\ndim(gapminder)\n\n[1] 1704    6\n\nnames(gap_normal)\n\n[1] \"continent\" \"country\"   \"year\"      \"gdpPercap\" \"lifeExp\"   \"pop\"      \n\nnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nNow we’ve got an intermediate data frame gap_normal with the same dimensions as the original gapminder, but the order of the variables is different. Let’s fix that before checking if they are all.equal().\n\ngap_normal <- gap_normal[, names(gapminder)]\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n[3] \"Component \\\"country\\\": 1704 string mismatches\"                                         \n[4] \"Component \\\"pop\\\": Mean relative difference: 1.634504\"                                 \n[5] \"Component \\\"continent\\\": 1212 string mismatches\"                                       \n[6] \"Component \\\"lifeExp\\\": Mean relative difference: 0.203822\"                             \n[7] \"Component \\\"gdpPercap\\\": Mean relative difference: 1.162302\"                           \n\nhead(gap_normal)\n\n# A tibble: 6 × 6\n  country  year      pop continent lifeExp gdpPercap\n  <chr>   <int>    <dbl> <chr>       <dbl>     <dbl>\n1 Algeria  1952  9279525 Africa       43.1     2449.\n2 Algeria  1957 10270856 Africa       45.7     3014.\n3 Algeria  1962 11000948 Africa       48.3     2551.\n4 Algeria  1967 12760499 Africa       51.4     3247.\n5 Algeria  1972 14760787 Africa       54.5     4183.\n6 Algeria  1977 17152804 Africa       58.0     4910.\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\nWe’re almost there, the original was sorted by country, then year.\n\ngap_normal <- gap_normal %>% arrange(country, year)\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n\n\nThat’s great! We’ve gone from the longest format back to the intermediate and we didn’t introduce any errors in our code.\nNow let’s convert the long all the way back to the wide. In the wide format, we will keep country and continent as ID variables and pivot the observations across the 3 metrics (pop,lifeExp,gdpPercap) and time (year). First we need to create appropriate labels for all our new variables (time*metric combinations) and we also need to unify our ID variables to simplify the process of defining gap_wide.\n\ngap_temp <- gap_long %>% unite(var_ID, continent, country, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ var_ID    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ obs_type  : chr [1:5112] \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" ...\n $ year      : int [1:5112] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\ngap_temp <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 3] (S3: tbl_df/tbl/data.frame)\n $ ID_var    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ var_names : chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nUsing unite() we now have a single ID variable which is a combination of continent,country,and we have defined variable names. We’re now ready to pipe in pivot_wider()\n\ngap_wide_new <- gap_long %>%\n  unite(ID_var, continent, country, sep = \"_\") %>%\n  unite(var_names, obs_type, year, sep = \"_\") %>%\n  pivot_wider(names_from = var_names, values_from = obs_values)\nstr(gap_wide_new)\n\ntibble [142 × 37] (S3: tbl_df/tbl/data.frame)\n $ ID_var        : chr [1:142] \"Africa_Algeria\" \"Africa_Angola\" \"Africa_Benin\" \"Africa_Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nTake this 1 step further and create a gap_ludicrously_wide format data by pivoting over countries, year and the 3 metrics? Hint this new data frame should only have 5 rows.\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\ngap_ludicrously_wide <- gap_long %>%\n    unite(var_names, obs_type, year, country, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values)\n\n\n\n\n\n\nNow we have a great ‘wide’ format data frame, but the ID_var could be more usable, let’s separate it into 2 variables with separate()\n\ngap_wide_betterID <- separate(gap_wide_new, ID_var, c(\"continent\", \"country\"), sep=\"_\")\ngap_wide_betterID <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values) %>%\n    separate(ID_var, c(\"continent\",\"country\"), sep = \"_\")\nstr(gap_wide_betterID)\n\ntibble [142 × 38] (S3: tbl_df/tbl/data.frame)\n $ continent     : chr [1:142] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr [1:142] \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\nall.equal(gap_wide, gap_wide_betterID)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (1, 3) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\""
  },
  {
    "objectID": "11-tidyr.html#other-great-resources",
    "href": "11-tidyr.html#other-great-resources",
    "title": "11  Reshaping data frames with tidyr",
    "section": "11.4 Other great resources",
    "text": "11.4 Other great resources\n\nR for Data Science\nData Wrangling Cheat sheet\nIntroduction to tidyr\nData wrangling with R and RStudio"
  },
  {
    "objectID": "06-data-frames.html#extracting-columns-from-a-data-frame",
    "href": "06-data-frames.html#extracting-columns-from-a-data-frame",
    "title": "6  Data frames",
    "section": "7.1 Extracting columns from a data frame",
    "text": "7.1 Extracting columns from a data frame\nThere are several ways to extract an individual column in a data frame, including using the $ notation that we used above:\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nBut a column can also be accessed using the square bracket notation:\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nwhich returns the column as a vector.\nThe syntax df[i, j] to extract the entry in the ith row and the jth column from the data frame called df. For example, df[3, 1] will extract the single entry in the third row and first column.\nA blank i or j this tells R to extract all of the rows or columns, respectively. That is, df[, 1] will extract all rows for the 1st column, and df[2, ] will extract the second row across all columns.\n\n7.1.1 The square bracket syntax [ ]\n\ndf[, j] will extract the jth column from the data frame called df as a vector.\ndf[i, ] will extract the ith row from the data frame called df as a data frame.\n\nFor example the following code extracts the data from the second column of cats as a vector\n\ncats[, 2]\n\n[1] 2.1 5.0 3.2\n\n\nand the following code extracts the second row of cats as a data frame:\n\ncats[2, ]\n\n   coat weight likes_string\n2 black      5            0\n\n\nNote, to extract the \\(j\\)th column from a data frame as a single-column data frame, you can use the single-dimension square bracket syntax: df[j].\n\ncats[2]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\nThis syntax also works with named indexing.\n\ncats[\"weight\"]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nThere are several subtly different ways to extract observations and elements from data.frames:\n\ncats[1]\ncats$coat\ncats[\"coat\"]\ncats[1, 1]\ncats[, 1]\ncats[1, ]\n\nTry out these examples and explain what is returned by each one.\nHint: Use the function class() to examine what is returned in each case.\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\n\ncats[1]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nWe can think of a data frame as a list of vectors. The single brace [1] returns the first slice of the list, as another list. In this case it is the first column of the data frame.\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThis example uses the $ character to address items by name. coat is the first column of the data frame, again a vector of type character.\n\ncats[\"coat\"]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nHere we are using a single brace [\"coat\"] replacing the index number with the column name. Like example 1, the returned object is a list.\n\ncats[1, 1]\n\n[1] \"calico\"\n\n\nThis example uses a single brace, but this time we provide row and column coordinates. The returned object is the value in row 1, column 1. The object is a vector of type character.\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nLike the previous example we use single braces and provide row and column coordinates. The row coordinate is not specified, R interprets this missing value as all the elements in this column and returns them as a vector.\n\ncats[1, ]\n\n    coat weight likes_string\n1 calico    2.1            1\n\n\nAgain we use the single brace with row and column coordinates. The column coordinate is not specified. The return value is a list containing all the values in the first row.\n\n\n\n\n\n\n\n\n\n\n\nTip: Renaming data frame columns\n\n\n\nLike vectors, data frames have column names, which can be accessed with the names() function.\n\nnames(cats)\n\n[1] \"coat\"         \"weight\"       \"likes_string\"\n\n\nIf you want to rename the second column of cats, you can assign a new name to the second element of names(cats).\n\nnames(cats)[2] <- \"weight_kg\"\ncats\n\n    coat weight_kg likes_string\n1 calico       2.1            1\n2  black       5.0            0\n3  tabby       3.2            1\n\n\n\n\nLet’s move away from cats to a more interesting data example: gapminder\n\ngapminder <- read.csv(\"data/gapminder_data.csv\")\n\n\n\n\n\n\n\nTip: filter\n\n\n\nIn the dplyr lesson, you will learn another method of filtering to rows of a data frame that satisfy a certain condition using the filter() function from the dplyr package in the tidyverse suite.\n\n\n\n\n7.1.2 Data frame subsetting\n[ with one argument is one way to extract a single column, but the resulting object will be a data frame with one column:\n\nhead(gapminder[3])\n\n       pop\n1  8425333\n2  9240934\n3 10267083\n4 11537966\n5 13079460\n6 14880372\n\n\n[[, however, will act to extract a single column as a vector:\n\nhead(gapminder[[3]])\n\n[1]  8425333  9240934 10267083 11537966 13079460 14880372\n\n\nNotice the difference in the way the two results are presented (the first is a data frame, the second is a vector)\n\nhead(gapminder[[\"lifeExp\"]])\n\n[1] 28.801 30.332 31.997 34.020 36.088 38.438\n\n\nAnd $ provides a convenient shorthand to extract columns by name:\n\nhead(gapminder$year)\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nWith two arguments, [ behaves lets us extract multiple rows and columns:\n\ngapminder[1:3, ]\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nIf we subset a single row, the result will be a data frame (because the elements are mixed types, they can’t be a vector):\n\ngapminder[3, ]\n\n      country year      pop continent lifeExp gdpPercap\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nFor a single column the result will be a vector (this can be changed with the third argument, drop = FALSE).\n\nhead(gapminder[, 2])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nwhich is equivalent to\n\nhead(gapminder[[2]])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nEach of the following pieces of code are incorrect. Identify the error and fix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\ngapminder[gapminder$year = 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\ngapminder[, -1:4]\n\n\nExtract the rows where the life expectancy is longer the 80 years\n\n\ngapminder[gapminder$lifeExp > 80]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\ngapminder[1, 4, 5]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\ngapminder[gapminder$year == 2002 | 2007, ]\n\n\n\n\n\n\n\nSolution to challenge 6\n\n\n\n\n\nFix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\n# gapminder[gapminder$year = 1957, ]\ngapminder[gapminder$year == 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\n# gapminder[, -1:4]\ngapminder[, -c(1:4)]\n\n\nExtract the rows where the life expectancy is longer than 80 years\n\n\n# gapminder[gapminder$lifeExp > 80]\ngapminder[gapminder$lifeExp > 80, ]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\n# gapminder[1, 4, 5]\ngapminder[1, c(4, 5)]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\n# gapminder[gapminder$year == 2002 | 2007, ]\ngapminder[gapminder$year == 2002 | gapminder$year == 2007, ]\n# or\ngapminder[gapminder$year %in% c(2002, 2007), ]\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSelecting elements of a vector that match “any of” a list of components is a very common data analysis task.\nSuppose we want to pull out information from Southeast Asia, which includes the countries of Myanmar, Thailand, Cambodia, Vietnam, and Laos.\nYour task is to subset the data just to the rows that include the countries in Southeast Asia\n\nDefine a logical vector that is TRUE for all of the countries in southeast Asia and FALSE otherwise.\nUse this logical vector to extract just the rows for Southeast Asia from the gapminder dataset.\n\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\n\nse_asia = gapminder$country %in% c(\"Myanmar\", \"Thailand\", \"Cambodia\", \"Vietnam\", \"Laos\")\ngapminder[se_asia, ]\n\n      country year      pop continent lifeExp gdpPercap\n217  Cambodia 1952  4693836      Asia  39.417  368.4693\n218  Cambodia 1957  5322536      Asia  41.366  434.0383\n219  Cambodia 1962  6083619      Asia  43.415  496.9136\n220  Cambodia 1967  6960067      Asia  45.415  523.4323\n221  Cambodia 1972  7450606      Asia  40.317  421.6240\n222  Cambodia 1977  6978607      Asia  31.220  524.9722\n223  Cambodia 1982  7272485      Asia  50.957  624.4755\n224  Cambodia 1987  8371791      Asia  53.914  683.8956\n225  Cambodia 1992 10150094      Asia  55.803  682.3032\n226  Cambodia 1997 11782962      Asia  56.534  734.2852\n227  Cambodia 2002 12926707      Asia  56.752  896.2260\n228  Cambodia 2007 14131858      Asia  59.723 1713.7787\n1045  Myanmar 1952 20092996      Asia  36.319  331.0000\n1046  Myanmar 1957 21731844      Asia  41.905  350.0000\n1047  Myanmar 1962 23634436      Asia  45.108  388.0000\n1048  Myanmar 1967 25870271      Asia  49.379  349.0000\n1049  Myanmar 1972 28466390      Asia  53.070  357.0000\n1050  Myanmar 1977 31528087      Asia  56.059  371.0000\n1051  Myanmar 1982 34680442      Asia  58.056  424.0000\n1052  Myanmar 1987 38028578      Asia  58.339  385.0000\n1053  Myanmar 1992 40546538      Asia  59.320  347.0000\n1054  Myanmar 1997 43247867      Asia  60.328  415.0000\n1055  Myanmar 2002 45598081      Asia  59.908  611.0000\n1056  Myanmar 2007 47761980      Asia  62.069  944.0000\n1525 Thailand 1952 21289402      Asia  50.848  757.7974\n1526 Thailand 1957 25041917      Asia  53.630  793.5774\n1527 Thailand 1962 29263397      Asia  56.061 1002.1992\n1528 Thailand 1967 34024249      Asia  58.285 1295.4607\n1529 Thailand 1972 39276153      Asia  60.405 1524.3589\n1530 Thailand 1977 44148285      Asia  62.494 1961.2246\n1531 Thailand 1982 48827160      Asia  64.597 2393.2198\n1532 Thailand 1987 52910342      Asia  66.084 2982.6538\n1533 Thailand 1992 56667095      Asia  67.298 4616.8965\n1534 Thailand 1997 60216677      Asia  67.521 5852.6255\n1535 Thailand 2002 62806748      Asia  68.564 5913.1875\n1536 Thailand 2007 65068149      Asia  70.616 7458.3963\n1645  Vietnam 1952 26246839      Asia  40.412  605.0665\n1646  Vietnam 1957 28998543      Asia  42.887  676.2854\n1647  Vietnam 1962 33796140      Asia  45.363  772.0492\n1648  Vietnam 1967 39463910      Asia  47.838  637.1233\n1649  Vietnam 1972 44655014      Asia  50.254  699.5016\n1650  Vietnam 1977 50533506      Asia  55.764  713.5371\n1651  Vietnam 1982 56142181      Asia  58.816  707.2358\n1652  Vietnam 1987 62826491      Asia  62.820  820.7994\n1653  Vietnam 1992 69940728      Asia  67.662  989.0231\n1654  Vietnam 1997 76048996      Asia  70.672 1385.8968\n1655  Vietnam 2002 80908147      Asia  73.017 1764.4567\n1656  Vietnam 2007 85262356      Asia  74.249 2441.5764\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 7\n\n\n\n\nWhy does gapminder[1:20] return an error? How does it differ from gapminder[1:20, ]?\nCreate a new data.frame called gapminder_subset that only contains rows 1 through 9 and rows 19 through 23.\n\n\n\n\n\n\n\nSolution to challenge 7\n\n\n\n\n\n\ngapminder[1:20] tries to extract the first 20 columns, but there are not 20 columns. gapminder[1:20, ] subsets the data to give the first 20 rows and all columns.\n\n\n\ngapminder_subset <- gapminder[c(1:9, 19:23), ]"
  },
  {
    "objectID": "11-iteration.html#repeating-operations",
    "href": "11-iteration.html#repeating-operations",
    "title": "11  Iteration with for loops and map functions",
    "section": "11.1 Repeating operations",
    "text": "11.1 Repeating operations\nIf you want to iterate over a set of values, when the order of iteration is important, and perform the same operation on each, one way to do this is using a for() loop.\nIn general, the advice of many R users would be to learn about for() loops, but to avoid using for() loops unless the order of iteration is important: i.e. the calculation at each iteration depends on the results of previous iterations.\nThe basic structure of a for() loop is:\n\nfor (iterator in set of values) {\n  do a thing\n}\n\nFor example:\n\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\n\nx <- c()\nfor (i in 1:10) {\n  x[i] <- exp(i)\n}\nx\n\n [1]     2.718282     7.389056    20.085537    54.598150   148.413159\n [6]   403.428793  1096.633158  2980.957987  8103.083928 22026.465795\n\n\nThe 1:10 bit creates a vector on the fly; you can iterate over any other vector as well.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor loops are common in programming in general, for loops are rarely used in R, primarily due to their computational inefficiency.\nInstead, a much more efficient method for iterating in R is using the map() functions from the purrr R package. To load the purrr R package, you need to run the following code (if the purrr package is not installed, you will need to run the commented install.packages() line)\n\n# install.packages(\"purrr\")\nlibrary(purrr)\n\nThe first argument from the map() function is the object that we want to iterate over. The second argument is the function that we want to apply at each iteration. The output of the map() function is always a list.\nFor example, the following code will apply the exp() function to each entry in the vector 1:10 and return the results in a list:\n\nmap(1:10, exp)\n\n[[1]]\n[1] 2.718282\n\n[[2]]\n[1] 7.389056\n\n[[3]]\n[1] 20.08554\n\n[[4]]\n[1] 54.59815\n\n[[5]]\n[1] 148.4132\n\n[[6]]\n[1] 403.4288\n\n[[7]]\n[1] 1096.633\n\n[[8]]\n[1] 2980.958\n\n[[9]]\n[1] 8103.084\n\n[[10]]\n[1] 22026.47\n\n\nSince lists are unwieldy, there are several versions of the map() function, such as map_dbl() that specifies the type of your output. For instance, if you want your output to be a numeric “double” vector, you can use map_dbl():\n\nmap_dbl(1:10, exp)\n\n [1]     2.718282     7.389056    20.085537    54.598150   148.413159\n [6]   403.428793  1096.633158  2980.957987  8103.083928 22026.465795\n\n\nand if you want it to be a character vector, you can use map_chr():\n\nmap_chr(gapminder, class)\n\n    country        year         pop   continent     lifeExp   gdpPercap \n\"character\"   \"integer\"   \"numeric\" \"character\"   \"numeric\"   \"numeric\" \n\n\nHere, recall that the gapminder data frame is a list, and the map_ function is iterating over the elements of the list, which in this case is the columns.\nNote that the output of the function you are applying must match the map_ function that you use, else you will get an error:\n\nmap_dbl(1:10, class)\n\nError in `map_dbl()`:\nℹ In index: 1.\nCaused by error:\n! Can't coerce from a string to a double vector.\n\n\nThe true power from the map functions really comes once you learn how to write your own functions (see future lesson on functions).\n\n\n\n\n\n\nChallenge 2 (advanced)\n\n\n\nFor each numeric column in the gapminder dataset, print the number of unique entries using the length() and unique() function.\nDo this in two different ways: using a for loop and a map() function.\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nnumeric_columns <- is.numeric(gapminder)\nfor (i in 1:ncol(gapminder)) {\n  print(mean(gapminder[, i]))\n}\n\nWarning in mean.default(gapminder[, i]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n[1] 1979.5\n[1] 29601212\n\n\nWarning in mean.default(gapminder[, i]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n[1] 59.47444\n[1] 7215.327\n\n\n\nmap(gapminder, mean)\n\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n\n\n$country\n[1] NA\n\n$year\n[1] 1979.5\n\n$pop\n[1] 29601212\n\n$continent\n[1] NA\n\n$lifeExp\n[1] 59.47444\n\n$gdpPercap\n[1] 7215.327\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nModify the script from Challenge 3 to loop over each country. This time print out whether the life expectancy is smaller than 50, between 50 and 70, or greater than 70.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nWe modify our solution to Challenge 3 by now adding two thresholds, lowerThreshold and upperThreshold and extending our if-else statements:\n\nlowerThreshold <- 50\nupperThreshold <- 70\nfor (iCountry in unique(gapminder$country)) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if(tmp < lowerThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", lowerThreshold, \"\\n\")\n   } else if(tmp > lowerThreshold && tmp < upperThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is between\", lowerThreshold, \"and\", upperThreshold, \"\\n\")\n   } else {\n       cat(\"Average Life Expectancy in\", iCountry, \"is greater than\", upperThreshold, \"\\n\")\n   }\n   rm(tmp)\n}\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5 - Advanced\n\n\n\nWrite a script that loops over each country in the gapminder dataset, tests whether the country starts with a ‘B’, and graphs life expectancy against time as a line graph if the mean life expectancy is under 50 years.\n\n\n\n\n\n\nSolution for Challenge 5\n\n\n\n\n\nWe will use the grep() command that was introduced in the Unix Shell lesson to find countries that start with “B.” Lets understand how to do this first. Following from the Unix shell section we may be tempted to try the following\n\ngrep(\"^B\", unique(gapminder$country))\n\nBut when we evaluate this command it returns the indices of the factor variable country that start with “B.” To get the values, we must add the value = TRUE option to the grep() command:\n\ngrep(\"^B\", unique(gapminder$country), value = TRUE)\n\nWe will now store these countries in a variable called candidateCountries, and then loop over each entry in the variable. Inside the loop, we evaluate the average life expectancy for each country, and if the average life expectancy is less than 50 we use base-plot to plot the evolution of average life expectancy using with() and subset():\n\nthresholdValue <- 50\ncandidateCountries <- grep(\"^B\", unique(gapminder$country), value = TRUE)\nfor (iCountry in candidateCountries) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if (tmp < thresholdValue) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", thresholdValue, \"plotting life expectancy graph... \\n\")\n       with(subset(gapminder, country == iCountry),\n               plot(year, lifeExp,\n                    type = \"o\",\n                    main = paste(\"Life Expectancy in\", iCountry, \"over time\"),\n                    ylab = \"Life Expectancy\",\n                    xlab = \"Year\"\n                    ) # end plot\n            ) # end with\n   } # end if\n   rm(tmp)\n} # end for loop"
  },
  {
    "objectID": "10-if.html#if-statements",
    "href": "10-if.html#if-statements",
    "title": "10  If statements",
    "section": "10.1 “If” statements",
    "text": "10.1 “If” statements\nThere are several ways you can control flow in R. For conditional statements, the most commonly used approaches are the constructs:\n\n# if\nif (condition is true) {\n  perform action\n}\n\n# if ... else\nif (condition is true) {\n  perform action\n} else {  # that is, if the condition is false,\n  perform alternative action\n}\n\nSay, for example, that we want R to print a message if a variable x has a particular value:\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n}\n\nThe print statement does not appear in the console because x (8) is not greater than 10. To print a different message for numbers less than 10, we can add an else statement.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else {\n  print(\"x is less than 10\")\n}\n\n[1] \"x is less than 10\"\n\n\nYou can also test multiple conditions by using else if.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else if (x > 5) {\n  print(\"x is greater than 5, but less than 10\")\n} else {\n  print(\"x is less than 5\")\n}\n\n[1] \"x is greater than 5, but less than 10\"\n\n\nImportant: when R evaluates the condition inside if() statements, it is looking for a logical value (TRUE or FALSE).\n\n\n\n\n\n\nIf statements in functions\n\n\n\nIf statements might not seem all that useful on their own, but they are incredibly useful for writing functions (as we will learn in the next lesson).\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nUse an if() statement to print a suitable message reporting whether there are any records from 2002 in the gapminder dataset.\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nWe first obtain a logical vector describing which element of gapminder$year is equal to 2002:\n\nif (2002 %in% gapminder$year) {\n  print(\"Record(s) for the year 2002 found.\")\n}\n\n[1] \"Record(s) for the year 2002 found.\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: A common error with if() statements\n\n\n\nA common error with if() statements looks like:\n\n\nError in if (gapminder$year == 2012) {: the condition has length > 1\n\n\nThe if() function only accepts singular (of length 1) inputs, and therefore returns an error when you supply it with a vector.\nThe if() function will still run, but will only evaluate the condition in the first element of the vector.\nTherefore, to use the if() function, you need to make sure your input is a single value (of length 1), rather than a vector."
  },
  {
    "objectID": "13-tidyr.html#getting-started",
    "href": "13-tidyr.html#getting-started",
    "title": "13  Reshaping data frames with tidyr",
    "section": "13.1 Getting started",
    "text": "13.1 Getting started\nFirst install the packages if you haven’t already done so (you probably installed dplyr in the previous lesson):\n\n#install.packages(\"tidyverse\")\n\nLoad the packages\n\nlibrary(\"tidyverse\")\n\nFirst, lets look at the structure of our original gapminder data frame:\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nIs gapminder a purely long, purely wide, or some intermediate format?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nThe original gapminder data.frame is in an intermediate format. It is not purely long since it had multiple observation variables (pop,lifeExp,gdpPercap).\n\n\n\n\n\nSometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely ‘long’ and ‘wide’ data formats. We have 3 “ID variables” (continent, country, year) and 3 “Observation variables” (pop,lifeExp,gdpPercap). This intermediate format can be preferred despite not having ALL observations in 1 column given that all 3 observation variables have different units. There are few operations that would need us to make this data frame any longer (i.e. 4 ID variables and 1 Observation variable).\nWhile using many of the functions in R, which are often vector based, you usually do not want to do mathematical operations on values with different units. For example, using the purely long format, a single mean for all of the values of population, life expectancy, and GDP would not be meaningful since it would return the mean of values with 3 incompatible units. The solution is that we first manipulate the data either by grouping (see the lesson on dplyr), or we change the structure of the data frame. Note: Some plotting functions in R actually work better in the wide format data."
  },
  {
    "objectID": "13-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "href": "13-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "title": "13  Reshaping data frames with tidyr",
    "section": "13.2 From wide to long format with pivot_longer()",
    "text": "13.2 From wide to long format with pivot_longer()\nUntil now, we’ve been using the nicely formatted original gapminder dataset, but ‘real’ data (i.e. our own research data) will never be so well organized. Here let’s start with the wide formatted version of the gapminder dataset.\n\nDownload the wide version of the gapminder data from here and save it in your data folder.\n\nWe’ll load the data file and look at it. Note: we don’t want our continent and country columns to be factors, so we use the stringsAsFactors argument for read.csv() to disable that.\n\ngap_wide <- read.csv(\"data/gapminder_wide.csv\", stringsAsFactors = FALSE)\nstr(gap_wide)\n\n'data.frame':   142 obs. of  38 variables:\n $ continent     : chr  \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr  \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num  2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num  3014 3828 960 918 617 ...\n $ gdpPercap_1962: num  2551 4269 949 984 723 ...\n $ gdpPercap_1967: num  3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num  4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num  4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num  5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num  5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num  5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num  4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num  5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num  6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num  43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num  45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num  48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num  51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num  54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num  58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num  61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num  65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num  67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num  69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num  71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num  72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num  9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num  10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num  11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num  12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num  14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num  17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num  20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num  23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num  26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num  29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : int  31287142 10866106 7026113 1630347 12251209 7021078 15929988 4048013 8835739 614382 ...\n $ pop_2007      : int  33333216 12420476 8078314 1639131 14326203 8390505 17696293 4369038 10238807 710960 ...\n\n\n\n\n\nDiagram illustrating the wide format of the gapminder data frame\n\n\nTo change this very wide data frame layout back to our nice, intermediate (or longer) layout, we will use one of the two available pivot functions from the tidyr package. To convert from wide to a longer format, we will use the pivot_longer() function. pivot_longer() makes datasets longer by increasing the number of rows and decreasing the number of columns, or ‘lengthening’ your observation variables into a single variable.\n\n\n\nDiagram illustrating how pivot longer reorganizes a data frame from a wide to long format\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"pop_1952\" \"pop_1957\" \"pop_1962\" \"pop_1967\" ...\n $ obs_values  : num [1:5112] 9279525 10270856 11000948 12760499 14760787 ...\n\n\nHere we have used piping syntax which is similar to what we were doing in the previous lesson with dplyr. In fact, these are compatible and you can use a mix of tidyr and dplyr functions by piping them together.\nWe first provide to pivot_longer() a vector of column names that will be pivoted into longer format. We could type out all the observation variables, but as in the select() function (see dplyr lesson), we can use the starts_with() argument to select all variables that start with the desired character string. pivot_longer() also allows the alternative syntax of using the - symbol to identify which variables are not to be pivoted (i.e. ID variables).\nThe next arguments to pivot_longer() are names_to for naming the column that will contain the new ID variable (obstype_year) and values_to for naming the new amalgamated observation variable (obs_value). We supply these new column names as strings.\n\n\n\nDiagram illustrating the long format of the gapminder data\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(-continent, -country),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values  : num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nThat may seem trivial with this particular data frame, but sometimes you have 1 ID variable and 40 observation variables with irregular variable names. The flexibility is a huge time saver!\nNow obstype_year actually contains 2 pieces of information, the observation type (pop,lifeExp, or gdpPercap) and the year. We can use the separate() function to split the character strings into multiple variables\n\ngap_long <- gap_long %>% separate(obstype_year, into = c('obs_type', 'year'), sep = \"_\")\ngap_long$year <- as.integer(gap_long$year)\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nUsing gap_long, calculate the mean life expectancy, population, and gdpPercap for each continent. *Hint:** use the group_by() and summarize() functions we learned in the dplyr lesson\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\ngap_long %>% group_by(continent, obs_type) %>%\n    summarize(means=mean(obs_values))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 15 × 3\n# Groups:   continent [5]\n   continent obs_type       means\n   <chr>     <chr>          <dbl>\n 1 Africa    gdpPercap     2194. \n 2 Africa    lifeExp         48.9\n 3 Africa    pop        9916003. \n 4 Americas  gdpPercap     7136. \n 5 Americas  lifeExp         64.7\n 6 Americas  pop       24504795. \n 7 Asia      gdpPercap     7902. \n 8 Asia      lifeExp         60.1\n 9 Asia      pop       77038722. \n10 Europe    gdpPercap    14469. \n11 Europe    lifeExp         71.9\n12 Europe    pop       17169765. \n13 Oceania   gdpPercap    18622. \n14 Oceania   lifeExp         74.3\n15 Oceania   pop        8874672."
  },
  {
    "objectID": "13-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "href": "13-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "title": "13  Reshaping data frames with tidyr",
    "section": "13.3 From long to intermediate format with pivot_wider()",
    "text": "13.3 From long to intermediate format with pivot_wider()\nIt is always good to check work. So, let’s use the second pivot function, pivot_wider(), to ‘widen’ our observation variables back out. pivot_wider() is the opposite of pivot_longer(), making a dataset wider by increasing the number of columns and decreasing the number of rows. We can use pivot_wider() to pivot or reshape our gap_long to the original intermediate format or the widest format. Let’s start with the intermediate format.\nThe pivot_wider() function takes names_from and values_from arguments.\nTo names_from we supply the column name whose contents will be pivoted into new output columns in the widened data frame. The corresponding values will be added from the column named in the values_from argument.\n\ngap_normal <- gap_long %>%\n  pivot_wider(names_from = obs_type, values_from = obs_values)\ndim(gap_normal)\n\n[1] 1704    6\n\ndim(gapminder)\n\n[1] 1704    6\n\nnames(gap_normal)\n\n[1] \"continent\" \"country\"   \"year\"      \"gdpPercap\" \"lifeExp\"   \"pop\"      \n\nnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nNow we’ve got an intermediate data frame gap_normal with the same dimensions as the original gapminder, but the order of the variables is different. Let’s fix that before checking if they are all.equal().\n\ngap_normal <- gap_normal[, names(gapminder)]\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n[3] \"Component \\\"country\\\": 1704 string mismatches\"                                         \n[4] \"Component \\\"pop\\\": Mean relative difference: 1.634504\"                                 \n[5] \"Component \\\"continent\\\": 1212 string mismatches\"                                       \n[6] \"Component \\\"lifeExp\\\": Mean relative difference: 0.203822\"                             \n[7] \"Component \\\"gdpPercap\\\": Mean relative difference: 1.162302\"                           \n\nhead(gap_normal)\n\n# A tibble: 6 × 6\n  country  year      pop continent lifeExp gdpPercap\n  <chr>   <int>    <dbl> <chr>       <dbl>     <dbl>\n1 Algeria  1952  9279525 Africa       43.1     2449.\n2 Algeria  1957 10270856 Africa       45.7     3014.\n3 Algeria  1962 11000948 Africa       48.3     2551.\n4 Algeria  1967 12760499 Africa       51.4     3247.\n5 Algeria  1972 14760787 Africa       54.5     4183.\n6 Algeria  1977 17152804 Africa       58.0     4910.\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\nWe’re almost there, the original was sorted by country, then year.\n\ngap_normal <- gap_normal %>% arrange(country, year)\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n\n\nThat’s great! We’ve gone from the longest format back to the intermediate and we didn’t introduce any errors in our code.\nNow let’s convert the long all the way back to the wide. In the wide format, we will keep country and continent as ID variables and pivot the observations across the 3 metrics (pop,lifeExp,gdpPercap) and time (year). First we need to create appropriate labels for all our new variables (time*metric combinations) and we also need to unify our ID variables to simplify the process of defining gap_wide.\n\ngap_temp <- gap_long %>% unite(var_ID, continent, country, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ var_ID    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ obs_type  : chr [1:5112] \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" ...\n $ year      : int [1:5112] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\ngap_temp <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 3] (S3: tbl_df/tbl/data.frame)\n $ ID_var    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ var_names : chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nUsing unite() we now have a single ID variable which is a combination of continent,country,and we have defined variable names. We’re now ready to pipe in pivot_wider()\n\ngap_wide_new <- gap_long %>%\n  unite(ID_var, continent, country, sep = \"_\") %>%\n  unite(var_names, obs_type, year, sep = \"_\") %>%\n  pivot_wider(names_from = var_names, values_from = obs_values)\nstr(gap_wide_new)\n\ntibble [142 × 37] (S3: tbl_df/tbl/data.frame)\n $ ID_var        : chr [1:142] \"Africa_Algeria\" \"Africa_Angola\" \"Africa_Benin\" \"Africa_Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nTake this 1 step further and create a gap_ludicrously_wide format data by pivoting over countries, year and the 3 metrics? Hint this new data frame should only have 5 rows.\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\ngap_ludicrously_wide <- gap_long %>%\n    unite(var_names, obs_type, year, country, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values)\n\n\n\n\n\n\nNow we have a great ‘wide’ format data frame, but the ID_var could be more usable, let’s separate it into 2 variables with separate()\n\ngap_wide_betterID <- separate(gap_wide_new, ID_var, c(\"continent\", \"country\"), sep=\"_\")\ngap_wide_betterID <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values) %>%\n    separate(ID_var, c(\"continent\",\"country\"), sep = \"_\")\nstr(gap_wide_betterID)\n\ntibble [142 × 38] (S3: tbl_df/tbl/data.frame)\n $ continent     : chr [1:142] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr [1:142] \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\nall.equal(gap_wide, gap_wide_betterID)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (1, 3) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\""
  },
  {
    "objectID": "13-tidyr.html#other-great-resources",
    "href": "13-tidyr.html#other-great-resources",
    "title": "13  Reshaping data frames with tidyr",
    "section": "13.4 Other great resources",
    "text": "13.4 Other great resources\n\nR for Data Science\nData Wrangling Cheat sheet\nIntroduction to tidyr\nData wrangling with R and RStudio"
  },
  {
    "objectID": "12-plot-ggplot2.html#layers",
    "href": "12-plot-ggplot2.html#layers",
    "title": "12  Data visualization with ggplot2",
    "section": "12.1 Layers",
    "text": "12.1 Layers\nUsing a scatterplot probably isn’t the best for visualizing change over time. Instead, let’s tell ggplot to visualize the data as a line plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, color=continent)) +\n  geom_line()\n\n\n\n\nInstead of adding a geom_point layer, we’ve added a geom_line layer.\nHowever, the result doesn’t look quite as we might have expected: it seems to be jumping around a lot in each continent. Let’s try to separate the data by country, plotting one line for each country:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line()\n\n\n\n\nWe’ve added the group aesthetic, which tells ggplot to draw a line for each country.\nBut what if we want to visualize both lines and points on the plot? We can add another layer to the plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line() + geom_point()\n\n\n\n\nIt’s important to note that each layer is drawn on top of the previous layer. In this example, the points have been drawn on top of the lines. Here’s a demonstration:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_line(mapping = aes(color=continent)) + geom_point()\n\n\n\n\nIn this example, the aesthetic mapping of color has been moved from the global plot options in ggplot to the geom_line layer so it no longer applies to the points. Now we can clearly see that the points are drawn on top of the lines.\n\n\n\n\n\n\nTip: Setting an aesthetic to a value instead of a mapping\n\n\n\nSo far, we’ve seen how to use an aesthetic (such as color) as a mapping to a variable in the data. For example, when we use geom_line(mapping = aes(color=continent)), ggplot will give a different color to each continent. But what if we want to change the color of all lines to blue? You may think that geom_line(mapping = aes(color=\"blue\")) should work, but it doesn’t. Since we don’t want to create a mapping to a specific variable, we can move the color specification outside of the aes() function, like this: geom_line(color=\"blue\").\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSwitch the order of the point and line layers from the previous example. What happened?\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nThe lines now get drawn over the points!\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_point() + geom_line(mapping = aes(color=continent))\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The plot illustrates the possibilities for styling visualisations in ggplot2 with data points enlarged, coloured orange, and displayed without transparency."
  },
  {
    "objectID": "12-plot-ggplot2.html#transformations-and-statistics",
    "href": "12-plot-ggplot2.html#transformations-and-statistics",
    "title": "12  Data visualization with ggplot2",
    "section": "12.2 Transformations and statistics",
    "text": "12.2 Transformations and statistics\nggplot2 also makes it easy to overlay statistical models over the data. To demonstrate we’ll go back to our first example:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nCurrently it’s hard to see the relationship between the points due to some strong outliers in GDP per capita. We can change the scale of units on the x axis using the scale functions. These control the mapping between the data values and visual values of an aesthetic. We can also modify the transparency of the points, using the alpha function, which is especially helpful when you have a large amount of data which is very clustered.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10()\n\n\n\n\nScatterplot of GDP vs life expectancy showing logarithmic x-axis data spread\n\n\n\n\nThe scale_x_log10 function applied a transformation to the coordinate system of the plot, so that each multiple of 10 is evenly spaced from left to right. For example, a GDP per capita of 1,000 is the same horizontal distance away from a value of 10,000 as the 10,000 value is from 100,000. This helps to visualize the spread of the data along the x-axis.\n\n\n\n\n\n\nTip Reminder: Setting an aesthetic to a value instead of a mapping\n\n\n\nNotice that we used geom_point(alpha = 0.5). As the previous tip mentioned, using a setting outside of the aes() function will cause this value to be used for all points, which is what we want in this case. But just like any other aesthetic setting, alpha can also be mapped to a variable in the data. For example, we can give a different transparency to each continent with geom_point(mapping = aes(alpha = continent)).\n\n\nWe can fit a simple relationship to the data by adding another layer, geom_smooth:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a blue trend line summarising the relationship between variables, and gray shaded area indicating 95% confidence intervals for that trend line.\n\n\n\n\nWe can make the line thicker by setting the size aesthetic in the geom_smooth layer:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\", size=1.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The blue trend line is slightly thicker than in the previous figure.\n\n\n\n\nThere are two ways an aesthetic can be specified. Here we set the size aesthetic by passing it as an argument to geom_smooth. Previously in the lesson we’ve used the aes function to define a mapping between data variables and their visual representation.\n\n\n\n\n\n\nChallenge 4a\n\n\n\nModify the color and size of the points on the point layer in the previous example. Hint: do not use the aes function.\n\n\n\n\n\n\nSolution to challenge 4a\n\n\n\n\n\nHere a possible solution:\nNotice that the color argument is supplied outside of the aes() function. This means that it applies to all data points on the graph and is not related to a specific variable.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\ngeom_point(size = 3, color = \"orange\") + scale_x_log10() +\ngeom_smooth(method = \"lm\", size = 1.5)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4b\n\n\n\nModify your solution to Challenge 4a so that the points are now a different shape and are colored by continent with new trendlines. Hint: The color argument can be used inside the aesthetic.\n\n\n\n\n\n\nSolution to challenge 4b\n\n\n\n\n\nHere is a possible solution:\nNotice that supplying the color argument inside the aes() functions enables you to connect it to a certain variable. The shape argument, as you can see, modifies all data points the same way (it is outside the aes() call) while the color argument which is placed inside the aes() call modifies a point’s color based on its continent value.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\ngeom_point(size=3, shape=17) + scale_x_log10() +\ngeom_smooth(method=\"lm\", size=1.5)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "12-plot-ggplot2.html#multi-panel-figures",
    "href": "12-plot-ggplot2.html#multi-panel-figures",
    "title": "12  Data visualization with ggplot2",
    "section": "12.3 Multi-panel figures",
    "text": "12.3 Multi-panel figures\nEarlier we visualized the change in life expectancy over time across all countries in one plot. Alternatively, we can split this out over multiple panels by adding a layer of facet panels.\n\n\n\n\n\n\nTip\n\n\n\nWe start by making a subset of data including only countries located in the Americas. This includes 25 countries, which will begin to clutter the figure. Note that we apply a “theme” definition to rotate the x-axis labels to maintain readability. Nearly everything in ggplot2 is customizable.\n\n\n\namericas <- gapminder[gapminder$continent == \"Americas\",]\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThe facet_wrap layer took a “formula” as its argument, denoted by the tilde (~). This tells R to draw a panel for each unique value in the country column of the gapminder dataset."
  },
  {
    "objectID": "12-plot-ggplot2.html#modifying-text",
    "href": "12-plot-ggplot2.html#modifying-text",
    "title": "12  Data visualization with ggplot2",
    "section": "12.4 Modifying text",
    "text": "12.4 Modifying text\nTo clean this figure up for a publication we need to change some of the text elements. The x-axis is too cluttered, and the y axis should read “Life expectancy”, rather than the column name in the data frame.\nWe can do this by adding a couple of different layers. The theme layer controls the axis text, and overall text size. Labels for the axes, plot title and any legend can be set using the labs function. Legend titles are set using the same names we used in the aes specification. Thus below the color legend title is set using color = \"Continent\", while the title of a fill legend would be set using fill = \"MyTitle\".\n\nggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))"
  },
  {
    "objectID": "12-plot-ggplot2.html#exporting-the-plot",
    "href": "12-plot-ggplot2.html#exporting-the-plot",
    "title": "12  Data visualization with ggplot2",
    "section": "12.5 Exporting the plot",
    "text": "12.5 Exporting the plot\nThe ggsave() function allows you to export a plot created with ggplot. You can specify the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi) to create high quality graphics for publication. In order to save the plot from above, we first assign it to a variable lifeExp_plot, then tell ggsave to save that plot in png format to a directory called results. (Make sure you have a results/ folder in your working directory.)\n\n\n\n\nlifeExp_plot <- ggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\nggsave(filename = \"results/lifeExp.png\", plot = lifeExp_plot, width = 12, height = 10, dpi = 300, units = \"cm\")\n\nThere are two nice things about ggsave. First, it defaults to the last plot, so if you omit the plot argument it will automatically save the last plot you created with ggplot. Secondly, it tries to determine the format you want to save your plot in from the file extension you provide for the filename (for example .png or .pdf). If you need to, you can specify the format explicitly in the device argument.\nThis is a taste of what you can do with ggplot2. RStudio provides a really useful cheat sheet of the different layers available, and more extensive documentation is available on the ggplot2 website. Finally, if you have no idea how to change something, a quick Google search will usually send you to a relevant question and answer on Stack Overflow with reusable code to modify!\n\n\n\n\n\n\nChallenge 5\n\n\n\nGenerate boxplots to compare life expectancy between the different continents during the available years.\nAdvanced:\n\nRename y axis as Life Expectancy.\nRemove x axis labels.\n\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nHere a possible solution:\nxlab() and ylab() set labels for the x and y axes, respectively The axis title, text and ticks are attributes of the theme and must be modified within a theme() call.\n\nggplot(data = gapminder, mapping = aes(x = continent, y = lifeExp, fill = continent)) +\ngeom_boxplot() + facet_wrap(~year) +\nylab(\"Life Expectancy\") +\ntheme(axis.title.x=element_blank(),\n      axis.text.x = element_blank(),\n      axis.ticks.x = element_blank())"
  },
  {
    "objectID": "12-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "href": "12-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "title": "12  Data visualization with ggplot2",
    "section": "12.6 Combining dplyr and ggplot2",
    "text": "12.6 Combining dplyr and ggplot2\nNote, however, that if you installed and loaded the tidyverse above, then you will already have installed and loaded ggplot2.\nIn the plotting lesson we looked at how to make a multi-panel figure by adding a layer of facet panels using ggplot2. Here is the code we used (with some extra comments):\n\n# Filter countries located in the Americas\namericas <- gapminder[gapminder$continent == \"Americas\", ]\n# Make the plot\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThis code makes the right plot but it also creates an intermediate variable (americas) that we might not have any other uses for. Just as we used |> to pipe data along a chain of dplyr functions we can use it to pass data to ggplot(). Because |> replaces the first argument in a function we don’t need to specify the data = argument in the ggplot() function. By combining dplyr and ggplot2 functions we can make the same figure without creating any new variables or modifying the data.\n\ngapminder |>\n  # Filter countries located in the Americas\n  filter(continent == \"Americas\") |>\n  # Make the plot\n  ggplot(mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nMore examples of using the function mutate() and the ggplot2 package.\n\ngapminder |>\n  # extract first letter of country name into new column\n  mutate(startsWith = substr(country, 1, 1)) |>\n  # only keep countries starting with A or Z\n  filter(startsWith %in% c(\"A\", \"Z\")) |>\n  # plot lifeExp into facets\n  ggplot(aes(x = year, y = lifeExp, colour = continent)) +\n  geom_line() +\n  facet_wrap(vars(country)) +\n  theme_minimal()"
  },
  {
    "objectID": "08-lists.html#lists",
    "href": "08-lists.html#lists",
    "title": "8  Lists",
    "section": "8.1 Lists",
    "text": "8.1 Lists\nAnother data structure is the list.\nList are very flexible because you can put anything you want in it: unlike a vector, the elements of a list can have different data types. For example:\n\nlist_example <- list(1, \"a\", TRUE)\nlist_example\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n\nLike a vector, the “length” of a list corresponds to how many entries it contains:\n\nlength(list_example)\n\n[1] 3\n\n\nWhen printing the object structure with str(), we see the data types of all elements:\n\nstr(list_example)\n\nList of 3\n $ : num 1\n $ : chr \"a\"\n $ : logi TRUE\n\n\nTo retrieve one of the elements of a list, we use the double bracket notation:\n\nlist_example[[2]]\n\n[1] \"a\"\n\n\nThe elements of lists also can have names, they can be given by prepending them to the values, separated by an equals sign:\n\nanother_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE)\nanother_list\n\n$title\n[1] \"Numbers\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n[1] TRUE\n\n\nThis results in a named list. Now we have a new function of our object! We can access single elements by an additional way!\n\nanother_list$title\n\n[1] \"Numbers\"\n\n\nas well as using named indexing in the double square bracket notation.\n\nanother_list[[\"title\"]]\n\n[1] \"Numbers\"\n\n\nLists, it turns out, can become a lot more complicated than vectors. While each entry of a vector is just a single value, each entry of a list can be any type of object, including vectors and data frames. For example, the following list of length three contains three entries: a numeric vector, a data frame, and a single character value:\n\ncomplicated_list <- list(vec = c(1, 2, 9),\n                         dataframe = cats, \n                         single_value = \"a\")\ncomplicated_list\n\n$vec\n[1] 1 2 9\n\n$dataframe\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n$single_value\n[1] \"a\"\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nCreate a list of length two containing a character vector containing the letters “x”, “y”, “z” and a data frame with two columns that looks like this.\n\n\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\nYour list output should look like this:\n\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\nSolution to Challenge 6\n\n\n\n\n\n\nlist(c(\"x\", \"y\", \"z\"),\n     data.frame(name = c(\"Henry\", \"Hannah\", \"Harvey\"), grade = c(\"A\", \"B\", \"C\")))\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\n8.1.1 Data frames as a special case of a list\nIt turns out that a data frame is a special kind of a list. Specifically, a data frame is a list of vectors of the same length.\nThis is why you can extract vector columns from a data frame using the double brackets notation:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\n\ncats[[\"coat\"]]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nNote that the df[i, j] index notation is specific to data frames (and does not work for lists).\nYou will learn more about extracting information from vectors, lists and data frames in the advanced subsetting lesson.\n\n\n8.1.2 List subsetting\nNow we’ll introduce some new subsetting operators. There are three functions used to subset lists. We’ve already seen these when learning about atomic vectors and matrices: [, [[, and $.\nUsing [ will always return a list. If you want to subset a list, but not extract an element, then you will likely use [.\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist[1]\n\n$a\n[1] \"Software Carpentry\"\n\n\nThis returns a list with one element.\nWe can subset elements of a list exactly the same way as atomic vectors using [. Comparison operations however won’t work as they’re not recursive, they will try to condition on the data structures in each element of the list, not the individual elements within those data structures.\n\nxlist[1:2]\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nTo extract individual elements of a list, you need to use the double-square bracket function: [[.\n\nxlist[[1]]\n\n[1] \"Software Carpentry\"\n\n\nNotice that now the result is a vector, not a list.\nYou can’t extract more than one element at once:\n\nxlist[[1:2]]\n\nError in xlist[[1:2]]: subscript out of bounds\n\n\nNor use it to skip elements:\n\nxlist[[-1]]\n\nError in xlist[[-1]]: invalid negative subscript in get1index <real>\n\n\nBut you can use names to both subset and extract elements:\n\nxlist[[\"a\"]]\n\n[1] \"Software Carpentry\"\n\n\nThe $ function is a shorthand way for extracting elements by name:\n\nxlist$data\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nGiven the following list:\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nUsing list and vector subsetting, extract the second entry in the second element of the list (i.e., extract the number 2 from the b entry from xlist`). There are several ways to do this. Compare your answer with your neighbor. Did you do it the same way?\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\n\nxlist$b[2]\n\n[1] 2\n\n\n\nxlist[[2]][2]\n\n[1] 2\n\n\n\nxlist[[\"b\"]][2]\n\n[1] 2"
  },
  {
    "objectID": "04-vectors_types.html#subsetting-vectors",
    "href": "04-vectors_types.html#subsetting-vectors",
    "title": "4  Vectors and types",
    "section": "4.5 Subsetting vectors",
    "text": "4.5 Subsetting vectors\nWe can extract individual elements of a vector by using the square bracket notation:\n\nfirst_element <- sequence_example[1]\nfirst_element\n\n[1] 20\n\n\nTo change a single element, use the bracket on the other side of the arrow:\n\nsequence_example[1] <- 30\nsequence_example\n\n[1] 30 21 22 23 24 25\n\n\nLet’s define a new vector, x:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nx\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nSo now that we’ve created a toy vector to play with, how do we get at its contents?\n\n4.5.1 Accessing elements using their indices\nTo extract elements of a vector we can give their corresponding index, starting from one:\n\nx[1]\n\n  a \n5.4 \n\n\n\nx[4]\n\n  d \n4.8 \n\n\nThe square brackets operator is a function. For vectors, it means “get me the nth element”.\nWe can ask for multiple elements at once by providing a vector if indices:\n\nx[c(1, 3)]\n\n  a   c \n5.4 7.1 \n\n\nOr “slices” of the vector using a sequential integer vector index:\n\nx[1:4]\n\n  a   b   c   d \n5.4 6.2 7.1 4.8 \n\n\nRecall that the : operator creates a sequence of numbers from the left element to the right.\n\n1:4\n\n[1] 1 2 3 4\n\nc(1, 2, 3, 4)\n\n[1] 1 2 3 4\n\n\nWe can ask for the same element multiple times:\n\nx[c(1,1,3)]\n\n  a   a   c \n5.4 5.4 7.1 \n\n\nIf we ask for an index beyond the length of the vector, R will return a missing value:\n\nx[6]\n\n<NA> \n  NA \n\n\nThis is a vector of length one containing an NA, whose name is also NA.\nIf we ask for the 0th element, we get an empty vector:\n\nx[0]\n\nnamed numeric(0)\n\n\n\n\n\n\n\n\nVector numbering in R starts at 1\n\n\n\nIn many programming languages (C and Python, for example), the first element of a vector has an index of 0. In R, the first element is 1.\n\n\n\n\n4.5.2 Skipping and removing elements\nIf we use a negative number as the index of a vector, R will return every element except for the one specified:\n\nx[-2]\n\n  a   c   d   e \n5.4 7.1 4.8 7.5 \n\n\nWe can skip multiple elements:\n\nx[c(-1, -5)]  # or x[-c(1,5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\n\n\n\n\n\nOrder of operations\n\n\n\nA common trip up for novices occurs when trying to skip slices of a vector. It’s natural to try to negate a sequence like so:\n\nx[-1:3]\n\nThis gives a somewhat cryptic error:\n\n\nError in x[-1:3]: only 0's may be mixed with negative subscripts\n\n\nBut remember the order of operations. : is really a function. It takes its first argument as -1, and its second as 3, so generates the sequence of numbers: c(-1, 0, 1, 2, 3). The correct solution is to wrap that function call in brackets, so that the - operator applies to the result:\n\nx[-(1:3)]\n\n  d   e \n4.8 7.5 \n\n\n\n\nTo remove elements from a vector, we need to re-assign the variable to our result:\n\nx <- x[-4]\nx\n\n  a   b   c   e \n5.4 6.2 7.1 7.5 \n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nprint(x)\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nCome up with at least 2 different commands that will produce the following output:\n\n\n  b   c   d \n6.2 7.1 4.8 \n\n\nAfter you find 2 different commands, compare notes with your neighbour. Did you have different strategies?\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\n\nx[2:4]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[-c(1, 5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(2, 3, 4)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(\"b\", \"c\", \"d\")]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nStart by making a vector with the numbers 5 through 26. Then:\n\nPrint out the first three entries of the vector\nPrint out the fourth entry of the vector\nMultiply the vector by 2.\n\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nx <- 5:26\nhead(x, 3)\n\n[1] 5 6 7\n\nx[4]\n\n[1] 8\n\nx * 2\n\n [1] 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52"
  },
  {
    "objectID": "05-vectorization.html#subsetting-vectors-using-logical-operations",
    "href": "05-vectorization.html#subsetting-vectors-using-logical-operations",
    "title": "5  Vectorization",
    "section": "5.2 Subsetting vectors using logical operations ",
    "text": "5.2 Subsetting vectors using logical operations \nWe can also use any logical vector to subset:\n\nx[c(FALSE, FALSE, TRUE, FALSE, TRUE)]\n\n[1]  3 NA\n\n\nSince comparison operators (e.g. >, <, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one.\n\nx[x > 7]\n\nnumeric(0)\n\n\nBreaking it down, this statement first evaluates x>7, generating a logical vector c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x corresponding to the TRUE values.\nWe can use == to mimic the previous method of indexing by name (remember you have to use == rather than = for comparisons):\n\nnames(x) == \"a\"\n\nlogical(0)\n\nx[names(x) == \"a\"]\n\nnumeric(0)"
  },
  {
    "objectID": "05-subsetting-vectors.html",
    "href": "05-subsetting-vectors.html",
    "title": "5  Subsetting vectors",
    "section": "",
    "text": "6 Names\nWith names, we can give meaning to elements. It is the first time that we do not only have the data, but also explaining information. It is metadata that can be stuck to the object like a label. In R, this is called an attribute. Some attributes enable us to do more with our object, for example, like here, accessing an element by a self-defined name."
  },
  {
    "objectID": "05-subsetting-vectors.html#subsetting-vectors",
    "href": "05-subsetting-vectors.html#subsetting-vectors",
    "title": "5  Subsetting vectors",
    "section": "5.1 Subsetting vectors",
    "text": "5.1 Subsetting vectors\nWe can extract individual elements of a vector by using the square bracket notation:\n\nsequence_example <- 20:25\nfirst_element <- sequence_example[1]\nfirst_element\n\n[1] 20\n\n\nTo change a single element, use the bracket on the other side of the arrow:\n\nsequence_example[1] <- 30\nsequence_example\n\n[1] 30 21 22 23 24 25\n\n\nLet’s define a new vector, x:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nx\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nSo now that we’ve created a toy vector to play with, how do we get at its contents?\n\n5.1.1 Accessing elements using their indices\nTo extract elements of a vector we can give their corresponding index, starting from one:\n\nx[1]\n\n  a \n5.4 \n\n\n\nx[4]\n\n  d \n4.8 \n\n\nThe square brackets operator is a function. For vectors, it means “get me the nth element”.\nWe can ask for multiple elements at once by providing a vector if indices:\n\nx[c(1, 3)]\n\n  a   c \n5.4 7.1 \n\n\nOr “slices” of the vector using a sequential integer vector index:\n\nx[1:4]\n\n  a   b   c   d \n5.4 6.2 7.1 4.8 \n\n\nRecall that the : operator creates a sequence of numbers from the left element to the right.\n\n1:4\n\n[1] 1 2 3 4\n\nc(1, 2, 3, 4)\n\n[1] 1 2 3 4\n\n\nWe can ask for the same element multiple times:\n\nx[c(1,1,3)]\n\n  a   a   c \n5.4 5.4 7.1 \n\n\nIf we ask for an index beyond the length of the vector, R will return a missing value:\n\nx[6]\n\n<NA> \n  NA \n\n\nThis is a vector of length one containing an NA, whose name is also NA.\nIf we ask for the 0th element, we get an empty vector:\n\nx[0]\n\nnamed numeric(0)\n\n\n\n\n\n\n\n\nVector numbering in R starts at 1\n\n\n\nIn many programming languages (C and Python, for example), the first element of a vector has an index of 0. In R, the first element is 1.\n\n\n\n\n5.1.2 Skipping and removing elements\nIf we use a negative number as the index of a vector, R will return every element except for the one specified:\n\nx[-2]\n\n  a   c   d   e \n5.4 7.1 4.8 7.5 \n\n\nWe can skip multiple elements:\n\nx[c(-1, -5)]  # or x[-c(1,5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\n\n\n\n\n\nOrder of operations\n\n\n\nA common trip up for novices occurs when trying to skip slices of a vector. It’s natural to try to negate a sequence like so:\n\nx[-1:3]\n\nThis gives a somewhat cryptic error:\n\n\nError in x[-1:3]: only 0's may be mixed with negative subscripts\n\n\nBut remember the order of operations. : is really a function. It takes its first argument as -1, and its second as 3, so generates the sequence of numbers: c(-1, 0, 1, 2, 3). The correct solution is to wrap that function call in brackets, so that the - operator applies to the result:\n\nx[-(1:3)]\n\n  d   e \n4.8 7.5 \n\n\n\n\nTo remove elements from a vector, we need to re-assign the variable to our result:\n\nx <- x[-4]\nx\n\n  a   b   c   e \n5.4 6.2 7.1 7.5 \n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nprint(x)\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nCome up with at least 2 different commands that will produce the following output:\n\n\n  b   c   d \n6.2 7.1 4.8 \n\n\nAfter you find 2 different commands, compare notes with your neighbour. Did you have different strategies?\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\n\nx[2:4]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[-c(1, 5)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(2, 3, 4)]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\nx[c(\"b\", \"c\", \"d\")]\n\n  b   c   d \n6.2 7.1 4.8 \n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nStart by making a vector with the numbers 5 through 26. Then:\n\nPrint out the first three entries of the vector\nPrint out the fourth entry of the vector\nMultiply the vector by 2.\n\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nx <- 5:26\nhead(x, 3)\n\n[1] 5 6 7\n\nx[4]\n\n[1] 8\n\nx * 2\n\n [1] 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52"
  },
  {
    "objectID": "05-subsetting-vectors.html#accessing-vectors-by-name",
    "href": "05-subsetting-vectors.html#accessing-vectors-by-name",
    "title": "5  Subsetting vectors",
    "section": "6.1 Accessing vectors by name",
    "text": "6.1 Accessing vectors by name\nEach element of a vector can be given a name:\n\npizza_price <- c(pizzasubito = 5.64, pizzafresh = 6.60, callapizza = 4.50)\n\nTo retrieve a specific named entry from a vector, we can use the square bracket notation:\n\npizza_price[\"pizzasubito\"]\n\npizzasubito \n       5.64 \n\n\nwhich is equivalent to extracting the first entry of the vector:\n\npizza_price[1]\n\npizzasubito \n       5.64 \n\n\nIf you want to extract just the names of an object, use the names() function:\n\nnames(pizza_price)\n\n[1] \"pizzasubito\" \"pizzafresh\"  \"callapizza\" \n\n\nWe have seen how to access and change single elements of a vector. The same is possible for names:\n\nnames(pizza_price)[3]\n\n[1] \"callapizza\"\n\nnames(pizza_price)[3] <- \"call-a-pizza\"\npizza_price\n\n pizzasubito   pizzafresh call-a-pizza \n        5.64         6.60         4.50 \n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nDefine the following vector, y, and extract the “a” and “c” entries:\n\n\n\n\ny\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\ny <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we can name a vector 'on the fly'\ny[c(\"a\", \"c\")]\n\n  a   c \n5.4 7.1 \n\n\nThis is usually a much more reliable way to subset objects: the position of various elements can often change when chaining together subsetting operations, but the names will always remain the same!\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nWhat is the data type of the names of pizza_price? You can find out using the str() or class() functions.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nYou get the names of an object by wrapping the object name inside names(...). Similarly, you get the data type of the names by again wrapping the whole code in class(...):\n\nclass(names(pizza_price))\n\n[1] \"character\"\n\n\nalternatively, use a new variable if this is easier for you to read:\n\nnames <- names(pizza_price)\nclass(names)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nInstead of just changing the names of each element of a vector individually, you can also set all names of an object by writing code like (replace ALL CAPS text):\n\nnames( OBJECT ) <-  CHARACTER_VECTOR\n\nCreate a vector that gives the number for each letter in the alphabet!\n\nGenerate a vector called letter_no with the sequence of numbers from 1 to 26\nR has a built-in object called LETTERS (type LETTERS in the console. It is a 26-character vector of uppercase letters from A to Z. Set the names of letter_no to these 26 letters\nTest yourself by calling letter_no[\"B\"], which should give you the number 2!\n\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\n\nletter_no <- 1:26   # or seq(1,26)\nnames(letter_no) <- LETTERS\nletter_no[\"B\"]\n\nB \n2 \n\n\n\n\n\n\n\n\n6.1.0.1 Removing named elements\nRemoving named elements is a little harder. If we try to remove one named element by negating the string, R complains (slightly obscurely) that it doesn’t know how to take the negative of a string:\n\nx <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we start again by naming a vector 'on the fly'\nx[-\"a\"]\n\nError in -\"a\": invalid argument to unary operator\n\n\nHowever, we can use the != (not-equals) operator to construct a logical vector that will do what we want:\n\nx[names(x) != \"a\"]\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nSkipping multiple named indices is a little bit harder still. Suppose we want to drop the \"a\" and \"c\" elements, so we try this:\n\nx[names(x) != c(\"a\", \"c\")]\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nR did something, but it gave us a warning that we ought to pay attention to - and it apparently gave us the wrong answer (the \"c\" element is still included in the vector)!\nSo what does != actually do in this case? That’s an excellent question.\n\n\n6.1.1 Recycling\nLet’s take a look at the comparison component of this code:\n\nnames(x) != c(\"a\", \"c\")\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nWhy does R give TRUE as the third element of this vector, when names(x)[3] != \"c\" is obviously false? When you use !=, R tries to compare each element of the left argument with the corresponding element of its right argument. What happens when you compare vectors of different lengths?\n\n\n\nInequality testing\n\n\nWhen one vector is shorter than the other, it gets recycled:\n\n\n\nInequality testing: results of recycling\n\n\nIn this case R repeats c(\"a\", \"c\") as many times as necessary to match names(x), i.e. we get c(\"a\",\"c\",\"a\",\"c\",\"a\"). Since the recycled \"a\" doesn’t match the third element of names(x), the value of != is TRUE. Because in this case the longer vector length (5) isn’t a multiple of the shorter vector length (2), R printed a warning message. If we had been unlucky and names(x) had contained six elements, R would silently have done the wrong thing (i.e., not what we intended it to do). This recycling rule can can introduce hard-to-find and subtle bugs!\nThe way to get R to do what we really want (match each element of the left argument with all of the elements of the right argument) it to use the %in% operator. The %in% operator goes through each element of its left argument, in this case the names of x, and asks, “Does this element occur in the second argument?”. Here, since we want to exclude values, we also need a ! operator to change “in” to “not in”:\n\nx[!(names(x) %in% c(\"a\", \"c\"))]\n\n  b   d   e \n6.2 4.8 7.5"
  },
  {
    "objectID": "05-subsetting-vectors.html#names",
    "href": "05-subsetting-vectors.html#names",
    "title": "5  Subsetting vectors",
    "section": "5.2 Names",
    "text": "5.2 Names\nWith names, we can give meaning to elements. It is the first time that we do not only have the data, but also explaining information. It is metadata that can be stuck to the object like a label. In R, this is called an attribute. Some attributes enable us to do more with our object, for example, like here, accessing an element by a self-defined name.\n\n5.2.1 Accessing vectors by name\nEach element of a vector can be given a name:\n\npizza_price <- c(pizzasubito = 5.64, pizzafresh = 6.60, callapizza = 4.50)\n\nTo retrieve a specific named entry from a vector, we can use the square bracket notation:\n\npizza_price[\"pizzasubito\"]\n\npizzasubito \n       5.64 \n\n\nwhich is equivalent to extracting the first entry of the vector:\n\npizza_price[1]\n\npizzasubito \n       5.64 \n\n\nIf you want to extract just the names of an object, use the names() function:\n\nnames(pizza_price)\n\n[1] \"pizzasubito\" \"pizzafresh\"  \"callapizza\" \n\n\nWe have seen how to access and change single elements of a vector. The same is possible for names:\n\nnames(pizza_price)[3]\n\n[1] \"callapizza\"\n\nnames(pizza_price)[3] <- \"call-a-pizza\"\npizza_price\n\n pizzasubito   pizzafresh call-a-pizza \n        5.64         6.60         4.50 \n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nDefine the following vector, y, and extract the “a” and “c” entries:\n\n\n\n\ny\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\ny <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we can name a vector 'on the fly'\ny[c(\"a\", \"c\")]\n\n  a   c \n5.4 7.1 \n\n\nThis is usually a much more reliable way to subset objects: the position of various elements can often change when chaining together subsetting operations, but the names will always remain the same!\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nWhat is the data type of the names of pizza_price? You can find out using the str() or class() functions.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nYou get the names of an object by wrapping the object name inside names(...). Similarly, you get the data type of the names by again wrapping the whole code in class(...):\n\nclass(names(pizza_price))\n\n[1] \"character\"\n\n\nalternatively, use a new variable if this is easier for you to read:\n\nnames <- names(pizza_price)\nclass(names)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nInstead of just changing the names of each element of a vector individually, you can also set all names of an object by writing code like (replace ALL CAPS text):\n\nnames( OBJECT ) <-  CHARACTER_VECTOR\n\nCreate a vector that gives the number for each letter in the alphabet!\n\nGenerate a vector called letter_no with the sequence of numbers from 1 to 26\nR has a built-in object called LETTERS (type LETTERS in the console. It is a 26-character vector of uppercase letters from A to Z. Set the names of letter_no to these 26 letters\nTest yourself by calling letter_no[\"B\"], which should give you the number 2!\n\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\n\nletter_no <- 1:26   # or seq(1,26)\nnames(letter_no) <- LETTERS\nletter_no[\"B\"]\n\nB \n2 \n\n\n\n\n\n\n\n\n\n5.2.2 Removing named elements\nRemoving named elements is a little harder. If we try to remove one named element by negating the string, R complains (slightly obscurely) that it doesn’t know how to take the negative of a string:\n\nx <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we start again by naming a vector 'on the fly'\nx[-\"a\"]\n\nError in -\"a\": invalid argument to unary operator\n\n\nHowever, we can use the != (not-equals) operator to construct a logical vector that will do what we want:\n\nx[names(x) != \"a\"]\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nSkipping multiple named indices is a little bit harder still. Suppose we want to drop the \"a\" and \"c\" elements, so we try this:\n\nx[names(x) != c(\"a\", \"c\")]\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nR did something, but it gave us a warning that we ought to pay attention to - and it apparently gave us the wrong answer (the \"c\" element is still included in the vector)!\nSo what does != actually do in this case? That’s an excellent question."
  },
  {
    "objectID": "05-subsetting-vectors.html#recycling",
    "href": "05-subsetting-vectors.html#recycling",
    "title": "5  Subsetting vectors",
    "section": "5.3 Recycling",
    "text": "5.3 Recycling\nLet’s take a look at the comparison component of this code:\n\nnames(x) != c(\"a\", \"c\")\n\nWarning in names(x) != c(\"a\", \"c\"): longer object length is not a multiple of\nshorter object length\n\n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nWhy does R give TRUE as the third element of this vector, when names(x)[3] != \"c\" is obviously false? When you use !=, R tries to compare each element of the left argument with the corresponding element of its right argument. What happens when you compare vectors of different lengths?\n\n\n\nInequality testing\n\n\nWhen one vector is shorter than the other, it gets recycled:\n\n\n\nInequality testing: results of recycling\n\n\nIn this case R repeats c(\"a\", \"c\") as many times as necessary to match names(x), i.e. we get c(\"a\",\"c\",\"a\",\"c\",\"a\"). Since the recycled \"a\" doesn’t match the third element of names(x), the value of != is TRUE. Because in this case the longer vector length (5) isn’t a multiple of the shorter vector length (2), R printed a warning message. If we had been unlucky and names(x) had contained six elements, R would silently have done the wrong thing (i.e., not what we intended it to do). This recycling rule can can introduce hard-to-find and subtle bugs!\nThe way to get R to do what we really want (match each element of the left argument with all of the elements of the right argument) it to use the %in% operator. The %in% operator goes through each element of its left argument, in this case the names of x, and asks, “Does this element occur in the second argument?”. Here, since we want to exclude values, we also need a ! operator to change “in” to “not in”:\n\nx[!(names(x) %in% c(\"a\", \"c\"))]\n\n  b   d   e \n6.2 4.8 7.5"
  },
  {
    "objectID": "06-vectorization.html#vectorization",
    "href": "06-vectorization.html#vectorization",
    "title": "6  Vectorization",
    "section": "6.1 Vectorization",
    "text": "6.1 Vectorization\nMost of R’s functions are vectorized, meaning that the function will operate on all elements of a vector without needing to loop through and act on each element one at a time. This makes writing code more concise, easy to read, and less error prone.\nFor example, applying multiplication to a vector will conduct the operation element-wise:\n\nx <- 1:4\nx * 2\n\n[1] 2 4 6 8\n\n\nWe can also add two vectors together:\n\ny <- 6:9\nx + y\n\n[1]  7  9 11 13\n\n\nEach element of x was added to its corresponding element of y:\n\nx:  1  2  3  4\n    +  +  +  +\ny:  6  7  8  9\n---------------\n    7  9 11 13\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nLet’s try this on the weight column of the cats dataset. Make a new column in the cats data frame that contains a “calibrated” weight measurement, corresponding to the original weight measurement weight minus 0.5.\nCheck the head or tail of the data frame to make sure it worked.\nTo define the cats data frame, run\n\ncats <- read.csv(file = \"data/feline-data.csv\")\n\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\n\ncats$weight_calibrated <- cats$weight - 0.5\nhead(cats)\n\n    coat weight likes_string weight_calibrated\n1 calico    2.1            1               1.6\n2  black    5.0            0               4.5\n3  tabby    3.2            1               2.7\n\n\n\n\n\n\n\nComparison operators, logical operators, and many functions are also vectorized:\n\n6.1.1 Comparison operators\nComparison operators applied to a vector will produce a boolean vector\n\nx\n\n[1] 1 2 3 4\n\nx > 2\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\n\n\n6.1.2 Functions\nMost functions also operate element-wise on vectors:\n\nx <- 1:4\nx\n\n[1] 1 2 3 4\n\nlog(x)\n\n[1] 0.0000000 0.6931472 1.0986123 1.3862944\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nWe’re interested in looking at the sum of the following sequence of fractions:\n\nx = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)\n\nThis would be tedious to type out, and impossible for high values of n. Use vectorization to compute x when n = 100. What is the sum when n = 10,000?\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nsum(1/(1:100)^2)\n\n[1] 1.634984\n\nsum(1/(1:1e04)^2)\n\n[1] 1.644834\n\n\nWe could do this for a general n using:\n\nn <- 10000\nsum(1/(1:n)^2)\n\n[1] 1.644834\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Operations on vectors of unequal length\n\n\n\nOperations can also be performed on vectors of unequal length, through a process known as recycling. This process automatically repeats the smaller vector until it matches the length of the larger vector. R will provide a warning if the larger vector is not a multiple of the smaller vector.\n\nx <- c(1, 2, 3)\ny <- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 5 7 9 8\n\n\nVector x was recycled to match the length of vector y\n\nx:  1  2  3  1  2  3  1\n    +  +  +  +  +  +  +\ny:  1  2  3  4  5  6  7\n-----------------------\n    2  4  6  5  7  9  8"
  },
  {
    "objectID": "06-vectorization.html#subsetting-vectors-using-logical-operations",
    "href": "06-vectorization.html#subsetting-vectors-using-logical-operations",
    "title": "6  Vectorization",
    "section": "6.2 Subsetting vectors using logical operations ",
    "text": "6.2 Subsetting vectors using logical operations \nLet’s consider the following vector:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\n\nWe can also use any logical vector to subset:\n\nx[c(FALSE, FALSE, TRUE, FALSE, TRUE)]\n\n  c   e \n7.1 7.5 \n\n\nSince comparison operators (e.g. >, <, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one.\n\nx[x > 7]\n\n  c   e \n7.1 7.5 \n\n\nBreaking it down, this statement first evaluates x>7, generating a logical vector c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x corresponding to the TRUE values.\nWe can use == to mimic the previous method of indexing by name (remember you have to use == rather than = for comparisons):\n\nnames(x) == \"a\"\n\n[1]  TRUE FALSE FALSE FALSE FALSE\n\nx[names(x) == \"a\"]\n\n  a \n5.4"
  },
  {
    "objectID": "06-vectorization.html#combining-logical-conditions",
    "href": "06-vectorization.html#combining-logical-conditions",
    "title": "6  Vectorization",
    "section": "6.3 Combining logical conditions",
    "text": "6.3 Combining logical conditions\nWe often want to combine multiple logical criteria. For example, we might want to find all the countries that are located in Asia or Europe and have life expectancies within a certain range. Several operations for combining logical vectors exist in R:\n\n&, the “logical AND” operator: returns TRUE if both the left and right are TRUE.\n|, the “logical OR” operator: returns TRUE, if either the left or right (or both) are TRUE.\n\nYou may sometimes see && and || instead of & and |. These two-character operators only look at the first element of each vector and ignore the remaining elements. In general you should not use the two-character operators in data analysis.\n\n!, the “logical NOT” operator: converts TRUE to FALSE and FALSE to TRUE. It can negate a single logical condition (eg !TRUE becomes FALSE), or a whole vector of conditions(eg !c(TRUE, FALSE) becomes c(FALSE, TRUE)).\n\nAdditionally, you can compare the elements within a single vector using the all function (which returns TRUE if every element of the vector is TRUE) and the any function (which returns TRUE if one or more elements of the vector are TRUE).\nFor example, the following code will only return the values of x that are equal to either 5.4 or 7 (since there is no value equal to 7, only the value equal to 5.4 will be returned):\n\n(x == 5.4) | (x == 7)\n\n    a     b     c     d     e \n TRUE FALSE FALSE FALSE FALSE \n\nx[(x == 5.4) | (x == 7)]\n\n  a \n5.4 \n\n\nWe could extract all entries that are not equal to 5.4 as follows:\n\nx[x != 5.4]\n\n  b   c   d   e \n6.2 7.1 4.8 7.5 \n\n\nNote that we don’t want to use == to compare with a vector, since this will only look at the first entry.\n\nx == c(5.4, 4.8, 7.5)\n\nWarning in x == c(5.4, 4.8, 7.5): longer object length is not a multiple of\nshorter object length\n\n\n    a     b     c     d     e \n TRUE FALSE FALSE FALSE FALSE \n\n\nInstead, use the %in% operator:"
  },
  {
    "objectID": "06-vectorization.html#the-in-operator-in",
    "href": "06-vectorization.html#the-in-operator-in",
    "title": "6  Vectorization",
    "section": "6.4 The in operator %in%",
    "text": "6.4 The in operator %in%\nAnother way to do this is to ask R to subset the values of x that are “in” a vector of values.\n\nx %in% c(5.4, 4.8, 7)\n\n[1]  TRUE FALSE FALSE  TRUE FALSE\n\nx[x %in% c(5.4, 4.8, 7)]\n\n  a   d \n5.4 4.8 \n\n\nWe could extract the entries that are not in this vector by preceding the logical expression with a !\n\n!(x %in% c(5.4, 4.8, 7))\n\n[1] FALSE  TRUE  TRUE FALSE  TRUE\n\nx[!(x %in% c(5.4, 4.8, 7))]\n\n  b   c   e \n6.2 7.1 7.5 \n\n\n\n\n\n\n\n\nTip: Getting help for operators\n\n\n\nRemember you can search for help on operators by wrapping them in quotes: help(\"%in%\") or ?\"%in%\".\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nGiven the following code:\n\nx <- c(5.4, 6.2, 7.1, 4.8, 7.5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e')\nx\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\nWrite a subsetting command to return the values in x that are greater than 4 or less than 7.\nWrite another subsetting command to return the values in x that are greater than 4 and less than 7.\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\ngreater than 4 or less than 7:\n\nx[(x < 7) | (x > 4)]\n\n  a   b   c   d   e \n5.4 6.2 7.1 4.8 7.5 \n\n\ngreater than 4 and less than 7:\n\nx[(x < 7) & (x > 4)]\n\n  a   b   d \n5.4 6.2 4.8 \n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Non-unique names\n\n\n\nIt is possible for multiple elements in a vector to have the same name. (For a data frame, columns can have the same name too.) Consider these examples:\n\nx <- 1:3\nx\n\n[1] 1 2 3\n\nnames(x) <- c('a', 'a', 'a')\nx\n\na a a \n1 2 3 \n\nx['a']  # only returns first value\n\na \n1 \n\nx[names(x) == 'a']  # returns all three values\n\na a a \n1 2 3"
  },
  {
    "objectID": "07-data-frames.html",
    "href": "07-data-frames.html",
    "title": "7  Data frames",
    "section": "",
    "text": "8 Data frames\nWe introduced data frames at the very beginning of this lesson, they represent a table of data. Recall our cats data frame:\nColumns of a data frame are vectors of different types, each of the same length, that are organized by belonging to the same table.\nIn our cats example, we have an character, a numeric, and a logical column/variable. As we have seen already, each column of data.frame is a vector."
  },
  {
    "objectID": "07-data-frames.html#extracting-columns-from-a-data-frame",
    "href": "07-data-frames.html#extracting-columns-from-a-data-frame",
    "title": "7  Data frames",
    "section": "8.1 Extracting columns from a data frame",
    "text": "8.1 Extracting columns from a data frame\nThere are several ways to extract an individual column in a data frame, including using the $ notation that we used above:\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nBut a column can also be accessed using the square bracket notation:\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nwhich returns the column as a vector.\nThe syntax df[i, j] to extract the entry in the ith row and the jth column from the data frame called df. For example, df[3, 1] will extract the single entry in the third row and first column.\nA blank i or j this tells R to extract all of the rows or columns, respectively. That is, df[, 1] will extract all rows for the 1st column, and df[2, ] will extract the second row across all columns.\n\n8.1.1 The square bracket syntax [ ]\n\ndf[, j] will extract the jth column from the data frame called df as a vector.\ndf[i, ] will extract the ith row from the data frame called df as a data frame.\n\nFor example the following code extracts the data from the second column of cats as a vector\n\ncats[, 2]\n\n[1] 2.1 5.0 3.2\n\n\nand the following code extracts the second row of cats as a data frame:\n\ncats[2, ]\n\n   coat weight likes_string\n2 black      5            0\n\n\nNote, to extract the \\(j\\)th column from a data frame as a single-column data frame, you can use the single-dimension square bracket syntax: df[j].\n\ncats[2]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\nThis syntax also works with named indexing.\n\ncats[\"weight\"]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nThere are several subtly different ways to extract observations and elements from data.frames:\n\ncats[1]\ncats$coat\ncats[\"coat\"]\ncats[1, 1]\ncats[, 1]\ncats[1, ]\n\nTry out these examples and explain what is returned by each one.\nHint: Use the function class() to examine what is returned in each case.\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\n\ncats[1]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nWe can think of a data frame as a list of vectors. The single brace [1] returns the first slice of the list, as another list. In this case it is the first column of the data frame.\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThis example uses the $ character to address items by name. coat is the first column of the data frame, again a vector of type character.\n\ncats[\"coat\"]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nHere we are using a single brace [\"coat\"] replacing the index number with the column name. Like example 1, the returned object is a list.\n\ncats[1, 1]\n\n[1] \"calico\"\n\n\nThis example uses a single brace, but this time we provide row and column coordinates. The returned object is the value in row 1, column 1. The object is a vector of type character.\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nLike the previous example we use single braces and provide row and column coordinates. The row coordinate is not specified, R interprets this missing value as all the elements in this column and returns them as a vector.\n\ncats[1, ]\n\n    coat weight likes_string\n1 calico    2.1            1\n\n\nAgain we use the single brace with row and column coordinates. The column coordinate is not specified. The return value is a list containing all the values in the first row.\n\n\n\n\n\n\n\n\n\n\n\nTip: Renaming data frame columns\n\n\n\nLike vectors, data frames have column names, which can be accessed with the names() function.\n\nnames(cats)\n\n[1] \"coat\"         \"weight\"       \"likes_string\"\n\n\nIf you want to rename the second column of cats, you can assign a new name to the second element of names(cats).\n\nnames(cats)[2] <- \"weight_kg\"\ncats\n\n    coat weight_kg likes_string\n1 calico       2.1            1\n2  black       5.0            0\n3  tabby       3.2            1\n\n\n\n\nLet’s move away from cats to a more interesting data example: gapminder\n\ngapminder <- read.csv(\"data/gapminder_data.csv\")\n\n\n\n\n\n\n\nTip: filter\n\n\n\nIn the dplyr lesson, you will learn another method of filtering to rows of a data frame that satisfy a certain condition using the filter() function from the dplyr package in the tidyverse suite.\n\n\n\n\n8.1.2 Data frame subsetting\n[ with one argument is one way to extract a single column, but the resulting object will be a data frame with one column:\n\nhead(gapminder[3])\n\n       pop\n1  8425333\n2  9240934\n3 10267083\n4 11537966\n5 13079460\n6 14880372\n\n\n[[, however, will act to extract a single column as a vector:\n\nhead(gapminder[[3]])\n\n[1]  8425333  9240934 10267083 11537966 13079460 14880372\n\n\nNotice the difference in the way the two results are presented (the first is a data frame, the second is a vector)\n\nhead(gapminder[[\"lifeExp\"]])\n\n[1] 28.801 30.332 31.997 34.020 36.088 38.438\n\n\nAnd $ provides a convenient shorthand to extract columns by name:\n\nhead(gapminder$year)\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nWith two arguments, [ behaves lets us extract multiple rows and columns:\n\ngapminder[1:3, ]\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nIf we subset a single row, the result will be a data frame (because the elements are mixed types, they can’t be a vector):\n\ngapminder[3, ]\n\n      country year      pop continent lifeExp gdpPercap\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n\n\nFor a single column the result will be a vector (this can be changed with the third argument, drop = FALSE).\n\nhead(gapminder[, 2])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\nwhich is equivalent to\n\nhead(gapminder[[2]])\n\n[1] 1952 1957 1962 1967 1972 1977\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nEach of the following pieces of code are incorrect. Identify the error and fix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\ngapminder[gapminder$year = 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\ngapminder[, -1:4]\n\n\nExtract the rows where the life expectancy is longer the 80 years\n\n\ngapminder[gapminder$lifeExp > 80]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\ngapminder[1, 4, 5]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\ngapminder[gapminder$year == 2002 | 2007, ]\n\n\n\n\n\n\n\nSolution to challenge 6\n\n\n\n\n\nFix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\n# gapminder[gapminder$year = 1957, ]\ngapminder[gapminder$year == 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\n# gapminder[, -1:4]\ngapminder[, -c(1:4)]\n\n\nExtract the rows where the life expectancy is longer than 80 years\n\n\n# gapminder[gapminder$lifeExp > 80]\ngapminder[gapminder$lifeExp > 80, ]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\n# gapminder[1, 4, 5]\ngapminder[1, c(4, 5)]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\n# gapminder[gapminder$year == 2002 | 2007, ]\ngapminder[gapminder$year == 2002 | gapminder$year == 2007, ]\n# or\ngapminder[gapminder$year %in% c(2002, 2007), ]\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSelecting elements of a vector that match “any of” a list of components is a very common data analysis task.\nSuppose we want to pull out information from Southeast Asia, which includes the countries of Myanmar, Thailand, Cambodia, Vietnam, and Laos.\nYour task is to subset the data just to the rows that include the countries in Southeast Asia\n\nDefine a logical vector that is TRUE for all of the countries in southeast Asia and FALSE otherwise.\nUse this logical vector to extract just the rows for Southeast Asia from the gapminder dataset.\n\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\n\nse_asia = gapminder$country %in% c(\"Myanmar\", \"Thailand\", \"Cambodia\", \"Vietnam\", \"Laos\")\ngapminder[se_asia, ]\n\n      country year      pop continent lifeExp gdpPercap\n217  Cambodia 1952  4693836      Asia  39.417  368.4693\n218  Cambodia 1957  5322536      Asia  41.366  434.0383\n219  Cambodia 1962  6083619      Asia  43.415  496.9136\n220  Cambodia 1967  6960067      Asia  45.415  523.4323\n221  Cambodia 1972  7450606      Asia  40.317  421.6240\n222  Cambodia 1977  6978607      Asia  31.220  524.9722\n223  Cambodia 1982  7272485      Asia  50.957  624.4755\n224  Cambodia 1987  8371791      Asia  53.914  683.8956\n225  Cambodia 1992 10150094      Asia  55.803  682.3032\n226  Cambodia 1997 11782962      Asia  56.534  734.2852\n227  Cambodia 2002 12926707      Asia  56.752  896.2260\n228  Cambodia 2007 14131858      Asia  59.723 1713.7787\n1045  Myanmar 1952 20092996      Asia  36.319  331.0000\n1046  Myanmar 1957 21731844      Asia  41.905  350.0000\n1047  Myanmar 1962 23634436      Asia  45.108  388.0000\n1048  Myanmar 1967 25870271      Asia  49.379  349.0000\n1049  Myanmar 1972 28466390      Asia  53.070  357.0000\n1050  Myanmar 1977 31528087      Asia  56.059  371.0000\n1051  Myanmar 1982 34680442      Asia  58.056  424.0000\n1052  Myanmar 1987 38028578      Asia  58.339  385.0000\n1053  Myanmar 1992 40546538      Asia  59.320  347.0000\n1054  Myanmar 1997 43247867      Asia  60.328  415.0000\n1055  Myanmar 2002 45598081      Asia  59.908  611.0000\n1056  Myanmar 2007 47761980      Asia  62.069  944.0000\n1525 Thailand 1952 21289402      Asia  50.848  757.7974\n1526 Thailand 1957 25041917      Asia  53.630  793.5774\n1527 Thailand 1962 29263397      Asia  56.061 1002.1992\n1528 Thailand 1967 34024249      Asia  58.285 1295.4607\n1529 Thailand 1972 39276153      Asia  60.405 1524.3589\n1530 Thailand 1977 44148285      Asia  62.494 1961.2246\n1531 Thailand 1982 48827160      Asia  64.597 2393.2198\n1532 Thailand 1987 52910342      Asia  66.084 2982.6538\n1533 Thailand 1992 56667095      Asia  67.298 4616.8965\n1534 Thailand 1997 60216677      Asia  67.521 5852.6255\n1535 Thailand 2002 62806748      Asia  68.564 5913.1875\n1536 Thailand 2007 65068149      Asia  70.616 7458.3963\n1645  Vietnam 1952 26246839      Asia  40.412  605.0665\n1646  Vietnam 1957 28998543      Asia  42.887  676.2854\n1647  Vietnam 1962 33796140      Asia  45.363  772.0492\n1648  Vietnam 1967 39463910      Asia  47.838  637.1233\n1649  Vietnam 1972 44655014      Asia  50.254  699.5016\n1650  Vietnam 1977 50533506      Asia  55.764  713.5371\n1651  Vietnam 1982 56142181      Asia  58.816  707.2358\n1652  Vietnam 1987 62826491      Asia  62.820  820.7994\n1653  Vietnam 1992 69940728      Asia  67.662  989.0231\n1654  Vietnam 1997 76048996      Asia  70.672 1385.8968\n1655  Vietnam 2002 80908147      Asia  73.017 1764.4567\n1656  Vietnam 2007 85262356      Asia  74.249 2441.5764\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 7\n\n\n\n\nWhy does gapminder[1:20] return an error? How does it differ from gapminder[1:20, ]?\nCreate a new data.frame called gapminder_subset that only contains rows 1 through 9 and rows 19 through 23.\n\n\n\n\n\n\n\nSolution to challenge 7\n\n\n\n\n\n\ngapminder[1:20] tries to extract the first 20 columns, but there are not 20 columns. gapminder[1:20, ] subsets the data to give the first 20 rows and all columns.\n\n\n\ngapminder_subset <- gapminder[c(1:9, 19:23), ]"
  },
  {
    "objectID": "07-subsetting-data-frames.html",
    "href": "07-subsetting-data-frames.html",
    "title": "7  Subsetting data frames",
    "section": "",
    "text": "8 Data frames\nData frames represent a table of data. Recall our cats data frame:\nColumns of a data frame are vectors of different types, each of the same length, that are organized by belonging to the same table.\nIn our cats example, we have a character, a numeric, and a logical column/variable. As we have seen already, each column of data.frame is a vector."
  },
  {
    "objectID": "07-subsetting-data-frames.html#extracting-columns-from-a-data-frame",
    "href": "07-subsetting-data-frames.html#extracting-columns-from-a-data-frame",
    "title": "7  Subsetting data frames",
    "section": "8.1 Extracting columns from a data frame",
    "text": "8.1 Extracting columns from a data frame\n\n8.1.1 The dollar sign syntax $\nThere are several ways to extract an individual column in a data frame, including using the $ notation for extracting columns by name:\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThis approach returns the column as a vector.\n\n\n8.1.2 The square bracket syntax with two dimensions [,]\nA column can also be accessed using the square bracket notation with two dimensions:\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThe syntax df[i, j] to extract the entry in the ith row and the jth column from the data frame called df. For example, df[3, 1] will extract the single entry in the third row and first column.\nA blank i or j this tells R to extract all of the rows or columns, respectively. That is, df[, 1] will extract all rows for the 1st column, and df[2, ] will extract the second row across all columns.\n\ndf[, j] will extract the jth column from the data frame called df as a vector.\ndf[i, ] will extract the ith row from the data frame called df as a data frame.\n\nFor example the following code extracts the data from the second column of cats as a vector\n\ncats[, 2]\n\n[1] 2.1 5.0 3.2\n\n\nand the following code extracts the second row of cats as a data frame:\n\ncats[2, ]\n\n   coat weight likes_string\n2 black      5            0\n\n\n\n\n8.1.3 The square bracket syntax with one dimension []\nNote, to extract the \\(j\\)th column, you can alternatively use the single-dimension square bracket syntax: df[j].\n\ncats[2]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\nThis syntax also works with named indexing.\n\ncats[\"weight\"]\n\n  weight\n1    2.1\n2    5.0\n3    3.2\n\n\nThis, however, returns a one-dimensional data frame, rather than a vector.\n\n\n8.1.4 The double bracket syntax with one dimension [[]]\nFinally, another way to extract a column from a data frame is using the double bracket syntax [[]]:\n\ncats[[2]]\n\n[1] 2.1 5.0 3.2\n\n\nThis also works with named indexing:\n\ncats[[\"weight\"]]\n\n[1] 2.1 5.0 3.2\n\n\nCan you see how the output of indexing with this [[]] syntax differs from the single bracket syntax []?\nThe double bracket syntax [[]] returns the column as a vector, whereas the single bracket syntax [] returns the column as a single-column data frame.\n\n\n\n\n\n\nChallenge 1\n\n\n\nThere are several subtly different ways to extract observations and elements from data.frames:\n\ncats[1]\ncats$coat\ncats[\"coat\"]\ncats[1, 1]\ncats[, 1]\ncats[1, ]\n\nTry out these examples and explain what is returned by each one.\nHint: Use the function class() to examine what is returned in each case.\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\ncats[1]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nThe single brace [1] returns the first column of the data frame as a one-column data frame (this will make more sense once we introduce lists).\nThe $ notation, however, lets us extract a column by name as a vector.\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nLike for vectors, we can also use the single brace notation with named indexing:\n\ncats[\"coat\"]\n\n    coat\n1 calico\n2  black\n3  tabby\n\n\nHere we are using a single brace [\"coat\"] replacing the index number with the column name. Like example 1, the returned object is a data frame.\nNext,\n\ncats[1, 1]\n\n[1] \"calico\"\n\n\nThis example uses a single brace, but this time we provide row and column coordinates. The returned object is the value in row 1, column 1. The object is a vector of type character.\nWhat about:\n\ncats[, 1]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nLike the previous example we use single braces and provide row and column coordinates. The row coordinate is not specified, R interprets this missing value as all the elements in this column and returns them as a vector.\n\ncats[1, ]\n\n    coat weight likes_string\n1 calico    2.1            1\n\n\nAgain we use the single brace with row and column coordinates. The column coordinate is not specified. The return value is a list containing all the values in the first row.\n\n\n\n\n\n\n\n\n\n\n\nTip: Renaming data frame columns\n\n\n\nLike vectors, data frames have column names, which can be accessed with the names() function.\n\nnames(cats)\n\n[1] \"coat\"         \"weight\"       \"likes_string\"\n\n\nIf you want to rename the second column of cats, you can assign a new name to the second element of names(cats).\n\nnames(cats)[2] <- \"weight_kg\"\ncats\n\n    coat weight_kg likes_string\n1 calico       2.1            1\n2  black       5.0            0\n3  tabby       3.2            1\n\n\n\n\n\n\n\n\n\n\nTip: select and rename\n\n\n\nIn the dplyr lesson, you will learn another method of extracting columns of a data frame and renaming them using the select() and rename() functions from the dplyr package in the tidyverse suite."
  },
  {
    "objectID": "07-subsetting-data-frames.html#extracting-multiple-columns-and-rows",
    "href": "07-subsetting-data-frames.html#extracting-multiple-columns-and-rows",
    "title": "7  Subsetting data frames",
    "section": "8.2 Extracting multiple columns (and rows)",
    "text": "8.2 Extracting multiple columns (and rows)\nThe square bracket syntaxes (but not the $ syntax) options allow us to select multiple columns at once:\nCan you guess what the following code will return?\n\ncats[1:2]\n\n    coat weight_kg\n1 calico       2.1\n2  black       5.0\n3  tabby       3.2\n\n\n\ncats[c(3, 1), 3]\n\n[1] 1 1\n\n\nLike for vectors, we can also subset using logical operations:\nThe following code will select only the rows where the cat’s weight is at least 3\n\ncats$weight > 3\n\n[1] FALSE  TRUE  TRUE\n\ncats[cats$weight > 3, ]\n\n   coat weight_kg likes_string\n2 black       5.0            0\n3 tabby       3.2            1\n\n\nThe following code will select only the rows where the cat’s coat is tabby or calico and returns just the values in the “weight” column:\n\ncats[cats$coat %in% c(\"tabby\", \"calico\"), \"weight\"]\n\nNULL"
  },
  {
    "objectID": "07-subsetting-data-frames.html#gapminder-example",
    "href": "07-subsetting-data-frames.html#gapminder-example",
    "title": "7  Subsetting data frames",
    "section": "8.3 Gapminder example",
    "text": "8.3 Gapminder example\nLet’s move away from cats to a more interesting data example: gapminder\n\ngapminder <- read.csv(\"data/gapminder_data.csv\")\n\nThe gapminder dataset contains information on the population, life expectency, GDP per capita for a range of country-year combinations:\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\n\ndim(gapminder)\n\n[1] 1704    6\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nEach of the following pieces of code are incorrect. Identify the error and fix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\ngapminder[gapminder$year = 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\ngapminder[, -1:4]\n\n\nExtract the rows where the life expectancy is longer the 80 years\n\n\ngapminder[gapminder$lifeExp > 80]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\ngapminder[1, 4, 5]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\ngapminder[gapminder$year == 2002 | 2007, ]\n\n\n\n\n\n\n\nSolution to challenge 2\n\n\n\n\n\nFix each of the following common data frame subsetting errors:\n\nExtract observations collected for the year 1957\n\n\n# gapminder[gapminder$year = 1957, ]\ngapminder[gapminder$year == 1957, ]\n\n\nExtract all columns except 1 through to 4\n\n\n# gapminder[, -1:4]\ngapminder[, -c(1:4)]\n\n\nExtract the rows where the life expectancy is longer than 80 years\n\n\n# gapminder[gapminder$lifeExp > 80]\ngapminder[gapminder$lifeExp > 80, ]\n\n\nExtract the first row, and the fourth and fifth columns (continent and lifeExp).\n\n\n# gapminder[1, 4, 5]\ngapminder[1, c(4, 5)]\n\n\nAdvanced: extract rows that contain information for the years 2002 and 2007\n\n\n# gapminder[gapminder$year == 2002 | 2007, ]\ngapminder[gapminder$year == 2002 | gapminder$year == 2007, ]\n# or\ngapminder[gapminder$year %in% c(2002, 2007), ]\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSelecting elements of a vector that match “any of” a list of components is a very common data analysis task.\nSuppose we want to pull out information from Southeast Asia, which includes the countries of Myanmar, Thailand, Cambodia, Vietnam, and Laos.\nYour task is to subset the data just to the rows that include the countries in Southeast Asia\n\nDefine a logical vector that is TRUE for all of the countries in southeast Asia and FALSE otherwise.\nUse this logical vector to extract just the rows for Southeast Asia from the gapminder dataset.\n\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\n\nse_asia = gapminder$country %in% c(\"Myanmar\", \"Thailand\", \"Cambodia\", \"Vietnam\", \"Laos\")\ngapminder[se_asia, ]\n\n      country year      pop continent lifeExp gdpPercap\n217  Cambodia 1952  4693836      Asia  39.417  368.4693\n218  Cambodia 1957  5322536      Asia  41.366  434.0383\n219  Cambodia 1962  6083619      Asia  43.415  496.9136\n220  Cambodia 1967  6960067      Asia  45.415  523.4323\n221  Cambodia 1972  7450606      Asia  40.317  421.6240\n222  Cambodia 1977  6978607      Asia  31.220  524.9722\n223  Cambodia 1982  7272485      Asia  50.957  624.4755\n224  Cambodia 1987  8371791      Asia  53.914  683.8956\n225  Cambodia 1992 10150094      Asia  55.803  682.3032\n226  Cambodia 1997 11782962      Asia  56.534  734.2852\n227  Cambodia 2002 12926707      Asia  56.752  896.2260\n228  Cambodia 2007 14131858      Asia  59.723 1713.7787\n1045  Myanmar 1952 20092996      Asia  36.319  331.0000\n1046  Myanmar 1957 21731844      Asia  41.905  350.0000\n1047  Myanmar 1962 23634436      Asia  45.108  388.0000\n1048  Myanmar 1967 25870271      Asia  49.379  349.0000\n1049  Myanmar 1972 28466390      Asia  53.070  357.0000\n1050  Myanmar 1977 31528087      Asia  56.059  371.0000\n1051  Myanmar 1982 34680442      Asia  58.056  424.0000\n1052  Myanmar 1987 38028578      Asia  58.339  385.0000\n1053  Myanmar 1992 40546538      Asia  59.320  347.0000\n1054  Myanmar 1997 43247867      Asia  60.328  415.0000\n1055  Myanmar 2002 45598081      Asia  59.908  611.0000\n1056  Myanmar 2007 47761980      Asia  62.069  944.0000\n1525 Thailand 1952 21289402      Asia  50.848  757.7974\n1526 Thailand 1957 25041917      Asia  53.630  793.5774\n1527 Thailand 1962 29263397      Asia  56.061 1002.1992\n1528 Thailand 1967 34024249      Asia  58.285 1295.4607\n1529 Thailand 1972 39276153      Asia  60.405 1524.3589\n1530 Thailand 1977 44148285      Asia  62.494 1961.2246\n1531 Thailand 1982 48827160      Asia  64.597 2393.2198\n1532 Thailand 1987 52910342      Asia  66.084 2982.6538\n1533 Thailand 1992 56667095      Asia  67.298 4616.8965\n1534 Thailand 1997 60216677      Asia  67.521 5852.6255\n1535 Thailand 2002 62806748      Asia  68.564 5913.1875\n1536 Thailand 2007 65068149      Asia  70.616 7458.3963\n1645  Vietnam 1952 26246839      Asia  40.412  605.0665\n1646  Vietnam 1957 28998543      Asia  42.887  676.2854\n1647  Vietnam 1962 33796140      Asia  45.363  772.0492\n1648  Vietnam 1967 39463910      Asia  47.838  637.1233\n1649  Vietnam 1972 44655014      Asia  50.254  699.5016\n1650  Vietnam 1977 50533506      Asia  55.764  713.5371\n1651  Vietnam 1982 56142181      Asia  58.816  707.2358\n1652  Vietnam 1987 62826491      Asia  62.820  820.7994\n1653  Vietnam 1992 69940728      Asia  67.662  989.0231\n1654  Vietnam 1997 76048996      Asia  70.672 1385.8968\n1655  Vietnam 2002 80908147      Asia  73.017 1764.4567\n1656  Vietnam 2007 85262356      Asia  74.249 2441.5764\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\n\nWhy does gapminder[1:20] return an error? How does it differ from gapminder[1:20, ]?\nCreate a new data.frame called gapminder_subset that only contains rows 1 through 9 and rows 19 through 23.\n\n\n\n\n\n\n\nSolution to challenge 4\n\n\n\n\n\n\ngapminder[1:20] tries to extract the first 20 columns, but there are not 20 columns. gapminder[1:20, ] subsets the data to give the first 20 rows and all columns.\n\n\n\ngapminder_subset <- gapminder[c(1:9, 19:23), ]"
  },
  {
    "objectID": "08-dplyr.html#the-dplyr-package",
    "href": "08-dplyr.html#the-dplyr-package",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.1 The dplyr package",
    "text": "8.1 The dplyr package\nLuckily, the dplyr package provides a number of very useful functions for manipulating data frames in a way that will reduce the above repetition, reduce the probability of making errors, and probably even save you some typing. As an added bonus, you might even find the dplyr grammar easier to read.\n\n\n\n\n\n\nTip: Tidyverse\n\n\n\ndplyr package belongs to a broader family of opinionated R packages designed for data science called the “Tidyverse”. These packages are specifically designed to work harmoniously together. Some of these packages will be covered along this course, but you can find more complete information here: https://www.tidyverse.org/.\n\n\nHere we’re going to cover 5 of the most commonly used functions as well as using pipes (|>) to combine them.\n\nselect()\nfilter()\ngroup_by()\nsummarize()\nmutate()\n\n\n\n\n\n\n\n\n\n\n\nYou will need to install (if you have not already) and load the tidyverse package, which will also install dplyr, ggplot2, and other related packages:\n\ninstall.packages('tidyverse')\n\n\nlibrary(tidyverse)\n\nRecall that you only need to install a package once (so you should not include the install.packages() code in your code chunk – you can just run it directly in the console), but you need to load it every time you start a new R session."
  },
  {
    "objectID": "08-dplyr.html#using-select",
    "href": "08-dplyr.html#using-select",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.2 Using select()",
    "text": "8.2 Using select()\nIf, for example, we wanted to move forward with only a few of the variables in our data frame we could use the select() function. This will keep only the variables you select.\n\nyear_country_gdp <- select(gapminder, year, country, gdpPercap)\n\n If we want to remove one column only from the gapminder data, for example, removing the continent column.\n\nsmaller_gapminder_data <- select(gapminder, -continent)\n\nIf we open up year_country_gdp we’ll see that it only contains the year, country and gdpPercap. Above we used ‘normal’ grammar, but the strengths of dplyr lie in combining several functions using pipes. Since the pipes grammar is unlike anything we’ve seen in R before, let’s repeat what we’ve done above using pipes.\n\nyear_country_gdp <- gapminder |> select(year, country, gdpPercap)\n\nTo help you understand why we wrote that in that way, let’s walk through it step by step. First we summon the gapminder data frame and pass it on, using the pipe symbol |>, to the next step, which is the select() function. In this case we don’t specify which data object we use in the select() function since in gets that from the previous pipe. Fun Fact: There is a good chance you have encountered pipes before in the shell. In R, a pipe symbol is |> while in the shell it is | but the concept is the same!\n\n\n\n\n\n\nTip: Renaming data frame columns in dplyr\n\n\n\nIn Chapter 4 we covered how you can rename columns with base R by assigning a value to the output of the names() function. Just like select, this is a bit cumbersome, but thankfully dplyr has a rename() function. Within a pipeline, the syntax is rename(new_name = old_name). For example, we may want to rename the gdpPercap column name from our select() statement above.\n\ntidy_gdp <- year_country_gdp |> rename(gdp_per_capita = gdpPercap)\nhead(tidy_gdp)\n\n  year     country gdp_per_capita\n1 1952 Afghanistan       779.4453\n2 1957 Afghanistan       820.8530\n3 1962 Afghanistan       853.1007\n4 1967 Afghanistan       836.1971\n5 1972 Afghanistan       739.9811\n6 1977 Afghanistan       786.1134"
  },
  {
    "objectID": "08-dplyr.html#using-filter",
    "href": "08-dplyr.html#using-filter",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.3 Using filter()",
    "text": "8.3 Using filter()\nIf we now want to move forward with the above, but only with European countries, we can combine select and filter\n\nyear_country_gdp_euro <- gapminder |>\n  filter(continent == \"Europe\") |>\n  select(year, country, gdpPercap)\n\nIf we now want to show life expectancy of European countries but only for a specific year (e.g., 2007), we can do as below.\n\neurope_lifeExp_2007 <- gapminder |>\n  filter(continent == \"Europe\", year == 2007) |>\n  select(country, lifeExp)\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nWrite a single command (which can span multiple lines and includes pipes) that will produce a data frame that has the African values for lifeExp, country and year, but not for other Continents. How many rows does your data frame have and why?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\nyear_country_lifeExp_Africa <- gapminder |>\n  filter(continent == \"Africa\") |>\n  select(year, country, lifeExp)\n\n\n\n\n\n\nAs with last time, first we pass the gapminder data frame to the filter() function, then we pass the filtered version of the gapminder data frame to the select() function. Note: The order of operations is very important in this case. If we used ‘select’ first, filter would not be able to find the variable continent since we would have removed it in the previous step."
  },
  {
    "objectID": "08-dplyr.html#using-group_by",
    "href": "08-dplyr.html#using-group_by",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.4 Using group_by()",
    "text": "8.4 Using group_by()\nNow, we were supposed to be reducing the error prone repetitiveness of what can be done with base R, but up to now we haven’t done that since we would have to repeat the above for each continent. Instead of filter(), which will only pass observations that meet your criteria (in the above: continent == \"Europe\"), we can use group_by(), which will essentially use every unique criteria that you could have used in filter.\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\nstr(gapminder |> group_by(continent))\n\ngropd_df [1,704 × 6] (S3: grouped_df/tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num [1:1704] 8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n - attr(*, \"groups\")= tibble [5 × 2] (S3: tbl_df/tbl/data.frame)\n  ..$ continent: chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...\n  ..$ .rows    : list<int> [1:5] \n  .. ..$ : int [1:624] 25 26 27 28 29 30 31 32 33 34 ...\n  .. ..$ : int [1:300] 49 50 51 52 53 54 55 56 57 58 ...\n  .. ..$ : int [1:396] 1 2 3 4 5 6 7 8 9 10 ...\n  .. ..$ : int [1:360] 13 14 15 16 17 18 19 20 21 22 ...\n  .. ..$ : int [1:24] 61 62 63 64 65 66 67 68 69 70 ...\n  .. ..@ ptype: int(0) \n  ..- attr(*, \".drop\")= logi TRUE\n\n\nYou will notice that the structure of the data frame where we used group_by() (grouped_df) is not the same as the original gapminder (data.frame). A grouped_df can be thought of as a list where each item in the listis a data.frame which contains only the rows that correspond to the a particular value continent (at least in the example above).\n\n\n\nDiagram illustrating how the group by function oraganizes a data frame into groups"
  },
  {
    "objectID": "08-dplyr.html#using-summarize",
    "href": "08-dplyr.html#using-summarize",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.5 Using summarize()",
    "text": "8.5 Using summarize()\nThe above was a bit on the uneventful side but group_by() is much more exciting in conjunction with summarize(). This will allow us to create new variable(s) by using functions that repeat for each of the continent-specific data frames. That is to say, using the group_by() function, we split our original data frame into multiple pieces, then we can run functions (e.g. mean() or sd()) within summarize().\n\ngdp_bycontinents <- gapminder |>\n  group_by(continent) |>\n  summarize(mean_gdpPercap = mean(gdpPercap))\n\n\n\n\nDiagram illustrating the use of group by and summarize together to create a new variable\n\n\n\ncontinent mean_gdpPercap\n<fctr>          <dbl>\n  1    Africa       2193.755\n2  Americas       7136.110\n3      Asia       7902.150\n4    Europe      14469.476\n5   Oceania      18621.609\n\nThat allowed us to calculate the mean gdpPercap for each continent, but it gets even better.\n\n\n\n\n\n\nChallenge 2\n\n\n\nCalculate the average life expectancy per country. Which has the longest average life expectancy and which has the shortest average life expectancy?\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nlifeExp_bycountry <- gapminder |>\n  group_by(country) |>\n  summarize(mean_lifeExp = mean(lifeExp))\nlifeExp_bycountry |>\n  filter(mean_lifeExp == min(mean_lifeExp) | mean_lifeExp == max(mean_lifeExp))\n\n# A tibble: 2 × 2\n  country      mean_lifeExp\n  <chr>               <dbl>\n1 Iceland              76.5\n2 Sierra Leone         36.8\n\n\nAnother way to do this is to use the dplyr function arrange(), which arranges the rows in a data frame according to the order of one or more variables from the data frame. It has similar syntax to other functions from the dplyr package. You can use desc() inside arrange() to sort in descending order.\n\nlifeExp_bycountry |>\n  arrange(mean_lifeExp) |>\n  head(1)\n\n# A tibble: 1 × 2\n  country      mean_lifeExp\n  <chr>               <dbl>\n1 Sierra Leone         36.8\n\nlifeExp_bycountry |>\n  arrange(desc(mean_lifeExp)) |>\n  head(1)\n\n# A tibble: 1 × 2\n  country mean_lifeExp\n  <chr>          <dbl>\n1 Iceland         76.5\n\n\nAlphabetical order works too\n\nlifeExp_bycountry |>\n  arrange(desc(country)) |>\n  head(1)\n\n# A tibble: 1 × 2\n  country  mean_lifeExp\n  <chr>           <dbl>\n1 Zimbabwe         52.7\n\n\n\n\n\n\n\nThe function group_by() allows us to group by multiple variables. Let’s group by year and continent.\n\ngdp_bycontinents_byyear <- gapminder |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\nThat is already quite powerful, but it gets even better! You’re not limited to defining 1 new variable in summarize().\n\ngdp_pop_bycontinents_byyear <- gapminder |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            sd_gdpPercap = sd(gdpPercap),\n            mean_pop = mean(pop),\n            sd_pop = sd(pop))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "08-dplyr.html#count-and-n",
    "href": "08-dplyr.html#count-and-n",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.9 count() and n()",
    "text": "8.9 count() and n()\nA very common operation is to count the number of observations for each group. The dplyr package comes with two related functions that help with this.\nFor instance, if we wanted to check the number of countries included in the dataset for the year 2002, we can use the count() function. It takes the name of one or more columns that contain the groups we are interested in, and we can optionally sort the results in descending order by adding sort=TRUE:\n\ngapminder |>\n  filter(year == 2002) |>\n  count(continent, sort = TRUE)\n\n  continent  n\n1    Africa 52\n2      Asia 33\n3    Europe 30\n4  Americas 25\n5   Oceania  2\n\n\nIf we need to use the number of observations/rows in calculations, the n() function is useful. It will return the total number of observations in the current group rather than counting the number of observations in each group within a specific column.\nFor instance, if we wanted to get the standard error of the life expectancy per continent:\n\ngapminder |>\n  group_by(continent) |>\n  summarize(se_le = sd(lifeExp) / sqrt(n()))\n\n# A tibble: 5 × 2\n  continent se_le\n  <chr>     <dbl>\n1 Africa    0.366\n2 Americas  0.540\n3 Asia      0.596\n4 Europe    0.286\n5 Oceania   0.775\n\n\n\n\n\n\n\n\nAdvanced Challenge\n\n\n\nCalculate the total GDP in billions (gdpPercap * pop / 1e9) for each continent in the year 2002 and in 2007. Which continent had the largest GDP in 2002? which had the smallest? What about in 2007?\n\n\n\n\n\n\nSolution to Advanced Challenge\n\n\n\n\n\nOne way to answer this question is:\n\ngapminder |>\n  filter(year %in% c(1952, 2007)) |>\n  mutate(gdp = gdpPercap * pop / 1e9) |>\n  group_by(year, continent) |>\n  summarize(total_gdp = sum(gdp))\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 10 × 3\n# Groups:   year [2]\n    year continent total_gdp\n   <int> <chr>         <dbl>\n 1  1952 Africa         312.\n 2  1952 Americas      2943.\n 3  1952 Asia          1125.\n 4  1952 Europe        2549.\n 5  1952 Oceania        108.\n 6  2007 Africa        2380.\n 7  2007 Americas     19418.\n 8  2007 Asia         20708.\n 9  2007 Europe       14795.\n10  2007 Oceania        807."
  },
  {
    "objectID": "08-dplyr.html#using-mutate",
    "href": "08-dplyr.html#using-mutate",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.7 Using mutate()",
    "text": "8.7 Using mutate()\nWe can also create new variables prior to (or even after) summarizing information using mutate().\n\ngdp_pop_bycontinents_byyear <- gapminder |>\n  mutate(gdp_billion = gdpPercap * pop / 10^9) |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            sd_gdpPercap = sd(gdpPercap),\n            mean_pop = mean(pop),\n            sd_pop = sd(pop),\n            mean_gdp_billion = mean(gdp_billion),\n            sd_gdp_billion = sd(gdp_billion))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "08-dplyr.html#connect-mutate-with-logical-filtering-ifelse",
    "href": "08-dplyr.html#connect-mutate-with-logical-filtering-ifelse",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.8 Connect mutate with logical filtering: ifelse",
    "text": "8.8 Connect mutate with logical filtering: ifelse\nWhen creating new variables, we can hook this with a logical condition. A simple combination of mutate() and ifelse() facilitates filtering right where it is needed: in the moment of creating something new. This easy-to-read statement is a fast and powerful way of discarding certain data (even though the overall dimension of the data frame will not change) or for updating values depending on this given condition.\n\n## keeping all data but \"filtering\" after a certain condition\n# calculate GDP only for people with a life expectation above 25\ngdp_pop_bycontinents_byyear_above25 <- gapminder |>\n  mutate(gdp_billion = ifelse(lifeExp > 25, gdpPercap * pop / 10^9, NA)) |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            sd_gdpPercap = sd(gdpPercap),\n            mean_pop = mean(pop),\n            sd_pop = sd(pop),\n            mean_gdp_billion = mean(gdp_billion),\n            sd_gdp_billion = sd(gdp_billion))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n## updating only if certain condition is fullfilled\n# for life expectations above 40 years, the gpd to be expected in the future is scaled\ngdp_future_bycontinents_byyear_high_lifeExp <- gapminder |>\n  mutate(gdp_futureExpectation = ifelse(lifeExp > 40, gdpPercap * 1.5, gdpPercap)) |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_gdpPercap_expected = mean(gdp_futureExpectation))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\nAdvanced Challenge\n\n\n\nCalculate the average life expectancy in 2002 of 2 randomly selected countries for each continent. Then arrange the continent names in reverse order. Hint: Use the dplyr functions arrange() and sample_n(), they have similar syntax to other dplyr functions.\n\n\n\n\n\n\nSolution to Advanced Challenge\n\n\n\n\n\n\nlifeExp_2countries_bycontinents <- gapminder |>\n  filter(year == 2002) |>\n  group_by(continent) |>\n  sample_n(2) |>\n  summarize(mean_lifeExp = mean(lifeExp)) |>\n  arrange(desc(mean_lifeExp))"
  },
  {
    "objectID": "08-dplyr.html#other-great-resources",
    "href": "08-dplyr.html#other-great-resources",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.10 Other great resources",
    "text": "8.10 Other great resources\n\nR for Data Science\nData Wrangling Cheat sheet\nIntroduction to dplyr\nData wrangling with R and RStudio"
  },
  {
    "objectID": "14-tidyr.html#getting-started",
    "href": "14-tidyr.html#getting-started",
    "title": "14  Reshaping data frames with tidyr",
    "section": "14.1 Getting started",
    "text": "14.1 Getting started\nFirst install the packages if you haven’t already done so (you probably installed dplyr in the previous lesson):\n\n#install.packages(\"tidyverse\")\n\nLoad the packages\n\nlibrary(\"tidyverse\")\n\nFirst, lets look at the structure of our original gapminder data frame:\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nIs gapminder a purely long, purely wide, or some intermediate format?\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nThe original gapminder data.frame is in an intermediate format. It is not purely long since it had multiple observation variables (pop,lifeExp,gdpPercap).\n\n\n\n\n\nSometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely ‘long’ and ‘wide’ data formats. We have 3 “ID variables” (continent, country, year) and 3 “Observation variables” (pop,lifeExp,gdpPercap). This intermediate format can be preferred despite not having ALL observations in 1 column given that all 3 observation variables have different units. There are few operations that would need us to make this data frame any longer (i.e. 4 ID variables and 1 Observation variable).\nWhile using many of the functions in R, which are often vector based, you usually do not want to do mathematical operations on values with different units. For example, using the purely long format, a single mean for all of the values of population, life expectancy, and GDP would not be meaningful since it would return the mean of values with 3 incompatible units. The solution is that we first manipulate the data either by grouping (see the lesson on dplyr), or we change the structure of the data frame. Note: Some plotting functions in R actually work better in the wide format data."
  },
  {
    "objectID": "14-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "href": "14-tidyr.html#from-wide-to-long-format-with-pivot_longer",
    "title": "14  Reshaping data frames with tidyr",
    "section": "14.2 From wide to long format with pivot_longer()",
    "text": "14.2 From wide to long format with pivot_longer()\nUntil now, we’ve been using the nicely formatted original gapminder dataset, but ‘real’ data (i.e. our own research data) will never be so well organized. Here let’s start with the wide formatted version of the gapminder dataset.\n\nDownload the wide version of the gapminder data from here and save it in your data folder.\n\nWe’ll load the data file and look at it. Note: we don’t want our continent and country columns to be factors, so we use the stringsAsFactors argument for read.csv() to disable that.\n\ngap_wide <- read.csv(\"data/gapminder_wide.csv\", stringsAsFactors = FALSE)\nstr(gap_wide)\n\n'data.frame':   142 obs. of  38 variables:\n $ continent     : chr  \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr  \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num  2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num  3014 3828 960 918 617 ...\n $ gdpPercap_1962: num  2551 4269 949 984 723 ...\n $ gdpPercap_1967: num  3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num  4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num  4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num  5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num  5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num  5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num  4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num  5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num  6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num  43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num  45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num  48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num  51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num  54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num  58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num  61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num  65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num  67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num  69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num  71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num  72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num  9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num  10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num  11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num  12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num  14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num  17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num  20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num  23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num  26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num  29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : int  31287142 10866106 7026113 1630347 12251209 7021078 15929988 4048013 8835739 614382 ...\n $ pop_2007      : int  33333216 12420476 8078314 1639131 14326203 8390505 17696293 4369038 10238807 710960 ...\n\n\n\n\n\nDiagram illustrating the wide format of the gapminder data frame\n\n\nTo change this very wide data frame layout back to our nice, intermediate (or longer) layout, we will use one of the two available pivot functions from the tidyr package. To convert from wide to a longer format, we will use the pivot_longer() function. pivot_longer() makes datasets longer by increasing the number of rows and decreasing the number of columns, or ‘lengthening’ your observation variables into a single variable.\n\n\n\nDiagram illustrating how pivot longer reorganizes a data frame from a wide to long format\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"pop_1952\" \"pop_1957\" \"pop_1962\" \"pop_1967\" ...\n $ obs_values  : num [1:5112] 9279525 10270856 11000948 12760499 14760787 ...\n\n\nHere we have used piping syntax which is similar to what we were doing in the previous lesson with dplyr. In fact, these are compatible and you can use a mix of tidyr and dplyr functions by piping them together.\nWe first provide to pivot_longer() a vector of column names that will be pivoted into longer format. We could type out all the observation variables, but as in the select() function (see dplyr lesson), we can use the starts_with() argument to select all variables that start with the desired character string. pivot_longer() also allows the alternative syntax of using the - symbol to identify which variables are not to be pivoted (i.e. ID variables).\nThe next arguments to pivot_longer() are names_to for naming the column that will contain the new ID variable (obstype_year) and values_to for naming the new amalgamated observation variable (obs_value). We supply these new column names as strings.\n\n\n\nDiagram illustrating the long format of the gapminder data\n\n\n\ngap_long <- gap_wide %>%\n  pivot_longer(\n    cols = c(-continent, -country),\n    names_to = \"obstype_year\", values_to = \"obs_values\"\n  )\nstr(gap_long)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ continent   : chr [1:5112] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country     : chr [1:5112] \"Algeria\" \"Algeria\" \"Algeria\" \"Algeria\" ...\n $ obstype_year: chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values  : num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nThat may seem trivial with this particular data frame, but sometimes you have 1 ID variable and 40 observation variables with irregular variable names. The flexibility is a huge time saver!\nNow obstype_year actually contains 2 pieces of information, the observation type (pop,lifeExp, or gdpPercap) and the year. We can use the separate() function to split the character strings into multiple variables\n\ngap_long <- gap_long %>% separate(obstype_year, into = c('obs_type', 'year'), sep = \"_\")\ngap_long$year <- as.integer(gap_long$year)\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nUsing gap_long, calculate the mean life expectancy, population, and gdpPercap for each continent. *Hint:** use the group_by() and summarize() functions we learned in the dplyr lesson\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\ngap_long %>% group_by(continent, obs_type) %>%\n    summarize(means=mean(obs_values))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 15 × 3\n# Groups:   continent [5]\n   continent obs_type       means\n   <chr>     <chr>          <dbl>\n 1 Africa    gdpPercap     2194. \n 2 Africa    lifeExp         48.9\n 3 Africa    pop        9916003. \n 4 Americas  gdpPercap     7136. \n 5 Americas  lifeExp         64.7\n 6 Americas  pop       24504795. \n 7 Asia      gdpPercap     7902. \n 8 Asia      lifeExp         60.1\n 9 Asia      pop       77038722. \n10 Europe    gdpPercap    14469. \n11 Europe    lifeExp         71.9\n12 Europe    pop       17169765. \n13 Oceania   gdpPercap    18622. \n14 Oceania   lifeExp         74.3\n15 Oceania   pop        8874672."
  },
  {
    "objectID": "14-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "href": "14-tidyr.html#from-long-to-intermediate-format-with-pivot_wider",
    "title": "14  Reshaping data frames with tidyr",
    "section": "14.3 From long to intermediate format with pivot_wider()",
    "text": "14.3 From long to intermediate format with pivot_wider()\nIt is always good to check work. So, let’s use the second pivot function, pivot_wider(), to ‘widen’ our observation variables back out. pivot_wider() is the opposite of pivot_longer(), making a dataset wider by increasing the number of columns and decreasing the number of rows. We can use pivot_wider() to pivot or reshape our gap_long to the original intermediate format or the widest format. Let’s start with the intermediate format.\nThe pivot_wider() function takes names_from and values_from arguments.\nTo names_from we supply the column name whose contents will be pivoted into new output columns in the widened data frame. The corresponding values will be added from the column named in the values_from argument.\n\ngap_normal <- gap_long %>%\n  pivot_wider(names_from = obs_type, values_from = obs_values)\ndim(gap_normal)\n\n[1] 1704    6\n\ndim(gapminder)\n\n[1] 1704    6\n\nnames(gap_normal)\n\n[1] \"continent\" \"country\"   \"year\"      \"gdpPercap\" \"lifeExp\"   \"pop\"      \n\nnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nNow we’ve got an intermediate data frame gap_normal with the same dimensions as the original gapminder, but the order of the variables is different. Let’s fix that before checking if they are all.equal().\n\ngap_normal <- gap_normal[, names(gapminder)]\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n[3] \"Component \\\"country\\\": 1704 string mismatches\"                                         \n[4] \"Component \\\"pop\\\": Mean relative difference: 1.634504\"                                 \n[5] \"Component \\\"continent\\\": 1212 string mismatches\"                                       \n[6] \"Component \\\"lifeExp\\\": Mean relative difference: 0.203822\"                             \n[7] \"Component \\\"gdpPercap\\\": Mean relative difference: 1.162302\"                           \n\nhead(gap_normal)\n\n# A tibble: 6 × 6\n  country  year      pop continent lifeExp gdpPercap\n  <chr>   <int>    <dbl> <chr>       <dbl>     <dbl>\n1 Algeria  1952  9279525 Africa       43.1     2449.\n2 Algeria  1957 10270856 Africa       45.7     3014.\n3 Algeria  1962 11000948 Africa       48.3     2551.\n4 Algeria  1967 12760499 Africa       51.4     3247.\n5 Algeria  1972 14760787 Africa       54.5     4183.\n6 Algeria  1977 17152804 Africa       58.0     4910.\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\nWe’re almost there, the original was sorted by country, then year.\n\ngap_normal <- gap_normal %>% arrange(country, year)\nall.equal(gap_normal, gapminder)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (3, 1) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n\n\nThat’s great! We’ve gone from the longest format back to the intermediate and we didn’t introduce any errors in our code.\nNow let’s convert the long all the way back to the wide. In the wide format, we will keep country and continent as ID variables and pivot the observations across the 3 metrics (pop,lifeExp,gdpPercap) and time (year). First we need to create appropriate labels for all our new variables (time*metric combinations) and we also need to unify our ID variables to simplify the process of defining gap_wide.\n\ngap_temp <- gap_long %>% unite(var_ID, continent, country, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 4] (S3: tbl_df/tbl/data.frame)\n $ var_ID    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ obs_type  : chr [1:5112] \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" \"gdpPercap\" ...\n $ year      : int [1:5112] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\ngap_temp <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\")\nstr(gap_temp)\n\ntibble [5,112 × 3] (S3: tbl_df/tbl/data.frame)\n $ ID_var    : chr [1:5112] \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" \"Africa_Algeria\" ...\n $ var_names : chr [1:5112] \"gdpPercap_1952\" \"gdpPercap_1957\" \"gdpPercap_1962\" \"gdpPercap_1967\" ...\n $ obs_values: num [1:5112] 2449 3014 2551 3247 4183 ...\n\n\nUsing unite() we now have a single ID variable which is a combination of continent,country,and we have defined variable names. We’re now ready to pipe in pivot_wider()\n\ngap_wide_new <- gap_long %>%\n  unite(ID_var, continent, country, sep = \"_\") %>%\n  unite(var_names, obs_type, year, sep = \"_\") %>%\n  pivot_wider(names_from = var_names, values_from = obs_values)\nstr(gap_wide_new)\n\ntibble [142 × 37] (S3: tbl_df/tbl/data.frame)\n $ ID_var        : chr [1:142] \"Africa_Algeria\" \"Africa_Angola\" \"Africa_Benin\" \"Africa_Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nTake this 1 step further and create a gap_ludicrously_wide format data by pivoting over countries, year and the 3 metrics? Hint this new data frame should only have 5 rows.\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\n\ngap_ludicrously_wide <- gap_long %>%\n    unite(var_names, obs_type, year, country, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values)\n\n\n\n\n\n\nNow we have a great ‘wide’ format data frame, but the ID_var could be more usable, let’s separate it into 2 variables with separate()\n\ngap_wide_betterID <- separate(gap_wide_new, ID_var, c(\"continent\", \"country\"), sep=\"_\")\ngap_wide_betterID <- gap_long %>%\n    unite(ID_var, continent, country, sep = \"_\") %>%\n    unite(var_names, obs_type, year, sep = \"_\") %>%\n    pivot_wider(names_from = var_names, values_from = obs_values) %>%\n    separate(ID_var, c(\"continent\",\"country\"), sep = \"_\")\nstr(gap_wide_betterID)\n\ntibble [142 × 38] (S3: tbl_df/tbl/data.frame)\n $ continent     : chr [1:142] \"Africa\" \"Africa\" \"Africa\" \"Africa\" ...\n $ country       : chr [1:142] \"Algeria\" \"Angola\" \"Benin\" \"Botswana\" ...\n $ gdpPercap_1952: num [1:142] 2449 3521 1063 851 543 ...\n $ gdpPercap_1957: num [1:142] 3014 3828 960 918 617 ...\n $ gdpPercap_1962: num [1:142] 2551 4269 949 984 723 ...\n $ gdpPercap_1967: num [1:142] 3247 5523 1036 1215 795 ...\n $ gdpPercap_1972: num [1:142] 4183 5473 1086 2264 855 ...\n $ gdpPercap_1977: num [1:142] 4910 3009 1029 3215 743 ...\n $ gdpPercap_1982: num [1:142] 5745 2757 1278 4551 807 ...\n $ gdpPercap_1987: num [1:142] 5681 2430 1226 6206 912 ...\n $ gdpPercap_1992: num [1:142] 5023 2628 1191 7954 932 ...\n $ gdpPercap_1997: num [1:142] 4797 2277 1233 8647 946 ...\n $ gdpPercap_2002: num [1:142] 5288 2773 1373 11004 1038 ...\n $ gdpPercap_2007: num [1:142] 6223 4797 1441 12570 1217 ...\n $ lifeExp_1952  : num [1:142] 43.1 30 38.2 47.6 32 ...\n $ lifeExp_1957  : num [1:142] 45.7 32 40.4 49.6 34.9 ...\n $ lifeExp_1962  : num [1:142] 48.3 34 42.6 51.5 37.8 ...\n $ lifeExp_1967  : num [1:142] 51.4 36 44.9 53.3 40.7 ...\n $ lifeExp_1972  : num [1:142] 54.5 37.9 47 56 43.6 ...\n $ lifeExp_1977  : num [1:142] 58 39.5 49.2 59.3 46.1 ...\n $ lifeExp_1982  : num [1:142] 61.4 39.9 50.9 61.5 48.1 ...\n $ lifeExp_1987  : num [1:142] 65.8 39.9 52.3 63.6 49.6 ...\n $ lifeExp_1992  : num [1:142] 67.7 40.6 53.9 62.7 50.3 ...\n $ lifeExp_1997  : num [1:142] 69.2 41 54.8 52.6 50.3 ...\n $ lifeExp_2002  : num [1:142] 71 41 54.4 46.6 50.6 ...\n $ lifeExp_2007  : num [1:142] 72.3 42.7 56.7 50.7 52.3 ...\n $ pop_1952      : num [1:142] 9279525 4232095 1738315 442308 4469979 ...\n $ pop_1957      : num [1:142] 10270856 4561361 1925173 474639 4713416 ...\n $ pop_1962      : num [1:142] 11000948 4826015 2151895 512764 4919632 ...\n $ pop_1967      : num [1:142] 12760499 5247469 2427334 553541 5127935 ...\n $ pop_1972      : num [1:142] 14760787 5894858 2761407 619351 5433886 ...\n $ pop_1977      : num [1:142] 17152804 6162675 3168267 781472 5889574 ...\n $ pop_1982      : num [1:142] 20033753 7016384 3641603 970347 6634596 ...\n $ pop_1987      : num [1:142] 23254956 7874230 4243788 1151184 7586551 ...\n $ pop_1992      : num [1:142] 26298373 8735988 4981671 1342614 8878303 ...\n $ pop_1997      : num [1:142] 29072015 9875024 6066080 1536536 10352843 ...\n $ pop_2002      : num [1:142] 31287142 10866106 7026113 1630347 12251209 ...\n $ pop_2007      : num [1:142] 33333216 12420476 8078314 1639131 14326203 ...\n\nall.equal(gap_wide, gap_wide_betterID)\n\n[1] \"Attributes: < Component \\\"class\\\": Lengths (1, 3) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\""
  },
  {
    "objectID": "14-tidyr.html#other-great-resources",
    "href": "14-tidyr.html#other-great-resources",
    "title": "14  Reshaping data frames with tidyr",
    "section": "14.4 Other great resources",
    "text": "14.4 Other great resources\n\nR for Data Science\nData Wrangling Cheat sheet\nIntroduction to tidyr\nData wrangling with R and RStudio"
  },
  {
    "objectID": "13-plot-ggplot2.html#layers",
    "href": "13-plot-ggplot2.html#layers",
    "title": "13  Data visualization with ggplot2",
    "section": "13.1 Layers",
    "text": "13.1 Layers\nUsing a scatterplot probably isn’t the best for visualizing change over time. Instead, let’s tell ggplot to visualize the data as a line plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, color=continent)) +\n  geom_line()\n\n\n\n\nInstead of adding a geom_point layer, we’ve added a geom_line layer.\nHowever, the result doesn’t look quite as we might have expected: it seems to be jumping around a lot in each continent. Let’s try to separate the data by country, plotting one line for each country:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line()\n\n\n\n\nWe’ve added the group aesthetic, which tells ggplot to draw a line for each country.\nBut what if we want to visualize both lines and points on the plot? We can add another layer to the plot:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country, color=continent)) +\n  geom_line() + geom_point()\n\n\n\n\nIt’s important to note that each layer is drawn on top of the previous layer. In this example, the points have been drawn on top of the lines. Here’s a demonstration:\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_line(mapping = aes(color=continent)) + geom_point()\n\n\n\n\nIn this example, the aesthetic mapping of color has been moved from the global plot options in ggplot to the geom_line layer so it no longer applies to the points. Now we can clearly see that the points are drawn on top of the lines.\n\n\n\n\n\n\nTip: Setting an aesthetic to a value instead of a mapping\n\n\n\nSo far, we’ve seen how to use an aesthetic (such as color) as a mapping to a variable in the data. For example, when we use geom_line(mapping = aes(color=continent)), ggplot will give a different color to each continent. But what if we want to change the color of all lines to blue? You may think that geom_line(mapping = aes(color=\"blue\")) should work, but it doesn’t. Since we don’t want to create a mapping to a specific variable, we can move the color specification outside of the aes() function, like this: geom_line(color=\"blue\").\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSwitch the order of the point and line layers from the previous example. What happened?\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nThe lines now get drawn over the points!\n\nggplot(data = gapminder, mapping = aes(x=year, y=lifeExp, group=country)) +\n  geom_point() + geom_line(mapping = aes(color=continent))\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The plot illustrates the possibilities for styling visualisations in ggplot2 with data points enlarged, coloured orange, and displayed without transparency."
  },
  {
    "objectID": "13-plot-ggplot2.html#transformations-and-statistics",
    "href": "13-plot-ggplot2.html#transformations-and-statistics",
    "title": "13  Data visualization with ggplot2",
    "section": "13.2 Transformations and statistics",
    "text": "13.2 Transformations and statistics\nggplot2 also makes it easy to overlay statistical models over the data. To demonstrate we’ll go back to our first example:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nCurrently it’s hard to see the relationship between the points due to some strong outliers in GDP per capita. We can change the scale of units on the x axis using the scale functions. These control the mapping between the data values and visual values of an aesthetic. We can also modify the transparency of the points, using the alpha function, which is especially helpful when you have a large amount of data which is very clustered.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10()\n\n\n\n\nScatterplot of GDP vs life expectancy showing logarithmic x-axis data spread\n\n\n\n\nThe scale_x_log10 function applied a transformation to the coordinate system of the plot, so that each multiple of 10 is evenly spaced from left to right. For example, a GDP per capita of 1,000 is the same horizontal distance away from a value of 10,000 as the 10,000 value is from 100,000. This helps to visualize the spread of the data along the x-axis.\n\n\n\n\n\n\nTip Reminder: Setting an aesthetic to a value instead of a mapping\n\n\n\nNotice that we used geom_point(alpha = 0.5). As the previous tip mentioned, using a setting outside of the aes() function will cause this value to be used for all points, which is what we want in this case. But just like any other aesthetic setting, alpha can also be mapped to a variable in the data. For example, we can give a different transparency to each continent with geom_point(mapping = aes(alpha = continent)).\n\n\nWe can fit a simple relationship to the data by adding another layer, geom_smooth:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a blue trend line summarising the relationship between variables, and gray shaded area indicating 95% confidence intervals for that trend line.\n\n\n\n\nWe can make the line thicker by setting the size aesthetic in the geom_smooth layer:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + scale_x_log10() + geom_smooth(method=\"lm\", size=1.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The blue trend line is slightly thicker than in the previous figure.\n\n\n\n\nThere are two ways an aesthetic can be specified. Here we set the size aesthetic by passing it as an argument to geom_smooth. Previously in the lesson we’ve used the aes function to define a mapping between data variables and their visual representation.\n\n\n\n\n\n\nChallenge 4a\n\n\n\nModify the color and size of the points on the point layer in the previous example. Hint: do not use the aes function.\n\n\n\n\n\n\nSolution to challenge 4a\n\n\n\n\n\nHere a possible solution:\nNotice that the color argument is supplied outside of the aes() function. This means that it applies to all data points on the graph and is not related to a specific variable.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\ngeom_point(size = 3, color = \"orange\") + scale_x_log10() +\ngeom_smooth(method = \"lm\", size = 1.5)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4b\n\n\n\nModify your solution to Challenge 4a so that the points are now a different shape and are colored by continent with new trendlines. Hint: The color argument can be used inside the aesthetic.\n\n\n\n\n\n\nSolution to challenge 4b\n\n\n\n\n\nHere is a possible solution:\nNotice that supplying the color argument inside the aes() functions enables you to connect it to a certain variable. The shape argument, as you can see, modifies all data points the same way (it is outside the aes() call) while the color argument which is placed inside the aes() call modifies a point’s color based on its continent value.\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\ngeom_point(size=3, shape=17) + scale_x_log10() +\ngeom_smooth(method=\"lm\", size=1.5)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "13-plot-ggplot2.html#multi-panel-figures",
    "href": "13-plot-ggplot2.html#multi-panel-figures",
    "title": "13  Data visualization with ggplot2",
    "section": "13.3 Multi-panel figures",
    "text": "13.3 Multi-panel figures\nEarlier we visualized the change in life expectancy over time across all countries in one plot. Alternatively, we can split this out over multiple panels by adding a layer of facet panels.\n\n\n\n\n\n\nTip\n\n\n\nWe start by making a subset of data including only countries located in the Americas. This includes 25 countries, which will begin to clutter the figure. Note that we apply a “theme” definition to rotate the x-axis labels to maintain readability. Nearly everything in ggplot2 is customizable.\n\n\n\namericas <- gapminder[gapminder$continent == \"Americas\",]\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThe facet_wrap layer took a “formula” as its argument, denoted by the tilde (~). This tells R to draw a panel for each unique value in the country column of the gapminder dataset."
  },
  {
    "objectID": "13-plot-ggplot2.html#modifying-text",
    "href": "13-plot-ggplot2.html#modifying-text",
    "title": "13  Data visualization with ggplot2",
    "section": "13.4 Modifying text",
    "text": "13.4 Modifying text\nTo clean this figure up for a publication we need to change some of the text elements. The x-axis is too cluttered, and the y axis should read “Life expectancy”, rather than the column name in the data frame.\nWe can do this by adding a couple of different layers. The theme layer controls the axis text, and overall text size. Labels for the axes, plot title and any legend can be set using the labs function. Legend titles are set using the same names we used in the aes specification. Thus below the color legend title is set using color = \"Continent\", while the title of a fill legend would be set using fill = \"MyTitle\".\n\nggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))"
  },
  {
    "objectID": "13-plot-ggplot2.html#exporting-the-plot",
    "href": "13-plot-ggplot2.html#exporting-the-plot",
    "title": "13  Data visualization with ggplot2",
    "section": "13.5 Exporting the plot",
    "text": "13.5 Exporting the plot\nThe ggsave() function allows you to export a plot created with ggplot. You can specify the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi) to create high quality graphics for publication. In order to save the plot from above, we first assign it to a variable lifeExp_plot, then tell ggsave to save that plot in png format to a directory called results. (Make sure you have a results/ folder in your working directory.)\n\n\n\n\nlifeExp_plot <- ggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\nggsave(filename = \"results/lifeExp.png\", plot = lifeExp_plot, width = 12, height = 10, dpi = 300, units = \"cm\")\n\nThere are two nice things about ggsave. First, it defaults to the last plot, so if you omit the plot argument it will automatically save the last plot you created with ggplot. Secondly, it tries to determine the format you want to save your plot in from the file extension you provide for the filename (for example .png or .pdf). If you need to, you can specify the format explicitly in the device argument.\nThis is a taste of what you can do with ggplot2. RStudio provides a really useful cheat sheet of the different layers available, and more extensive documentation is available on the ggplot2 website. Finally, if you have no idea how to change something, a quick Google search will usually send you to a relevant question and answer on Stack Overflow with reusable code to modify!\n\n\n\n\n\n\nChallenge 5\n\n\n\nGenerate boxplots to compare life expectancy between the different continents during the available years.\nAdvanced:\n\nRename y axis as Life Expectancy.\nRemove x axis labels.\n\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nHere a possible solution:\nxlab() and ylab() set labels for the x and y axes, respectively The axis title, text and ticks are attributes of the theme and must be modified within a theme() call.\n\nggplot(data = gapminder, mapping = aes(x = continent, y = lifeExp, fill = continent)) +\ngeom_boxplot() + facet_wrap(~year) +\nylab(\"Life Expectancy\") +\ntheme(axis.title.x=element_blank(),\n      axis.text.x = element_blank(),\n      axis.ticks.x = element_blank())"
  },
  {
    "objectID": "13-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "href": "13-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "title": "13  Data visualization with ggplot2",
    "section": "13.6 Combining dplyr and ggplot2",
    "text": "13.6 Combining dplyr and ggplot2\nNote, however, that if you installed and loaded the tidyverse above, then you will already have installed and loaded ggplot2.\nIn the plotting lesson we looked at how to make a multi-panel figure by adding a layer of facet panels using ggplot2. Here is the code we used (with some extra comments):\n\n# Filter countries located in the Americas\namericas <- gapminder[gapminder$continent == \"Americas\", ]\n# Make the plot\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThis code makes the right plot but it also creates an intermediate variable (americas) that we might not have any other uses for. Just as we used |> to pipe data along a chain of dplyr functions we can use it to pass data to ggplot(). Because |> replaces the first argument in a function we don’t need to specify the data = argument in the ggplot() function. By combining dplyr and ggplot2 functions we can make the same figure without creating any new variables or modifying the data.\n\ngapminder |>\n  # Filter countries located in the Americas\n  filter(continent == \"Americas\") |>\n  # Make the plot\n  ggplot(mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nMore examples of using the function mutate() and the ggplot2 package.\n\ngapminder |>\n  # extract first letter of country name into new column\n  mutate(startsWith = substr(country, 1, 1)) |>\n  # only keep countries starting with A or Z\n  filter(startsWith %in% c(\"A\", \"Z\")) |>\n  # plot lifeExp into facets\n  ggplot(aes(x = year, y = lifeExp, colour = continent)) +\n  geom_line() +\n  facet_wrap(vars(country)) +\n  theme_minimal()"
  },
  {
    "objectID": "12-iteration.html#repeating-operations",
    "href": "12-iteration.html#repeating-operations",
    "title": "12  Iteration with for loops and map functions",
    "section": "12.1 Repeating operations",
    "text": "12.1 Repeating operations\nIf you want to iterate over a set of values, when the order of iteration is important, and perform the same operation on each, one way to do this is using a for() loop.\nIn general, the advice of many R users would be to learn about for() loops, but to avoid using for() loops unless the order of iteration is important: i.e. the calculation at each iteration depends on the results of previous iterations.\nThe basic structure of a for() loop is:\n\nfor (iterator in set of values) {\n  do a thing\n}\n\nFor example:\n\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\n\nx <- c()\nfor (i in 1:10) {\n  x[i] <- exp(i)\n}\nx\n\n [1]     2.718282     7.389056    20.085537    54.598150   148.413159\n [6]   403.428793  1096.633158  2980.957987  8103.083928 22026.465795\n\n\nThe 1:10 bit creates a vector on the fly; you can iterate over any other vector as well.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor loops are common in programming in general, for loops are rarely used in R, primarily due to their computational inefficiency.\nInstead, a much more efficient method for iterating in R is using the map() functions from the purrr R package. To load the purrr R package, you need to run the following code (if the purrr package is not installed, you will need to run the commented install.packages() line)\n\n# install.packages(\"purrr\")\nlibrary(purrr)\n\nThe first argument from the map() function is the object that we want to iterate over. The second argument is the function that we want to apply at each iteration. The output of the map() function is always a list.\nFor example, the following code will apply the exp() function to each entry in the vector 1:10 and return the results in a list:\n\nmap(1:10, exp)\n\n[[1]]\n[1] 2.718282\n\n[[2]]\n[1] 7.389056\n\n[[3]]\n[1] 20.08554\n\n[[4]]\n[1] 54.59815\n\n[[5]]\n[1] 148.4132\n\n[[6]]\n[1] 403.4288\n\n[[7]]\n[1] 1096.633\n\n[[8]]\n[1] 2980.958\n\n[[9]]\n[1] 8103.084\n\n[[10]]\n[1] 22026.47\n\n\nSince lists are unwieldy, there are several versions of the map() function, such as map_dbl() that specifies the type of your output. For instance, if you want your output to be a numeric “double” vector, you can use map_dbl():\n\nmap_dbl(1:10, exp)\n\n [1]     2.718282     7.389056    20.085537    54.598150   148.413159\n [6]   403.428793  1096.633158  2980.957987  8103.083928 22026.465795\n\n\nand if you want it to be a character vector, you can use map_chr():\n\nmap_chr(gapminder, class)\n\n    country        year         pop   continent     lifeExp   gdpPercap \n\"character\"   \"integer\"   \"numeric\" \"character\"   \"numeric\"   \"numeric\" \n\n\nHere, recall that the gapminder data frame is a list, and the map_ function is iterating over the elements of the list, which in this case is the columns.\nNote that the output of the function you are applying must match the map_ function that you use, else you will get an error:\n\nmap_dbl(1:10, class)\n\nError in `map_dbl()`:\nℹ In index: 1.\nCaused by error:\n! Can't coerce from a string to a double vector.\n\n\nThe true power from the map functions really comes once you learn how to write your own functions (see future lesson on functions).\n\n\n\n\n\n\nChallenge 2 (advanced)\n\n\n\nFor each numeric column in the gapminder dataset, print the number of unique entries using the length() and unique() function.\nDo this in two different ways: using a for loop and a map() function.\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nnumeric_columns <- is.numeric(gapminder)\nfor (i in 1:ncol(gapminder)) {\n  print(mean(gapminder[, i]))\n}\n\nWarning in mean.default(gapminder[, i]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n[1] 1979.5\n[1] 29601212\n\n\nWarning in mean.default(gapminder[, i]): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n[1] 59.47444\n[1] 7215.327\n\n\n\nmap(gapminder, mean)\n\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n\nWarning in mean.default(.x[[i]], ...): argument is not numeric or logical:\nreturning NA\n\n\n$country\n[1] NA\n\n$year\n[1] 1979.5\n\n$pop\n[1] 29601212\n\n$continent\n[1] NA\n\n$lifeExp\n[1] 59.47444\n\n$gdpPercap\n[1] 7215.327\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nModify the script from Challenge 3 to loop over each country. This time print out whether the life expectancy is smaller than 50, between 50 and 70, or greater than 70.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nWe modify our solution to Challenge 3 by now adding two thresholds, lowerThreshold and upperThreshold and extending our if-else statements:\n\nlowerThreshold <- 50\nupperThreshold <- 70\nfor (iCountry in unique(gapminder$country)) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if(tmp < lowerThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", lowerThreshold, \"\\n\")\n   } else if(tmp > lowerThreshold && tmp < upperThreshold) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is between\", lowerThreshold, \"and\", upperThreshold, \"\\n\")\n   } else {\n       cat(\"Average Life Expectancy in\", iCountry, \"is greater than\", upperThreshold, \"\\n\")\n   }\n   rm(tmp)\n}\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5 - Advanced\n\n\n\nWrite a script that loops over each country in the gapminder dataset, tests whether the country starts with a ‘B’, and graphs life expectancy against time as a line graph if the mean life expectancy is under 50 years.\n\n\n\n\n\n\nSolution for Challenge 5\n\n\n\n\n\nWe will use the grep() command that was introduced in the Unix Shell lesson to find countries that start with “B.” Lets understand how to do this first. Following from the Unix shell section we may be tempted to try the following\n\ngrep(\"^B\", unique(gapminder$country))\n\nBut when we evaluate this command it returns the indices of the factor variable country that start with “B.” To get the values, we must add the value = TRUE option to the grep() command:\n\ngrep(\"^B\", unique(gapminder$country), value = TRUE)\n\nWe will now store these countries in a variable called candidateCountries, and then loop over each entry in the variable. Inside the loop, we evaluate the average life expectancy for each country, and if the average life expectancy is less than 50 we use base-plot to plot the evolution of average life expectancy using with() and subset():\n\nthresholdValue <- 50\ncandidateCountries <- grep(\"^B\", unique(gapminder$country), value = TRUE)\nfor (iCountry in candidateCountries) {\n   tmp <- mean(gapminder[gapminder$country == iCountry, \"lifeExp\"])\n   if (tmp < thresholdValue) {\n       cat(\"Average Life Expectancy in\", iCountry, \"is less than\", thresholdValue, \"plotting life expectancy graph... \\n\")\n       with(subset(gapminder, country == iCountry),\n               plot(year, lifeExp,\n                    type = \"o\",\n                    main = paste(\"Life Expectancy in\", iCountry, \"over time\"),\n                    ylab = \"Life Expectancy\",\n                    xlab = \"Year\"\n                    ) # end plot\n            ) # end with\n   } # end if\n   rm(tmp)\n} # end for loop"
  },
  {
    "objectID": "11-if.html#if-statements",
    "href": "11-if.html#if-statements",
    "title": "11  If statements",
    "section": "11.1 “If” statements",
    "text": "11.1 “If” statements\nThere are several ways you can control flow in R. For conditional statements, the most commonly used approaches are the constructs:\n\n# if\nif (condition is true) {\n  perform action\n}\n\n# if ... else\nif (condition is true) {\n  perform action\n} else {  # that is, if the condition is false,\n  perform alternative action\n}\n\nSay, for example, that we want R to print a message if a variable x has a particular value:\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n}\n\nThe print statement does not appear in the console because x (8) is not greater than 10. To print a different message for numbers less than 10, we can add an else statement.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else {\n  print(\"x is less than 10\")\n}\n\n[1] \"x is less than 10\"\n\n\nYou can also test multiple conditions by using else if.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else if (x > 5) {\n  print(\"x is greater than 5, but less than 10\")\n} else {\n  print(\"x is less than 5\")\n}\n\n[1] \"x is greater than 5, but less than 10\"\n\n\nImportant: when R evaluates the condition inside if() statements, it is looking for a logical value (TRUE or FALSE).\n\n\n\n\n\n\nIf statements in functions\n\n\n\nIf statements might not seem all that useful on their own, but they are incredibly useful for writing functions (as we will learn in the next lesson).\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nUse an if() statement to print a suitable message reporting whether there are any records from 2002 in the gapminder dataset.\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\nWe first obtain a logical vector describing which element of gapminder$year is equal to 2002:\n\nif (2002 %in% gapminder$year) {\n  print(\"Record(s) for the year 2002 found.\")\n}\n\n[1] \"Record(s) for the year 2002 found.\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: A common error with if() statements\n\n\n\nA common error with if() statements looks like:\n\n\nError in if (gapminder$year == 2012) {: the condition has length > 1\n\n\nThe if() function only accepts singular (of length 1) inputs, and therefore returns an error when you supply it with a vector.\nThe if() function will still run, but will only evaluate the condition in the first element of the vector.\nTherefore, to use the if() function, you need to make sure your input is a single value (of length 1), rather than a vector."
  },
  {
    "objectID": "10-functions.html#defining-a-function",
    "href": "10-functions.html#defining-a-function",
    "title": "10  Functions",
    "section": "10.1 Defining a function",
    "text": "10.1 Defining a function\nIf you haven’t already, create a functions/ directory in the same folder as your working quarto file.\nOpen a new R script file and call it functions-lesson.R and save it in the functions/ directory.\nThe general structure of a function is:\n\nmy_function <- function(parameters) {\n  # perform action\n  # return value\n}\n\nLet’s define a function fahr_to_kelvin() that converts temperatures from Fahrenheit to Kelvin:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nThe list of arguments that the function takes are contained within the parentheses in function(args).\nNext, the body of the function–the statements that are executed when it runs–is contained within curly braces ({}). The statements in the body are indented by two spaces. This makes the code easier to read but does not affect how the code operates.\nIt is useful to think of creating functions like writing a cookbook. First you define the “ingredients” that your function needs. In this case, we only need one ingredient to use our function: “temp”. After we list our ingredients, we then say what we will do with them, in this case, we are taking our ingredient and applying a set of mathematical operators to it.\nWhen we call the function, the values we pass to it as arguments are assigned to those variables so that we can use them inside the function. Inside the function, we use a to output a result when the function is used.\n\n\n\n\n\n\nReturn statements\n\n\n\nOne feature unique to R is that the return statement is not required.\nR automatically returns whichever variable is on the last line of the body of the function. But for clarity, we will explicitly define the return statement.\n\n\nLet’s try running our function. Calling our own function is no different from calling any other function:\n\n# freezing point of water\nfahr_to_kelvin(32)\n\n[1] 273.15\n\n\n\n# boiling point of water\nfahr_to_kelvin(212)\n\n[1] 373.15\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nWrite a function called kelvin_to_celsius() that takes a temperature in Kelvin and returns that temperature in Celsius. Hint: To convert from Kelvin to Celsius you subtract 273.15\n\n\n\n\n\n\nSolution to challenge 1\n\n\n\n\n\nWrite a function called kelvin_to_celsius that takes a temperature in Kelvin and returns that temperature in Celsius\n\nkelvin_to_celsius <- function(temp) {\ncelsius <- temp - 273.15\nreturn(celsius)\n}"
  },
  {
    "objectID": "10-functions.html#combining-functions",
    "href": "10-functions.html#combining-functions",
    "title": "10  Functions",
    "section": "10.2 Combining functions",
    "text": "10.2 Combining functions\nThe real power of functions comes from mixing, matching and combining them into ever-larger chunks to get the effect we want.\nLet’s define two functions that will convert temperature from Fahrenheit to Kelvin, and Kelvin to Celsius:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nkelvin_to_celsius <- function(temp) {\n  celsius <- temp - 273.15\n  return(celsius)\n}\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nDefine the function to convert directly from Fahrenheit to Celsius, using the two functions above.\n\n\n\n\n\n\nSolution to challenge 2\n\n\n\n\n\nDefine the function to convert directly from Fahrenheit to Celsius, by reusing these two functions above\n\nfahr_to_celsius <- function(temp) {\n temp_k <- fahr_to_kelvin(temp)\n result <- kelvin_to_celsius(temp_k)\n return(result)\n}"
  },
  {
    "objectID": "10-functions.html#interlude-defensive-programming",
    "href": "10-functions.html#interlude-defensive-programming",
    "title": "10  Functions",
    "section": "10.3 Interlude: Defensive Programming",
    "text": "10.3 Interlude: Defensive Programming\nNow that we’ve begun to appreciate how writing functions provides an efficient way to make R code re-usable and modular, we should note that it is important to ensure that functions only work in their intended use-cases. Checking function parameters is related to the concept of defensive programming. Defensive programming encourages us to frequently check conditions and throw an error if something is wrong. These checks are referred to as assertion statements because we want to assert some condition is TRUE before proceeding. They make it easier to debug because they give us a better idea of where the errors originate.\n\n10.3.1 Checking conditions with stop()\nLet’s start by re-examining fahr_to_kelvin(), our function for converting temperatures from Fahrenheit to Kelvin. It was defined like so:\n\nfahr_to_kelvin <- function(temp) {\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nFor this function to work as intended, the argument temp must be a numeric value; otherwise, the mathematical procedure for converting between the two temperature scales will not work.\nTo create an error, we can use the function stop(). For example, since the argument temp must be a numeric vector, we could check for this condition with an if statement and throw an error if the condition was violated. We could augment our function above like so:\n\nfahr_to_kelvin <- function(temp) {\n  if (!is.numeric(temp)) {\n    stop(\"temp must be a numeric vector.\")\n  }\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\n\nfahr_to_kelvin(\"one\")\n\nError in fahr_to_kelvin(\"one\"): temp must be a numeric vector.\n\n\n\n\n\n\n\n\n“If” statements\n\n\n\nThere are several ways you can control flow in R. For conditional statements, the most commonly used approaches are the constructs:\n\n# if\nif (condition is true) {\n  perform action\n}\n\n# if ... else\nif (condition is true) {\n  perform action\n} else {  # that is, if the condition is false,\n  perform alternative action\n}\n\nSay, for example, that we want R to print a message if a variable x has a particular value:\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n}\n\nThe print statement does not appear in the console because x (8) is not greater than 10. To print a different message for numbers less than 10, we can add an else statement.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else {\n  print(\"x is less than 10\")\n}\n\n[1] \"x is less than 10\"\n\n\nYou can also test multiple conditions by using else if.\n\nx <- 8\n\nif (x >= 10) {\n  print(\"x is greater than or equal to 10\")\n} else if (x > 5) {\n  print(\"x is greater than 5, but less than 10\")\n} else {\n  print(\"x is less than 5\")\n}\n\n[1] \"x is greater than 5, but less than 10\"\n\n\nImportant: when R evaluates the condition inside if() statements, it is looking for a logical value (TRUE or FALSE).\n\n\nIf we had multiple conditions or arguments to check, it would take many lines of code to check all of them. Luckily R provides the convenience function stopifnot(). We can list as many requirements that should evaluate to TRUE; stopifnot() throws an error if it finds one that is FALSE. Listing these conditions also serves a secondary purpose as extra documentation for the function.\nLet’s try out defensive programming with stopifnot() by adding assertions to check the input to our function fahr_to_kelvin().\nWe want to assert the following: temp is a numeric vector. We may do that like so:\n\nfahr_to_kelvin <- function(temp) {\n  stopifnot(is.numeric(temp))\n  kelvin <- ((temp - 32) * (5 / 9)) + 273.15\n  return(kelvin)\n}\n\nIt still works when given proper input.\n\n# freezing point of water\nfahr_to_kelvin(temp = 32)\n\n[1] 273.15\n\n\nBut fails instantly if given improper input.\n\n# Metric is a factor instead of numeric\nfahr_to_kelvin(temp = \"a\")\n\nError in fahr_to_kelvin(temp = \"a\"): is.numeric(temp) is not TRUE\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nEdit our fahr_to_celsius() function so that it throws an error immediately if the argument temp is non-numeric. Test that your error message works as expected.\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nExtend our previous definition of the function by adding in an explicit call to stopifnot(). Since fahr_to_celsius() is a composition of two other functions, checking inside here makes adding checks to the two component functions redundant.\n\nfahr_to_celsius <- function(temp) {\n stopifnot(is.numeric(temp))\n temp_k <- fahr_to_kelvin(temp)\n result <- kelvin_to_celsius(temp_k)\n return(result)\n}"
  },
  {
    "objectID": "10-functions.html#more-on-combining-functions",
    "href": "10-functions.html#more-on-combining-functions",
    "title": "10  Functions",
    "section": "10.4 More on combining functions",
    "text": "10.4 More on combining functions\nNow, we’re going to define a function that calculates the Gross Domestic Product of a nation from the data available in our dataset:\n\n# Takes a dataset and multiplies the population column\n# with the GDP per capita column.\ncalcGDP <- function(dat) {\n  gdp <- dat$pop * dat$gdpPercap\n  return(gdp)\n}\n\nWe define calcGDP() by assigning it to the output of function. The list of argument names are contained within parentheses. Next, the body of the function – the statements executed when you call the function – is contained within curly braces ({}).\nWe’ve indented the statements in the body by two spaces. This makes the code easier to read but does not affect how it operates.\nWhen we call the function, the values we pass to it are assigned to the arguments, which become variables inside the body of the function.\nInside the function, we use the return() function to send back the result. This return() function is optional: R will automatically return the results of whatever command is executed on the last line of the function.\n\ncalcGDP(head(gapminder))\n\n[1]  6567086330  7585448670  8758855797  9648014150  9678553274 11697659231\n\n\nThat’s not very informative. Let’s add some more arguments so we can extract that per year and country.\n\n# Takes a dataset and multiplies the population column\n# with the GDP per capita column.\ncalcGDP <- function(dat, year=NULL, country=NULL) {\n  if(!is.null(year)) {\n    dat <- dat[dat$year %in% year, ]\n  }\n  if (!is.null(country)) {\n    dat <- dat[dat$country %in% country,]\n  }\n  gdp <- dat$pop * dat$gdpPercap\n\n  new <- cbind(dat, gdp=gdp)\n  return(new)\n}\n\nIf you’ve been writing these functions down into a separate R script (a good idea!), you can load in the functions into our R session by using the source() function:\n\nsource(\"functions/functions-lesson.R\")\n\nOk, so there’s a lot going on in this function now. In plain English, the function now subsets the provided data by year if the year argument isn’t empty, then subsets the result by country if the country argument isn’t empty. Then it calculates the GDP for whatever subset emerges from the previous two steps. The function then adds the GDP as a new column to the subsetted data and returns this as the final result. You can see that the output is much more informative than a vector of numbers.\nLet’s take a look at what happens when we specify the year:\n\nhead(calcGDP(gapminder, year = 2007))\n\n       country year      pop continent lifeExp  gdpPercap          gdp\n12 Afghanistan 2007 31889923      Asia  43.828   974.5803  31079291949\n24     Albania 2007  3600523    Europe  76.423  5937.0295  21376411360\n36     Algeria 2007 33333216    Africa  72.301  6223.3675 207444851958\n48      Angola 2007 12420476    Africa  42.731  4797.2313  59583895818\n60   Argentina 2007 40301927  Americas  75.320 12779.3796 515033625357\n72   Australia 2007 20434176   Oceania  81.235 34435.3674 703658358894\n\n\nOr for a specific country:\n\ncalcGDP(gapminder, country = \"Australia\")\n\n     country year      pop continent lifeExp gdpPercap          gdp\n61 Australia 1952  8691212   Oceania  69.120  10039.60  87256254102\n62 Australia 1957  9712569   Oceania  70.330  10949.65 106349227169\n63 Australia 1962 10794968   Oceania  70.930  12217.23 131884573002\n64 Australia 1967 11872264   Oceania  71.100  14526.12 172457986742\n65 Australia 1972 13177000   Oceania  71.930  16788.63 221223770658\n66 Australia 1977 14074100   Oceania  73.490  18334.20 258037329175\n67 Australia 1982 15184200   Oceania  74.740  19477.01 295742804309\n68 Australia 1987 16257249   Oceania  76.320  21888.89 355853119294\n69 Australia 1992 17481977   Oceania  77.560  23424.77 409511234952\n70 Australia 1997 18565243   Oceania  78.830  26997.94 501223252921\n71 Australia 2002 19546792   Oceania  80.370  30687.75 599847158654\n72 Australia 2007 20434176   Oceania  81.235  34435.37 703658358894\n\n\nOr both:\n\ncalcGDP(gapminder, year = 2007, country = \"Australia\")\n\n     country year      pop continent lifeExp gdpPercap          gdp\n72 Australia 2007 20434176   Oceania  81.235  34435.37 703658358894\n\n\nLet’s walk through the body of the function:\n\ncalcGDP <- function(dat, year = NULL, country = NULL) {\n\nHere we’ve added two arguments, year, and country. We’ve set default arguments for both as NULL using the = operator in the function definition. This means that those arguments will take on those values unless the user specifies otherwise.\n\n  if(!is.null(year)) {\n    dat <- dat[dat$year %in% year, ]\n  }\n  if (!is.null(country)) {\n    dat <- dat[dat$country %in% country,]\n  }\n\nHere, we check whether each additional argument is set to null, and whenever they’re not null overwrite the dataset stored in dat with a subset given by the non-null argument.\nBuilding these conditionals into the function makes it more flexible for later. Now, we can use it to calculate the GDP for:\n\nThe whole dataset;\nA single year;\nA single country;\nA single combination of year and country.\n\nBy using %in% instead, we can also give multiple years or countries to those arguments.\n\n\n\n\n\n\nTip: Pass by value\n\n\n\nFunctions in R almost always make copies of the data to operate on inside of a function body. When we modify dat inside the function we are modifying the copy of the gapminder dataset stored in dat, not the original variable we gave as the first argument. This is called “pass-by-value” and it makes writing code much safer: you can always be sure that whatever changes you make within the body of the function, stay inside the body of the function.\n\n\n\n\n\n\n\n\nTip: Function scope\n\n\n\nAnother important concept is scoping: any variables (or functions!) you create or modify inside the body of a function only exist for the lifetime of the function’s execution. When we call calcGDP(), the variables dat, gdp and new only exist inside the body of the function. Even if we have variables of the same name in our interactive R session, they are not modified in any way when executing a function.\n\n\n\n  gdp <- dat$pop * dat$gdpPercap\n  new <- cbind(dat, gdp=gdp)\n  return(new)\n}\n\nFinally, we calculated the GDP on our new subset, and created a new data frame with that column added. This means when we call the function later we can see the context for the returned GDP values, which is much better than in our first attempt where we got a vector of numbers.\n\n\n\n\n\n\nChallenge 4\n\n\n\nTest out your GDP function by calculating the GDP for New Zealand in 1987. How does this differ from New Zealand’s GDP in 1952?\n\n\n\n\n\n\nSolution to challenge 4\n\n\n\n\n\n\n calcGDP(gapminder, year = c(1952, 1987), country = \"New Zealand\")\n\nGDP for New Zealand in 1987: 65050008703 GDP for New Zealand in 1952: 21058193787\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nThe paste() function can be used to combine text together, e.g:\n\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\npaste(best_practice, collapse=\" \")\n\n[1] \"Write programs for people not computers\"\n\n\nWrite a function called fence() that takes two vectors as arguments, called text and wrapper, and prints out the text wrapped with the wrapper:\n\nfence(text=best_practice, wrapper=\"***\")\n\nNote: the paste() function has an argument called sep, which specifies the separator between text. The default is a space: ” “. The default for paste0() is no space”“.\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\nWrite a function called fence() that takes two vectors as arguments, called text and wrapper, and prints out the text wrapped with the wrapper:\n\nfence <- function(text, wrapper){\n text <- c(wrapper, text, wrapper)\n result <- paste(text, collapse = \" \")\n return(result)\n}\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\nfence(text=best_practice, wrapper=\"***\")\n\n[1] \"*** Write programs for people not computers ***\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nR has some unique aspects that can be exploited when performing more complicated operations. We will not be writing anything that requires knowledge of these more advanced concepts. In the future when you are comfortable writing functions in R, you can learn more by reading the R Language Manual or this chapter from Advanced R Programming by Hadley Wickham.\n\n\n\n\n\n\n\n\nTip: Testing and documenting\n\n\n\nIt’s important to both test functions and document them: Documentation helps you, and others, understand what the purpose of your function is, and how to use it, and its important to make sure that your function actually does what you think.\nWhen you first start out, your workflow will probably look a lot like this:\n\nWrite a function\nComment parts of the function to document its behaviour\nLoad in the source file\nExperiment with it in the console to make sure it behaves as you expect\nMake any necessary bug fixes\nRinse and repeat.\n\nFormal documentation for functions, written in separate .Rd files, gets turned into the documentation you see in help files. The roxygen2 package allows R coders to write documentation alongside the function code and then process it into the appropriate .Rd files. You will want to switch to this more formal method of writing documentation when you start writing more complicated R projects. In fact, packages are, in essence, bundles of functions with this formal documentation. Loading your own functions through source(\"functions.R\") is equivalent to loading someone else’s functions (or your own one day!) through library(\"package\").\nFormal automated tests can be written using the testthat package."
  },
  {
    "objectID": "09-lists.html#lists",
    "href": "09-lists.html#lists",
    "title": "9  Lists",
    "section": "9.1 Lists",
    "text": "9.1 Lists\nAnother data structure is the list.\nList are very flexible because you can put anything you want in it: unlike a vector, the elements of a list can have different data types. For example:\n\nlist_example <- list(1, \"a\", TRUE)\nlist_example\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n\nLike a vector, the “length” of a list corresponds to how many entries it contains:\n\nlength(list_example)\n\n[1] 3\n\n\nWhen printing the object structure with str(), we see the data types of all elements:\n\nstr(list_example)\n\nList of 3\n $ : num 1\n $ : chr \"a\"\n $ : logi TRUE\n\n\nTo retrieve one of the elements of a list, we use the double bracket notation:\n\nlist_example[[2]]\n\n[1] \"a\"\n\n\nThe elements of lists also can have names, they can be given by prepending them to the values, separated by an equals sign:\n\nanother_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE)\nanother_list\n\n$title\n[1] \"Numbers\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n[1] TRUE\n\n\nThis results in a named list. Now we have a new function of our object! We can access single elements by an additional way!\n\nanother_list$title\n\n[1] \"Numbers\"\n\n\nas well as using named indexing in the double square bracket notation.\n\nanother_list[[\"title\"]]\n\n[1] \"Numbers\"\n\n\nLists, it turns out, can become a lot more complicated than vectors. While each entry of a vector is just a single value, each entry of a list can be any type of object, including vectors and data frames. For example, the following list of length three contains three entries: a numeric vector, a data frame, and a single character value:\n\n# define the cats data frame:\ncats <- data.frame(coat = c(\"calico\", \"black\", \"tabby\"),\n                   weight = c(2.1, 5.0, 3.2),\n                   likes_string = c(1, 0, 1),\n                   stringsAsFactors = FALSE)\n\n\ncomplicated_list <- list(vec = c(1, 2, 9),\n                         dataframe = cats, \n                         single_value = \"a\")\ncomplicated_list\n\n$vec\n[1] 1 2 9\n\n$dataframe\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n$single_value\n[1] \"a\"\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nCreate a list of length two containing a character vector containing the letters “x”, “y”, “z” and a data frame with two columns that looks like this.\n\n\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\nYour list output should look like this:\n\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\nSolution to Challenge 6\n\n\n\n\n\n\nlist(c(\"x\", \"y\", \"z\"),\n     data.frame(name = c(\"Henry\", \"Hannah\", \"Harvey\"), grade = c(\"A\", \"B\", \"C\")))\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\n9.1.1 Data frames as a special case of a list\nIt turns out that a data frame is a special kind of a list. Specifically, a data frame is a list of vectors of the same length.\nThis is why you can extract vector columns from a data frame using the double brackets notation:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\n\ncats[[\"coat\"]]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nNote that the df[i, j] index notation is specific to data frames (and does not work for lists).\nYou will learn more about extracting information from vectors, lists and data frames in the advanced subsetting lesson.\n\n\n9.1.2 List subsetting\nNow we’ll introduce some new subsetting operators. There are three functions used to subset lists. We’ve already seen these when learning about atomic vectors and matrices: [, [[, and $.\nUsing [ will always return a list. If you want to subset a list, but not extract an element, then you will likely use [.\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist[1]\n\n$a\n[1] \"Software Carpentry\"\n\n\nThis returns a list with one element.\nWe can subset elements of a list exactly the same way as atomic vectors using [. Comparison operations however won’t work as they’re not recursive, they will try to condition on the data structures in each element of the list, not the individual elements within those data structures.\n\nxlist[1:2]\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nTo extract individual elements of a list, you need to use the double-square bracket function: [[.\n\nxlist[[1]]\n\n[1] \"Software Carpentry\"\n\n\nNotice that now the result is a vector, not a list.\nYou can’t extract more than one element at once:\n\nxlist[[1:2]]\n\nError in xlist[[1:2]]: subscript out of bounds\n\n\nNor use it to skip elements:\n\nxlist[[-1]]\n\nError in xlist[[-1]]: invalid negative subscript in get1index <real>\n\n\nBut you can use names to both subset and extract elements:\n\nxlist[[\"a\"]]\n\n[1] \"Software Carpentry\"\n\n\nThe $ function is a shorthand way for extracting elements by name:\n\nxlist$data\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nGiven the following list:\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nUsing list and vector subsetting, extract the second entry in the second element of the list (i.e., extract the number 2 from the b entry from xlist`). There are several ways to do this. Compare your answer with your neighbor. Did you do it the same way?\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\n\nxlist$b[2]\n\n[1] 2\n\n\n\nxlist[[2]][2]\n\n[1] 2\n\n\n\nxlist[[\"b\"]][2]\n\n[1] 2"
  },
  {
    "objectID": "08-dplyr.html#extracting-columns-using-select",
    "href": "08-dplyr.html#extracting-columns-using-select",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.2 Extracting columns using select()",
    "text": "8.2 Extracting columns using select()\nIf, for example, we wanted to move forward with only a few of the variables in our data frame we could use the select() function. The first argument is the data frame and the remaining argument are the names of the columns that you want to keep.\n\nyear_country_gdp <- select(gapminder, year, country, gdpPercap)\nhead(year_country_gdp)\n\n  year     country gdpPercap\n1 1952 Afghanistan  779.4453\n2 1957 Afghanistan  820.8530\n3 1962 Afghanistan  853.1007\n4 1967 Afghanistan  836.1971\n5 1972 Afghanistan  739.9811\n6 1977 Afghanistan  786.1134\n\n\n ::: {.callout-tip} ## Quotes vs no quotes\nUnlike the base R code, df[\"var\"], you usually do not need to enclose the variable names in quotes in most tidyverse functions: you can write select(df, var) rather than select(df, \"var\"). :::\nYou can also use the select() function to rename columns, for example, the following code will rename the gdpPercap column to gdp_per_cap, while selecting only the year, country, and gdp_per_cap columns:\n\ngapminder_selected <- select(gapminder, year, country, gdp_per_cap = gdpPercap)\nhead(gapminder_selected)\n\n  year     country gdp_per_cap\n1 1952 Afghanistan    779.4453\n2 1957 Afghanistan    820.8530\n3 1962 Afghanistan    853.1007\n4 1967 Afghanistan    836.1971\n5 1972 Afghanistan    739.9811\n6 1977 Afghanistan    786.1134\n\n\nIf we want to remove one column only from the gapminder data, we can use the -var syntax. For example, the code below removes the continent column:\n\nsmaller_gapminder_data <- select(gapminder, -continent)\n\nAbove we used ‘normal’ grammar, which places the data frame in the first argument of the dplyr function select(), but the real strength of dplyr lies in combining several functions using pipes."
  },
  {
    "objectID": "08-dplyr.html#filter-to-rows-using-filter",
    "href": "08-dplyr.html#filter-to-rows-using-filter",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.4 Filter to rows using filter()",
    "text": "8.4 Filter to rows using filter()\nIf we only want to look at the European countries in gapminder, we can use the filter() function:\n\ngapminder |> filter(continent == \"Europe\") |> head()\n\n  country year     pop continent lifeExp gdpPercap\n1 Albania 1952 1282697    Europe   55.23  1601.056\n2 Albania 1957 1476505    Europe   59.28  1942.284\n3 Albania 1962 1728137    Europe   64.82  2312.889\n4 Albania 1967 1984060    Europe   66.22  2760.197\n5 Albania 1972 2263554    Europe   67.69  3313.422\n6 Albania 1977 2509048    Europe   68.93  3533.004\n\n\nWe can even chain together select() and filter():\n\nyear_country_gdp_euro <- gapminder |>\n  filter(continent == \"Europe\") |>\n  select(year, country, gdpPercap)\nhead(year_country_gdp_euro)\n\n  year country gdpPercap\n1 1952 Albania  1601.056\n2 1957 Albania  1942.284\n3 1962 Albania  2312.889\n4 1967 Albania  2760.197\n5 1972 Albania  3313.422\n6 1977 Albania  3533.004\n\n\nYou can supply multiple conditions to filter() using a comma. This is equivalent to “and” &, as in only rows where both conditions are satisfied will be returned.\nFor example, if we now want to show life expectancy of European countries but only for a specific year (e.g., 2007), we can do as below.\n\neurope_lifeExp_2007 <- gapminder |>\n  filter(continent == \"Europe\", year == 2007) |>\n  select(country, lifeExp)\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nUse piping to produce a data frame that contains values for lifeExp, country and year for Africa but not for other Continents.\nYour data frame should have 624 rows and 3 columns (you can check this with dim()).\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\nyear_country_lifeExp_Africa <- gapminder |>\n  filter(continent == \"Africa\") |>\n  select(year, country, lifeExp)\nhead(year_country_lifeExp_Africa)\n\n  year country lifeExp\n1 1952 Algeria  43.077\n2 1957 Algeria  45.685\n3 1962 Algeria  48.303\n4 1967 Algeria  51.407\n5 1972 Algeria  54.518\n6 1977 Algeria  58.014\n\n\n\ndim(year_country_lifeExp_Africa)\n\n[1] 624   3\n\n\n\n\n\n\n\nIn the challenge above, first we pass the gapminder data frame to the filter() function, then we pass the filtered version of the gapminder data frame to the select() function. Note: The order of operations is very important in this case. If we used ‘select’ first, filter would not be able to find the variable continent since we would have removed it in the previous step."
  },
  {
    "objectID": "08-dplyr.html#adding-and-modifying-columns-using-mutate",
    "href": "08-dplyr.html#adding-and-modifying-columns-using-mutate",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.5 Adding and modifying columns using mutate()",
    "text": "8.5 Adding and modifying columns using mutate()\nYou can add new columns as well as modify existing columns in a data frame using mutate().\nFor example, the following code will create a new column called gdp_billion which contains the product of gdpPercap and pop columns and divides by 1 billion.\n\ngapminder |>\n  mutate(gdp_billion = gdpPercap * pop / 10^9) |>\n  head()\n\n      country year      pop continent lifeExp gdpPercap gdp_billion\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453    6.567086\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530    7.585449\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007    8.758856\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971    9.648014\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811    9.678553\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134   11.697659\n\n\nYou don’t have to always create a new variable with mutate()– you can instead modify an existing variable. For example, the code below replaces the lifeExp column with the rounded version of lifeExp:\n\ngapminder |>\n  mutate(lifeExp = round(lifeExp)) |>\n  head()\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia      29  779.4453\n2 Afghanistan 1957  9240934      Asia      30  820.8530\n3 Afghanistan 1962 10267083      Asia      32  853.1007\n4 Afghanistan 1967 11537966      Asia      34  836.1971\n5 Afghanistan 1972 13079460      Asia      36  739.9811\n6 Afghanistan 1977 14880372      Asia      38  786.1134\n\n\n\n\n\n\n\n\nCombining mutate() and select() with transmute()\n\n\n\nSometimes you want to both mutate and select at the same time. Rather than doing this in two separate steps, you can do it in one using transmute().\nThe following two code chunks are equivalent:\n\ngapminder |>\n  mutate(gdp_billion = gdpPercap * pop / 10^9) |>\n  select(country, year, gdp_billion) |>\n  head()\n\n      country year gdp_billion\n1 Afghanistan 1952    6.567086\n2 Afghanistan 1957    7.585449\n3 Afghanistan 1962    8.758856\n4 Afghanistan 1967    9.648014\n5 Afghanistan 1972    9.678553\n6 Afghanistan 1977   11.697659\n\n\n\ngapminder |>\n  transmute(country, year, gdp_billion = gdpPercap * pop / 10^9) |>\n  head()\n\n      country year gdp_billion\n1 Afghanistan 1952    6.567086\n2 Afghanistan 1957    7.585449\n3 Afghanistan 1962    8.758856\n4 Afghanistan 1967    9.648014\n5 Afghanistan 1972    9.678553\n6 Afghanistan 1977   11.697659\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nExplain what the following code is trying to do and explain why it doesn’t work. Re-write the code so that it does work:\n\ngapminder |>\n  filter(country == \"Australia\") |>\n  select(year, lifeExp = round(lifeExp))\n\nError in `select()`:\n! Problem while evaluating `round(lifeExp)`.\nCaused by error:\n! object 'lifeExp' not found\n\n\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nThe code doesn’t work because you can’t make modifications to the data inside a select() function.\nYou could fix this in a few ways. The most efficient is using transmute():\n\ngapminder |>\n  filter(country == \"Australia\") |>\n  transmute(year, lifeExp = round(lifeExp))\n\n   year lifeExp\n1  1952      69\n2  1957      70\n3  1962      71\n4  1967      71\n5  1972      72\n6  1977      73\n7  1982      75\n8  1987      76\n9  1992      78\n10 1997      79\n11 2002      80\n12 2007      81\n\n\nBut you could also use mutate() and select() separately\n\ngapminder |>\n  filter(country == \"Australia\") |>\n  select(year, lifeExp) |>\n  mutate(lifeExp = round(lifeExp)) \n\n   year lifeExp\n1  1952      69\n2  1957      70\n3  1962      71\n4  1967      71\n5  1972      72\n6  1977      73\n7  1982      75\n8  1987      76\n9  1992      78\n10 1997      79\n11 2002      80\n12 2007      81"
  },
  {
    "objectID": "08-dplyr.html#creating-column-summaries-using-summarize",
    "href": "08-dplyr.html#creating-column-summaries-using-summarize",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.6 Creating column summaries using summarize()",
    "text": "8.6 Creating column summaries using summarize()\nYou can easily compute a “summary” of a column using summarize(). For example, the following code computes the max life expectancy in the data:\n\ngapminder |>\n  summarize(max_life_exp = max(lifeExp))\n\n  max_life_exp\n1       82.603\n\n\nYou can even compute multiple summaries at once, e.g., computing both the max and minimum of the lifeExp variable:\n\ngapminder |>\n  summarize(max_life_exp = max(lifeExp),\n            min_life_exp = min(lifeExp))\n\n  max_life_exp min_life_exp\n1       82.603       23.599"
  },
  {
    "objectID": "08-dplyr.html#grouped-computations-with-group_by",
    "href": "08-dplyr.html#grouped-computations-with-group_by",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.7 Grouped computations with group_by()",
    "text": "8.7 Grouped computations with group_by()\nNow, we were supposed to be reducing the error prone repetitiveness of what can be done with base R, but up to now we haven’t done that since we would have to repeat the above for each continent.\nOne way to compute the mean lifeExp for each continent using dplyr functions would be:\n\ngapminder |> filter(continent == \"Europe\") |> summarise(mean(lifeExp))\n\n  mean(lifeExp)\n1      71.90369\n\ngapminder |> filter(continent == \"Africa\") |> summarise(mean(lifeExp))\n\n  mean(lifeExp)\n1      48.86533\n\ngapminder |> filter(continent == \"Asia\") |> summarise(mean(lifeExp))\n\n  mean(lifeExp)\n1       60.0649\n\ngapminder |> filter(continent == \"Americas\") |> summarise(mean(lifeExp))\n\n  mean(lifeExp)\n1      64.65874\n\ngapminder |> filter(continent == \"Oceania\") |> summarise(mean(lifeExp))\n\n  mean(lifeExp)\n1      74.32621\n\n\nBut this is very repetitive and is not in line with the tidyverse way of doing things!\nThe group_by() function offers a nice alternative approach for grouped operations on a data frame:\n\ngapminder |>\n  group_by(continent) |>\n  summarize(mean(lifeExp)) \n\n# A tibble: 5 × 2\n  continent `mean(lifeExp)`\n  <chr>               <dbl>\n1 Africa               48.9\n2 Americas             64.7\n3 Asia                 60.1\n4 Europe               71.9\n5 Oceania              74.3\n\n\nThe group_by() function essentially splits the data frame into separate data frames to perform the computation, and then joins the result back into a single data frame.\n\n\n\nDiagram illustrating how the group by function oraganizes a data frame into groups\n\n\nMoreover, group_by() doesn’t work just with summarize. Can you figure out what the following code is doing?\n\ngapminder |>\n  group_by(continent) |>\n  mutate(mean_lifeExp = mean(lifeExp)) |>\n  ungroup()\n\n# A tibble: 1,704 × 7\n   country      year      pop continent lifeExp gdpPercap mean_lifeExp\n   <chr>       <int>    <dbl> <chr>       <dbl>     <dbl>        <dbl>\n 1 Afghanistan  1952  8425333 Asia         28.8      779.         60.1\n 2 Afghanistan  1957  9240934 Asia         30.3      821.         60.1\n 3 Afghanistan  1962 10267083 Asia         32.0      853.         60.1\n 4 Afghanistan  1967 11537966 Asia         34.0      836.         60.1\n 5 Afghanistan  1972 13079460 Asia         36.1      740.         60.1\n 6 Afghanistan  1977 14880372 Asia         38.4      786.         60.1\n 7 Afghanistan  1982 12881816 Asia         39.9      978.         60.1\n 8 Afghanistan  1987 13867957 Asia         40.8      852.         60.1\n 9 Afghanistan  1992 16317921 Asia         41.7      649.         60.1\n10 Afghanistan  1997 22227415 Asia         41.8      635.         60.1\n# … with 1,694 more rows\n\n\n\n\n\n\n\n\nTip: ungrouping\n\n\n\nNote that it is good practice to follow any grouped operation with ungroup() since this prevents further downstream operations from also being grouped.\n\n\n\n\n\n\n\n\nTip: tibbles\n\n\n\nYou might have noticed that the object above is a “tibble”. A tibble is the tidyverse’s version of a data frame. For all intents and purposes, tibbles and data frames are completely equivalent. It is only once you get into very advanced tidyverse programming will you start to see the features that tibbles possess that data frames don’t, such as list columns.\n\n\n\n8.7.1 Grouping by multiple variables\nThe function group_by() allows us to group by multiple variables. For example, let’s group by year and continent and compute the mean gdpPercap for each year-continent combination:\n\ngapminder |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap)) |> \n  ungroup() |>\n  head()\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 6 × 3\n  continent  year mean_gdpPercap\n  <chr>     <int>          <dbl>\n1 Africa     1952          1253.\n2 Africa     1957          1385.\n3 Africa     1962          1598.\n4 Africa     1967          2050.\n5 Africa     1972          2340.\n6 Africa     1977          2586.\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nUse group_by(), summarise(), and filter() to identify which country has the longest average life expectancy and which has the shortest average life expectancy.\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nOne way to do this is to as\n\ngapminder |>\n  group_by(country) |>\n  summarize(mean_lifeExp = mean(lifeExp)) |>\n  ungroup() |>\n  filter(mean_lifeExp == min(mean_lifeExp) | mean_lifeExp == max(mean_lifeExp))\n\n# A tibble: 2 × 2\n  country      mean_lifeExp\n  <chr>               <dbl>\n1 Iceland              76.5\n2 Sierra Leone         36.8"
  },
  {
    "objectID": "08-dplyr.html#ordering-the-rows-in-a-data-frame-using-arrange",
    "href": "08-dplyr.html#ordering-the-rows-in-a-data-frame-using-arrange",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.8 Ordering the rows in a data frame using arrange()",
    "text": "8.8 Ordering the rows in a data frame using arrange()\nAnother way to do complete the previous challenge is to use the dplyr function arrange(), which arranges the rows in a data frame according to the order of one or more variables from the data frame. It has similar syntax to other functions from the dplyr package. You can use desc() inside arrange() to sort in descending order.\nFirst we can compute the average life expectancy for each country\n\nlifeExp_bycountry <- gapminder |>\n  group_by(country) |>\n  summarise(mean_lifeExp = mean(lifeExp)) |>\n  ungroup()\n\nThen we can arrange the data frame in order of the average life expectancy for each country to view the countries with the lowest average life expectancy\n\nlifeExp_bycountry |>\n  arrange(mean_lifeExp) |>\n  head()\n\n# A tibble: 6 × 2\n  country       mean_lifeExp\n  <chr>                <dbl>\n1 Sierra Leone          36.8\n2 Afghanistan           37.5\n3 Angola                37.9\n4 Guinea-Bissau         39.2\n5 Mozambique            40.4\n6 Somalia               41.0\n\n\nTo view the countries with the highest life expectancy, we can use the desc() function inside arrange() (or we can view the tail() of the previous data frame):\n\nlifeExp_bycountry |>\n  arrange(desc(mean_lifeExp)) |>\n  head()\n\n# A tibble: 6 × 2\n  country     mean_lifeExp\n  <chr>              <dbl>\n1 Iceland             76.5\n2 Sweden              76.2\n3 Norway              75.8\n4 Netherlands         75.6\n5 Switzerland         75.6\n6 Canada              74.9\n\n\n\n\n\n\n\n\nArranging by a character variable\n\n\n\nApplying arrange() to a character variable will present the rows in alphabetical order."
  },
  {
    "objectID": "08-dplyr.html#the-pipe",
    "href": "08-dplyr.html#the-pipe",
    "title": "8  Data Frame Manipulation with dplyr",
    "section": "8.3 The pipe |>",
    "text": "8.3 The pipe |>\nSince the pipes grammar is unlike anything we’ve seen in R before, let’s repeat what we’ve done above using pipes.\n\nyear_country_gdp <- gapminder |> select(year, country, gdpPercap)\n\nTo help you understand why we wrote that in that way, let’s walk through it step by step.\nFirst we summon the gapminder data frame and pass it on, using the pipe symbol |>, to the first argument in the function on the right hand side of the pipe, which is the select() function.\nSo the two pieces of code are equivalent.\n\nselect(gapminder, year)\n\n\ngapminder |> select(year)\n\n\n\n\n\n\n\nTwo pipes: |> vs %>%\n\n\n\nYou might sometimes see the pipe written as %>%, rather than |>.\n%>% is the “old” version of the pipe that was first introduced in the magrittr R package (and is also loaded with the dplyr package).\nRecently, a native pipe |> has been introduced to the base R language, and moving forward it is this new native pipe that we will use. The two pipes behave very similarly, with only minor differences (such as |> requires parentheses for functions with no arguments).\n\n\nThe pipe doesn’t only work with select(). The pipe can be used for every R function. For example, the following are equivalent:\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\ngapminder |> head()\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\nSo are these two:\n\nmean(c(1, 5, 3))\n\n[1] 3\n\nc(1, 5, 3) |> mean()\n\n[1] 3\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nRewrite the following code using the pipe:\n\n\n\n\nselect(gapminder, -continent)\n\n\n\n\n\nhead(select(gapminder, life_exp = lifeExp, gdp_per_cap = gdpPercap))\n\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\ngapminder |> select(-continent)\n\n\ngapminder |>\n  select(life_exp = lifeExp, gdp_per_cap = gdpPercap) |> \n  head()\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Renaming data frame columns in dplyr\n\n\n\nIn an earlier lesson, we covered how you can rename columns with base R by assigning a value to the output of the names() function. While this works just fine, dplyr has a rename() function that makes this even easier.\nWithin a pipeline, the syntax is rename(new_name = old_name). For example, we may want to rename the gdpPercap column name from our select() statement above.\n\ntidy_gdp <- year_country_gdp |> rename(gdp_per_capita = gdpPercap)\nhead(tidy_gdp)\n\n  year     country gdp_per_capita\n1 1952 Afghanistan       779.4453\n2 1957 Afghanistan       820.8530\n3 1962 Afghanistan       853.1007\n4 1967 Afghanistan       836.1971\n5 1972 Afghanistan       739.9811\n6 1977 Afghanistan       786.1134\n\n\n\n\n\n\n\n\n\n\nTip: rename() vs select()\n\n\n\nWe saw above that we can use select() to rename columns, but this also requires us to specify which columns to include in the output.\n\ngapminder |>\n  select(gdp_per_capita = gdpPercap) |>\n  head()\n\n  gdp_per_capita\n1       779.4453\n2       820.8530\n3       853.1007\n4       836.1971\n5       739.9811\n6       786.1134\n\n\nrename() however, will automatically return all columns, while renaming the specified column:\n\ngapminder |>\n  rename(gdp_per_capita = gdpPercap) |>\n  head()\n\n      country year      pop continent lifeExp gdp_per_capita\n1 Afghanistan 1952  8425333      Asia  28.801       779.4453\n2 Afghanistan 1957  9240934      Asia  30.332       820.8530\n3 Afghanistan 1962 10267083      Asia  31.997       853.1007\n4 Afghanistan 1967 11537966      Asia  34.020       836.1971\n5 Afghanistan 1972 13079460      Asia  36.088       739.9811\n6 Afghanistan 1977 14880372      Asia  38.438       786.1134"
  },
  {
    "objectID": "11-lists.html#lists",
    "href": "11-lists.html#lists",
    "title": "11  Lists",
    "section": "11.1 Lists",
    "text": "11.1 Lists\nAnother data structure is the list.\nList are very flexible because you can put anything you want in it: unlike a vector, the elements of a list can have different data types. For example:\n\nlist_example <- list(1, \"a\", TRUE)\nlist_example\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n\nLike a vector, the “length” of a list corresponds to how many entries it contains:\n\nlength(list_example)\n\n[1] 3\n\n\nWhen printing the object structure with str(), we see the data types of all elements:\n\nstr(list_example)\n\nList of 3\n $ : num 1\n $ : chr \"a\"\n $ : logi TRUE\n\n\nTo retrieve one of the elements of a list, we use the double bracket notation:\n\nlist_example[[2]]\n\n[1] \"a\"\n\n\nThe elements of lists also can have names, they can be given by prepending them to the values, separated by an equals sign:\n\nanother_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE)\nanother_list\n\n$title\n[1] \"Numbers\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n[1] TRUE\n\n\nThis results in a named list. Now we have a new function of our object! We can access single elements by an additional way!\n\nanother_list$title\n\n[1] \"Numbers\"\n\n\nas well as using named indexing in the double square bracket notation.\n\nanother_list[[\"title\"]]\n\n[1] \"Numbers\"\n\n\nLists, it turns out, can become a lot more complicated than vectors. While each entry of a vector is just a single value, each entry of a list can be any type of object, including vectors and data frames. For example, the following list of length three contains three entries: a numeric vector, a data frame, and a single character value:\n\n# define the cats data frame:\ncats <- data.frame(coat = c(\"calico\", \"black\", \"tabby\"),\n                   weight = c(2.1, 5.0, 3.2),\n                   likes_string = c(1, 0, 1),\n                   stringsAsFactors = FALSE)\n\n\ncomplicated_list <- list(vec = c(1, 2, 9),\n                         dataframe = cats, \n                         single_value = \"a\")\ncomplicated_list\n\n$vec\n[1] 1 2 9\n\n$dataframe\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n$single_value\n[1] \"a\"\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nCreate a list of length two containing a (1) character vector containing the letters “x”, “y”, “z” and (2) a data frame with two columns that looks like this.\n\n\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\nYour list output should look like this:\n\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\nSolution to Challenge 6\n\n\n\n\n\n\nlist(c(\"x\", \"y\", \"z\"),\n     data.frame(name = c(\"Henry\", \"Hannah\", \"Harvey\"), grade = c(\"A\", \"B\", \"C\")))\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\n11.1.1 Data frames as a special case of a list\nIt turns out that a data frame is a special kind of a list. Specifically, a data frame is a list of vectors of the same length.\nThis is why you can extract vector columns from a data frame using the double brackets notation:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\n\ncats[[\"coat\"]]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nNote that the df[i, j] index notation is specific to data frames (and does not work for lists).\n\n\n11.1.2 List subsetting\nNow we’ll introduce some new subsetting operators. There are three functions used to subset lists. We’ve already seen these when learning about atomic vectors and matrices: [, [[, and $.\nUsing [ will always return a list. If you want to subset a list, but not extract an element, then you will likely use [.\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist[1]\n\n$a\n[1] \"Software Carpentry\"\n\n\nThis returns a list with one element.\nWe can subset elements of a list exactly the same way as atomic vectors using [. Comparison operations however won’t work as they’re not recursive, they will try to condition on the data structures in each element of the list, not the individual elements within those data structures.\n\nxlist[1:2]\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nTo extract individual elements of a list, you need to use the double-square bracket function: [[.\n\nxlist[[1]]\n\n[1] \"Software Carpentry\"\n\n\nNotice that now the result is a vector, not a list.\nYou can’t extract more than one element at once:\n\nxlist[[1:2]]\n\nError in xlist[[1:2]]: subscript out of bounds\n\n\nNor use it to skip elements:\n\nxlist[[-1]]\n\nError in xlist[[-1]]: invalid negative subscript in get1index <real>\n\n\nBut you can use names to both subset and extract elements:\n\nxlist[[\"a\"]]\n\n[1] \"Software Carpentry\"\n\n\nThe $ function is a shorthand way for extracting elements by name:\n\nxlist$data\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nGiven the following list:\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nUsing list and vector subsetting, extract the second entry in the second element of the list (i.e., extract the number 2 from the b entry from xlist`). There are several ways to do this. Compare your answer with your neighbor. Did you do it the same way?\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\n\nxlist$b[2]\n\n[1] 2\n\n\n\nxlist[[2]][2]\n\n[1] 2\n\n\n\nxlist[[\"b\"]][2]\n\n[1] 2"
  },
  {
    "objectID": "09-plot-ggplot2.html#layers",
    "href": "09-plot-ggplot2.html#layers",
    "title": "9  Data visualization with ggplot2",
    "section": "9.1 Layers",
    "text": "9.1 Layers\nUsing a scatterplot probably isn’t the best for visualizing change over time. Instead, let’s tell ggplot to visualize the data as a line plot (dropping the argument names for brevity):\n\nggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +\n  geom_line()\n\n\n\n\nInstead of adding a geom_point layer, we’ve added a geom_line layer.\nHowever, the result doesn’t look quite as we might have expected: it seems to be jumping around a lot in each continent. This is because we haven’t told ggplot2 to plot a separate line for each country. We can do that by adding a group argument inside the aes() function:\n\nggplot(gapminder, aes(x = year, y = lifeExp, color = continent, group = country)) +\n  geom_line()\n\n\n\n\nThe group aesthetic tells ggplot to draw a line for each country.\nBut what if we want to visualize both lines and points on the plot? We can add another layer to the plot:\n\nggplot(gapminder, aes(x = year, y = lifeExp, group = country, color = continent)) +\n  geom_line() + \n  geom_point()\n\n\n\n\nIt’s important to note that each layer is drawn on top of the previous layer. In this example, the points have been drawn on top of the lines. Here’s a demonstration:\n\nggplot(gapminder, aes(x = year, y = lifeExp, group = country)) +\n  geom_line(aes(color = continent)) + geom_point()\n\n\n\n\nIn this example, the aesthetic mapping of color has been moved from the global plot options in ggplot to the geom_line layer so it no longer applies to the points layer. Now we can clearly see that the points are drawn on top of the lines.\n\n\n\n\n\n\nTip: Setting an aesthetic to a value instead of a mapping\n\n\n\nSo far, we’ve seen how to use an aesthetic (such as color) as a mapping to a variable in the data. For example, when we use geom_line(aes(color = continent)), ggplot will give a different color to each continent.\nBut what if we want to change the color of all lines to blue?\nYou may think that aes(color=\"blue\") should work, but it doesn’t.\n\nggplot(gapminder) +\n  geom_line(aes(x = year, y = lifeExp, group = country, color = \"blue\")) \n\n\n\n\nSince we don’t want to create a mapping to a specific variable from our data frame, we need to move the color specification outside of the aes() function, like this: geom_line(color=\"blue\").\n\nggplot(gapminder) +\n  geom_line(aes(x = year, y = lifeExp, group = country), color = \"blue\") \n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nSwitch the order of the point and line layers from the previous example. What happens?\n\n\n\n\n\n\nSolution to challenge 3\n\n\n\n\n\nThe lines now get drawn over the points!\n\nggplot(gapminder, aes(x = year, y = lifeExp, group = country)) +\n  geom_point() + \n  geom_line(mapping = aes(color = continent))\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The plot illustrates the possibilities for styling visualisations in ggplot2 with data points enlarged, coloured orange, and displayed without transparency."
  },
  {
    "objectID": "09-plot-ggplot2.html#transformations-and-statistics",
    "href": "09-plot-ggplot2.html#transformations-and-statistics",
    "title": "9  Data visualization with ggplot2",
    "section": "9.2 Transformations and statistics",
    "text": "9.2 Transformations and statistics\nggplot2 also makes it easy to overlay statistical models over the data. To demonstrate we’ll go back to our earlier example:\n\nggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nCurrently it’s hard to see the relationship between the points due to some strong outliers in GDP per capita. We can change the scale of units on the x axis using the scale functions. These control the mapping between the data values and visual values of an aesthetic.\nWe can also modify the transparency of the points, using the alpha function, which is especially helpful when you have a large amount of data which is very clustered.\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + \n  scale_x_log10()\n\n\n\n\nScatterplot of GDP vs life expectancy showing logarithmic x-axis data spread\n\n\n\n\nThe scale_x_log10() function applied a transformation to the coordinate system of the plot, so that each multiple of 10 is evenly spaced from left to right. For example, a GDP per capita of 1,000 is the same horizontal distance away from a value of 10,000 as the 10,000 value is from 100,000. This helps to visualize the spread of the data along the x-axis.\n\n\n\n\n\n\nTip Reminder: Setting an aesthetic to a value instead of a mapping\n\n\n\nNotice that we used geom_point(alpha = 0.5). As the previous tip mentioned, using a setting outside of the aes() function will cause this value to be used for all points, which is what we want in this case. But just like any other aesthetic setting, alpha can also be mapped to a variable in the data. For example, we can give a different transparency to each continent with geom_point(mapping = aes(alpha = continent)).\n\n\nWe can also fit a simple relationship to the data by adding another layer, geom_smooth():\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  scale_x_log10() \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a blue trend line summarising the relationship between variables, and gray shaded area indicating 95% confidence intervals for that trend line.\n\n\n\n\nWe can make the line thicker by setting the linewidth aesthetic in the geom_smooth layer:\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + \n  geom_smooth(method = \"lm\", linewidth = 1.5) +\n  scale_x_log10() \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot of life expectancy vs GDP per capita with a trend line summarising the relationship between variables. The blue trend line is slightly thicker than in the previous figure.\n\n\n\n\n\n\n\n\n\n\nChallenge 4a\n\n\n\nIn the previous example, uniformly set the color of all points to “orange” and the size of all points to 3.\nHint: do this outside the aes function.\n\n\n\n\n\n\nSolution to challenge 4a\n\n\n\n\n\nHere a possible solution:\nNotice that the color and size arguments are supplied outside of the aes() function.\nThis means that it applies to all data points on the graph and is not related to a specific variable.\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  # set size and color\n  geom_point(size = 3, color = \"orange\") + \n  geom_smooth(method = \"lm\", size = 1.5) +\n  scale_x_log10() \n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4b\n\n\n\nModify your solution to Challenge 4a so that the color of the points is determined by the continent variable and the size is determined by the pop variable.\nHint: The color and size arguments must now be used inside the aesthetic.\n\n\n\n\n\n\nSolution to challenge 4b\n\n\n\n\n\nHere is a possible solution:\nNotice that supplying the color and size arguments inside the aes() functions enables you to connect it to a certain variable.\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  # set size and color\n  geom_point(aes(size = pop, color = continent)) + \n  geom_smooth(method = \"lm\", size = 1.5) +\n  scale_x_log10() \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nSupplying the size and color arguments inside the ggplot() function will also apply them to the geom_smooth() layer."
  },
  {
    "objectID": "09-plot-ggplot2.html#multi-panel-figures",
    "href": "09-plot-ggplot2.html#multi-panel-figures",
    "title": "9  Data visualization with ggplot2",
    "section": "9.3 Multi-panel figures",
    "text": "9.3 Multi-panel figures\nEarlier we visualized the change in life expectancy over time across all countries in one plot like this:\n\nggplot(gapminder, aes(x = year, y = lifeExp, color = continent, group = country)) +\n  geom_line()\n\n\n\n\nAnother way to view this data is to split this out over multiple panels by adding a layer of facet panels.\nSince there are a lot of countries, we will first filter just to the “Americas”:\n\ngapminder |> \n  filter(continent == \"Americas\") |>\n  ggplot() +\n  geom_line(aes(x = year, y = lifeExp)) +\n  # make a separate plot for each country in the facet\n  facet_wrap(~country) +\n  # set the x-axis angle to 45 degrees\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\nThe facet_wrap layer took a “formula” as its argument, denoted by the tilde (~). This tells R to draw a panel for each unique value in the country column of the gapminder dataset."
  },
  {
    "objectID": "09-plot-ggplot2.html#modifying-text",
    "href": "09-plot-ggplot2.html#modifying-text",
    "title": "9  Data visualization with ggplot2",
    "section": "9.4 Modifying text",
    "text": "9.4 Modifying text\nTo clean this figure up for a publication we need to change some of the text elements. The x-axis is too cluttered, and the y axis should read “Life expectancy”, rather than the column name in the data frame.\nWe can do this by adding a couple of different layers. The theme layer controls the axis text, and overall text size. Labels for the axes, plot title and any legend can be set using the labs function. Legend titles are set using the same names we used in the aes specification. Thus below the color legend title is set using color = \"Continent\", while the title of a fill legend would be set using fill = \"MyTitle\".\n\nggplot(data = americas, mapping = aes(x = year, y = lifeExp, color=continent)) +\n  geom_line() + facet_wrap( ~ country) +\n  labs(\n    x = \"Year\",              # x axis title\n    y = \"Life expectancy\",   # y axis title\n    title = \"Figure 1\",      # main title of figure\n    color = \"Continent\"      # title of legend\n  ) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))"
  },
  {
    "objectID": "09-plot-ggplot2.html#exporting-the-plot",
    "href": "09-plot-ggplot2.html#exporting-the-plot",
    "title": "9  Data visualization with ggplot2",
    "section": "9.6 Exporting the plot",
    "text": "9.6 Exporting the plot\nThe ggsave() function allows you to export a plot created with ggplot. You can specify the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi) to create high quality graphics for publication. In order to save the plot from above, we first assign it to a variable lifeExp_plot, then tell ggsave to save that plot in png format to a directory called results. (Make sure you have a results/ folder in your working directory.)\n\n\n\n\nfacet_plot <- gapminder |> \n  filter(continent == \"Americas\") |>\n  ggplot() +\n  geom_line(aes(x = year, y = lifeExp)) +\n  # make a separate plot for each country in the facet\n  facet_wrap(~country) +\n  labs(x = \"Year\",              \n       y = \"Life expectancy\",   \n       title = \"Life expectency by year in the Americas\") +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\nggsave(filename = \"results/lifeExp.png\", plot = facet_plot, width = 12, height = 10, dpi = 300, units = \"cm\")\n\nThere are two nice things about ggsave. First, it defaults to the last plot, so if you omit the plot argument it will automatically save the last plot you created with ggplot. Secondly, it tries to determine the format you want to save your plot in from the file extension you provide for the filename (for example .png or .pdf). If you need to, you can specify the format explicitly in the device argument.\nThis is a taste of what you can do with ggplot2.\nRStudio provides a really useful cheat sheet of the different layers available, and more extensive documentation is available on the ggplot2 website. Finally, if you have no idea how to change something, a quick Google search will usually send you to a relevant question and answer on Stack Overflow with reusable code to modify!"
  },
  {
    "objectID": "09-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "href": "09-plot-ggplot2.html#combining-dplyr-and-ggplot2",
    "title": "9  Data visualization with ggplot2",
    "section": "9.6 Combining dplyr and ggplot2",
    "text": "9.6 Combining dplyr and ggplot2\nNote, however, that if you installed and loaded the tidyverse above, then you will already have installed and loaded ggplot2.\nIn the plotting lesson we looked at how to make a multi-panel figure by adding a layer of facet panels using ggplot2. Here is the code we used (with some extra comments):\n\n# Filter countries located in the Americas\namericas <- gapminder[gapminder$continent == \"Americas\", ]\n# Make the plot\nggplot(data = americas, mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nThis code makes the right plot but it also creates an intermediate variable (americas) that we might not have any other uses for. Just as we used |> to pipe data along a chain of dplyr functions we can use it to pass data to ggplot(). Because |> replaces the first argument in a function we don’t need to specify the data = argument in the ggplot() function. By combining dplyr and ggplot2 functions we can make the same figure without creating any new variables or modifying the data.\n\ngapminder |>\n  # Filter countries located in the Americas\n  filter(continent == \"Americas\") |>\n  # Make the plot\n  ggplot(mapping = aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap( ~ country) +\n  theme(axis.text.x = element_text(angle = 45))\n\n\n\n\nMore examples of using the function mutate() and the ggplot2 package.\n\ngapminder |>\n  # extract first letter of country name into new column\n  mutate(startsWith = substr(country, 1, 1)) |>\n  # only keep countries starting with A or Z\n  filter(startsWith %in% c(\"A\", \"Z\")) |>\n  # plot lifeExp into facets\n  ggplot(aes(x = year, y = lifeExp, colour = continent)) +\n  geom_line() +\n  facet_wrap(vars(country)) +\n  theme_minimal()"
  },
  {
    "objectID": "12-lists.html#lists",
    "href": "12-lists.html#lists",
    "title": "12  Lists",
    "section": "12.1 Lists",
    "text": "12.1 Lists\nAnother data structure is the list.\nList are very flexible because you can put anything you want in it: unlike a vector, the elements of a list can have different data types. For example:\n\nlist_example <- list(1, \"a\", TRUE)\nlist_example\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n\nLike a vector, the “length” of a list corresponds to how many entries it contains:\n\nlength(list_example)\n\n[1] 3\n\n\nWhen printing the object structure with str(), we see the data types of all elements:\n\nstr(list_example)\n\nList of 3\n $ : num 1\n $ : chr \"a\"\n $ : logi TRUE\n\n\nTo retrieve one of the elements of a list, we use the double bracket notation:\n\nlist_example[[2]]\n\n[1] \"a\"\n\n\nThe elements of lists also can have names, they can be given by prepending them to the values, separated by an equals sign:\n\nanother_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE)\nanother_list\n\n$title\n[1] \"Numbers\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n[1] TRUE\n\n\nThis results in a named list. Now we have a new function of our object! We can access single elements by an additional way!\n\nanother_list$title\n\n[1] \"Numbers\"\n\n\nas well as using named indexing in the double square bracket notation.\n\nanother_list[[\"title\"]]\n\n[1] \"Numbers\"\n\n\nLists, it turns out, can become a lot more complicated than vectors. While each entry of a vector is just a single value, each entry of a list can be any type of object, including vectors and data frames. For example, the following list of length three contains three entries: a numeric vector, a data frame, and a single character value:\n\n# define the cats data frame:\ncats <- data.frame(coat = c(\"calico\", \"black\", \"tabby\"),\n                   weight = c(2.1, 5.0, 3.2),\n                   likes_string = c(1, 0, 1),\n                   stringsAsFactors = FALSE)\n\n\ncomplicated_list <- list(vec = c(1, 2, 9),\n                         dataframe = cats, \n                         single_value = \"a\")\ncomplicated_list\n\n$vec\n[1] 1 2 9\n\n$dataframe\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n$single_value\n[1] \"a\"\n\n\n\n\n\n\n\n\nChallenge 6\n\n\n\nCreate a list of length two containing a (1) character vector containing the letters “x”, “y”, “z” and (2) a data frame with two columns that looks like this.\n\n\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\nYour list output should look like this:\n\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\nSolution to Challenge 6\n\n\n\n\n\n\nlist(c(\"x\", \"y\", \"z\"),\n     data.frame(name = c(\"Henry\", \"Hannah\", \"Harvey\"), grade = c(\"A\", \"B\", \"C\")))\n\n[[1]]\n[1] \"x\" \"y\" \"z\"\n\n[[2]]\n    name grade\n1  Henry     A\n2 Hannah     B\n3 Harvey     C\n\n\n\n\n\n\n\n\n12.1.1 Data frames as a special case of a list\nIt turns out that a data frame is a special kind of a list. Specifically, a data frame is a list of vectors of the same length.\nThis is why you can extract vector columns from a data frame using the double brackets notation:\n\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\n\ncats[[\"coat\"]]\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nNote that the df[i, j] index notation is specific to data frames (and does not work for lists).\n\n\n12.1.2 List subsetting\nNow we’ll introduce some new subsetting operators. There are three functions used to subset lists. We’ve already seen these when learning about atomic vectors and matrices: [, [[, and $.\nUsing [ will always return a list. If you want to subset a list, but not extract an element, then you will likely use [.\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist[1]\n\n$a\n[1] \"Software Carpentry\"\n\n\nThis returns a list with one element.\nWe can subset elements of a list exactly the same way as atomic vectors using [. Comparison operations however won’t work as they’re not recursive, they will try to condition on the data structures in each element of the list, not the individual elements within those data structures.\n\nxlist[1:2]\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nTo extract individual elements of a list, you need to use the double-square bracket function: [[.\n\nxlist[[1]]\n\n[1] \"Software Carpentry\"\n\n\nNotice that now the result is a vector, not a list.\nYou can’t extract more than one element at once:\n\nxlist[[1:2]]\n\nError in xlist[[1:2]]: subscript out of bounds\n\n\nNor use it to skip elements:\n\nxlist[[-1]]\n\nError in xlist[[-1]]: invalid negative subscript in get1index <real>\n\n\nBut you can use names to both subset and extract elements:\n\nxlist[[\"a\"]]\n\n[1] \"Software Carpentry\"\n\n\nThe $ function is a shorthand way for extracting elements by name:\n\nxlist$data\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nGiven the following list:\n\nxlist <- list(a = \"Software Carpentry\", b = 1:10, data = head(mtcars))\nxlist\n\n$a\n[1] \"Software Carpentry\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nUsing list and vector subsetting, extract the second entry in the second element of the list (i.e., extract the number 2 from the b entry from xlist`). There are several ways to do this. Compare your answer with your neighbor. Did you do it the same way?\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\n\nxlist$b[2]\n\n[1] 2\n\n\n\nxlist[[2]][2]\n\n[1] 2\n\n\n\nxlist[[\"b\"]][2]\n\n[1] 2"
  },
  {
    "objectID": "09-plot-ggplot2.html#modifying-labels",
    "href": "09-plot-ggplot2.html#modifying-labels",
    "title": "9  Data visualization with ggplot2",
    "section": "9.4 Modifying labels",
    "text": "9.4 Modifying labels\nTo clean this figure up for a publication we need to change some of the text elements. The x-axis is too cluttered, and the y axis should read “Life expectancy”, rather than the column name in the data frame.\nWe can do this by adding a couple of different layers. The theme layer controls the axis text, and overall text size. Labels for the axes, plot title and any legend can be set using the labs function.\n\ngapminder |> \n  filter(continent == \"Americas\") |>\n  ggplot() +\n  geom_line(aes(x = year, y = lifeExp)) +\n  # make a separate plot for each country in the facet\n  facet_wrap(~country) +\n  labs(x = \"Year\",              \n       y = \"Life expectancy\",   \n       title = \"Life expectency by year in the Americas\") +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nUsing geom_boxplot(), generate boxplots to compare life expectancy between the different continents, faceted by year. Color each boxplot by continent and rename each label so that it is nicely formatted and human-readable.\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nHere a possible solution:\n\ngapminder |> \n  ggplot(aes(x = continent, y = lifeExp, fill = continent)) +\n  geom_boxplot() + \n  facet_wrap(~year) +\n  labs(x = \"Continent\",\n       y = \"Life Expectancy\",\n       fill = \"Continent\") +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))"
  },
  {
    "objectID": "09-plot-ggplot2.html#built-in-themes",
    "href": "09-plot-ggplot2.html#built-in-themes",
    "title": "9  Data visualization with ggplot2",
    "section": "9.5 Built-in themes",
    "text": "9.5 Built-in themes\nThere are several themes for making your plots even prettier. For example,\n\ntheme_classic():\n\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(size = pop, color = continent)) +\n  scale_x_log10()  +\n  theme_classic()\n\n\n\n\n\ntheme_minimal():\n\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(size = pop, color = continent)) +\n  scale_x_log10()  +\n  theme_minimal()\n\n\n\n\n\ntheme_bw():\n\n\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(size = pop, color = continent)) +\n  scale_x_log10()  +\n  theme_bw()"
  },
  {
    "objectID": "10-functions.html#an-advanced-example",
    "href": "10-functions.html#an-advanced-example",
    "title": "10  Functions",
    "section": "10.4 An advanced example",
    "text": "10.4 An advanced example\nThe following function takes the gapminder data frame, and computes the GDP (in billions), while filtering to a specified year and country if specified.\n\n# Takes a dataset and multiplies the population column\n# with the GDP per capita column.\ncalcGDP <- function(dat, .year = NULL, .country = NULL) {\n  \n  if(!is.null(.year)) {\n    dat <- dat |> filter(year %in% .year)\n  }\n  if (!is.null(.country)) {\n    dat <- dat |> filter(country %in% .country)\n  }\n  \n  dat <- dat |>\n    transmute(country, year, gdp = pop * gdpPercap / 1e9)\n  \n  return(dat)\n}\n\nIf you’ve been writing these functions down into a separate R script (a good idea!), you can load in the functions into our R session by using the source() function:\n\nsource(\"functions/functions-lesson.R\")\n\nIf we don’t specify a .year or .country argument, our function returns all rows of the gapminder data.\n\ncalcGDP(gapminder) |>\n  head()\n\n      country year       gdp\n1 Afghanistan 1952  6.567086\n2 Afghanistan 1957  7.585449\n3 Afghanistan 1962  8.758856\n4 Afghanistan 1967  9.648014\n5 Afghanistan 1972  9.678553\n6 Afghanistan 1977 11.697659\n\n\nLet’s take a look at what happens when we specify the year:\n\nhead(calcGDP(gapminder, .year = 2007))\n\n      country year       gdp\n1 Afghanistan 2007  31.07929\n2     Albania 2007  21.37641\n3     Algeria 2007 207.44485\n4      Angola 2007  59.58390\n5   Argentina 2007 515.03363\n6   Australia 2007 703.65836\n\n\nOr for a specific country:\n\ncalcGDP(gapminder, .country = \"Australia\")\n\n     country year       gdp\n1  Australia 1952  87.25625\n2  Australia 1957 106.34923\n3  Australia 1962 131.88457\n4  Australia 1967 172.45799\n5  Australia 1972 221.22377\n6  Australia 1977 258.03733\n7  Australia 1982 295.74280\n8  Australia 1987 355.85312\n9  Australia 1992 409.51123\n10 Australia 1997 501.22325\n11 Australia 2002 599.84716\n12 Australia 2007 703.65836\n\n\nOr both:\n\ncalcGDP(gapminder, .year = 2007, .country = \"Australia\")\n\n    country year      gdp\n1 Australia 2007 703.6584\n\n\nLet’s walk through the body of the function:\n\ncalcGDP <- function(dat, .year = NULL, .country = NULL) {\n\nHere we’ve added two arguments, .year, and .country. We’ve set default arguments for both as NULL using the = operator in the function definition. We are using a period as a prefix to these arguments .year and .country to help visually differentiate between the arguemnt and the column name in dat/gapminder.\nThese arguments will take on those values unless the user specifies otherwise.\n\n  if(!is.null(.year)) {\n    dat <- dat |> filter(year %in% .year)\n  }\n  if (!is.null(.country)) {\n    dat <- dat |> filter(country %in% .country)\n  }\n\nHere, we check whether each additional argument is set to null, and whenever they’re not null overwrite the dataset stored in dat with the subset computed in body of the if statement.\nBuilding these conditionals into the function makes it more flexible for later. Now, we can use it to calculate the GDP for:\n\nThe whole dataset;\nA single year;\nA single country;\nA single combination of year and country.\n\nBy using %in% instead, we can also give multiple years or countries to those arguments.\n\n   dat <- dat |>\n    transmute(country, year, gdp = pop * gdpPercap / 1e9)\n  \n  return(dat)\n}\n\nFinally, we used transmute to both select country, year, and gdp variables and to compute the gdp variable itself.\n\n\n\n\n\n\nTip: Pass by value\n\n\n\nFunctions in R almost always make copies of the data to operate on inside of a function body. When we modify dat inside the function we are modifying the copy of the gapminder dataset stored in dat, not the original gapminder variable.\nThis is called “pass-by-value” and it makes writing code much safer: you can always be sure that whatever changes you make within the body of the function, stay inside the body of the function.\n\n\n\n\n\n\n\n\nTip: Function scope\n\n\n\nAnother important concept is scoping: any variables (or functions!) you create or modify inside the body of a function only exist for the lifetime of the function’s execution.\nWhen we call calcGDP(), the variables dat, gdp and new only exist inside the body of the function. Even if we have variables of the same name in our interactive R session, they are not modified in any way when executing a function.\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nTest out your GDP function by calculating the GDP for New Zealand in 1987 and 1952.\n\n\n\n\n\n\nSolution to challenge 4\n\n\n\n\n\n\ncalcGDP(gapminder, .year = c(1952, 1987), .country = \"New Zealand\")\n\n      country year      gdp\n1 New Zealand 1952 21.05819\n2 New Zealand 1987 63.05001\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nThe paste() function can be used to combine text together, e.g:\n\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\npaste(best_practice, collapse=\" \")\n\n[1] \"Write programs for people not computers\"\n\n\nWrite a function called fence() that takes two vectors as arguments, called text and wrapper, and prints out the text wrapped with the wrapper:\n\n\n\nThe output of the following code should be:\n\nfence(text = best_practice, wrapper=\"***\")\n\n[1] \"*** Write programs for people not computers ***\"\n\n\nNote: the paste() function has an argument called sep, which specifies the separator between text. The default is a space: ” “. The default for paste0() is no space”“.\n\n\n\n\n\n\nSolution to challenge 5\n\n\n\n\n\nThe following function will achieve our goal:\n\nfence <- function(text, wrapper){\n text <- c(wrapper, text, wrapper)\n result <- paste(text, collapse = \" \")\n return(result)\n}\nbest_practice <- c(\"Write\", \"programs\", \"for\", \"people\", \"not\", \"computers\")\nfence(text=best_practice, wrapper=\"***\")\n\n[1] \"*** Write programs for people not computers ***\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Testing and documenting\n\n\n\nIt’s important to both test functions and document them: Documentation helps you, and others, understand what the purpose of your function is, and how to use it, and its important to make sure that your function actually does what you think.\nWhen you first start out, your workflow will probably look a lot like this:\n\nWrite a function\nComment parts of the function to document its behaviour\nLoad in the source file\nExperiment with it in the console to make sure it behaves as you expect\nMake any necessary bug fixes\nRinse and repeat.\n\nFormal documentation for functions, written in separate .Rd files, gets turned into the documentation you see in help files. The roxygen2 package allows R coders to write documentation alongside the function code and then process it into the appropriate .Rd files. You will want to switch to this more formal method of writing documentation when you start writing more complicated R projects. In fact, packages are, in essence, bundles of functions with this formal documentation. Loading your own functions through source(\"functions.R\") is equivalent to loading someone else’s functions (or your own one day!) through library(\"package\").\nFormal automated tests can be written using the testthat package."
  }
]