[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Carpentry R Workshop",
    "section": "",
    "text": "Introduction\nOriginal homepage\nThis page contains the content for the R Software Carpentry workshop taught at the University of Utah on May 17-18.\nInstructors: Rebecca Barter, George Vega Yon\nThese materials have been adapted from the original Software Carpentry R for Reproducible Scientific Analysis workshop."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "01-rstudio-quarto.html#motivation",
    "href": "01-rstudio-quarto.html#motivation",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.1 Motivation",
    "text": "1.1 Motivation\nScience is a multi-step process: once you’ve designed an experiment and collected data, the real fun begins! This lesson will teach you how to start this process using R and RStudio. We will begin with raw data, perform exploratory analyses, and learn how to plot results graphically. This example starts with a dataset from gapminder.org containing population information for many countries through time. Can you read the data into R? Can you plot the population for Senegal? Can you calculate the average income for countries on the continent of Asia? By the end of these lessons you will be able to do things like plot the populations for all of these countries in under a minute!"
  },
  {
    "objectID": "01-rstudio-quarto.html#before-starting-the-workshop",
    "href": "01-rstudio-quarto.html#before-starting-the-workshop",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.2 Before Starting The Workshop",
    "text": "1.2 Before Starting The Workshop\nPlease ensure you have the latest version of R, RStudio, and Quarto installed on your machine, or that you are set up with Posit cloud (in which case everything will be installed for you). If you are having trouble installing any of the software on your local machine, we recommend that you use the Posit cloud instance that we have set up.\nNote that if you are working locally, we recommend re-installing R, RStudio, and Quarto to ensure that you have the latest version, as some features and packages used in the workshop may not work correctly (or at all) if your R, RStudio, and quarto are not up to date.\n\nDownload and install the latest version of R here\nDownload and install RStudio here\nDownload and install Quarto here"
  },
  {
    "objectID": "01-rstudio-quarto.html#introduction-to-rstudio",
    "href": "01-rstudio-quarto.html#introduction-to-rstudio",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.3 Introduction to RStudio",
    "text": "1.3 Introduction to RStudio\nThroughout this lesson, we’re going to teach you some of the fundamentals of the R language as well as some best practices for organizing code for scientific projects that will make your life easier.\nWe’ll be using RStudio: a free, open-source R Integrated Development Environment (IDE). It provides a built-in editor, works on all platforms (including on servers) and provides many advantages such as integration with version control and project management.\nBasic layout\nWhen you first open RStudio, you will be greeted by three panels:\n\nThe interactive R console/Terminal (entire left)\nEnvironment/History/Connections (tabbed in upper right)\nFiles/Plots/Packages/Help/Viewer (tabbed in lower right)\n\n\n\n\nRStudio layout\n\n\nOnce you open files, such as R scripts or quarto documents, an editor panel will also open in the top left.\n\n\n\nRStudio layout with .R file open"
  },
  {
    "objectID": "01-rstudio-quarto.html#quarto-documents",
    "href": "01-rstudio-quarto.html#quarto-documents",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.4 Quarto documents",
    "text": "1.4 Quarto documents\n\n\n\n\n\n\nQuarto documents\n\n\n\nIn this workshop, we will be saving our code in “quarto” documents (formerly R markdown documents). Quarto documents let us combine text, code, and output (such as plots and tables) into an html or pdf file. Quarto files have .qmd at the end of their names.\n\n\nQuarto documents (like their predecessor, R Markdown documents) allow you to combine text and code, so that rather than having your code standing alone in its own file, your code and its output can instead lie nestled in between narrative text that describes the analysis that you’re conducting and summarizes the results. Quarto documents are mind-blowingly versatile, and while they are mostly used to create simple html or pdf documents, they can also be used to make websites, blog posts, and books!\nSince we want to practice reproducible data science, it is important that we keep detailed records of the code that we wrote which led us to our data-driven answers. Quarto provides us with an easy way of doing that, plus since you can surround your code with text narrative, it can be used to communicate your analysis and results to other people: Quarto lets us feed two birds with one seed!\nTo start a new quarto document:\n\nHit the “New file” icon with a green plus in the top-right-hand corner of the RStudio application and select “Quarto document”. The following window should pop up:\n\n\n\n\n\n\n\nChoose a title (e.g., “My first quarto document”), and make yourself the author.\nSelect the HTML output option.\nSelect the “knitr” engine from the drop-down menu.\nUn-check “Use visual markdown editor” (if it is checked).\nHit the “Create” button to create your file.\n\nThis will open up a new quarto template document in the documents panel:\n\n\n\n\n\n\n1.4.1 Rendering quarto documents\nThe quarto file that you’ve just created contains a very brief summary of how quarto documents work. Note the instructions “When you click the Render button a document will be generated that includes both content and the output of embedded code.”\nIf you hit “Render” button while your quarto document is open, you should see that some code appeared very quickly in your console panel and your web browser opened up with a new (html) webpage titled “My first quarto document” that looks like this:\n\n\n\n\n\nIf you’re using RStudio in the cloud (or you have different settings to me), you may have instead found that the window opened in the “Viewer” panel of your RStudio application. If no window opened anywhere, find the analysis.html file on your computer that was created when you hit “Render”, and open it in your web browser.\nHitting the “Render” button “renders” your interactive quarto (.qmd) document as a static html (.html) file. This is like saving your interactive word document file as a static pdf file. Compare the original quarto (.qmd) document with the rendered web-browser page (.html). If you’re viewing the .qmd file in visual mode, they should look fairly similar.\n\n\n\n\n\n\nSimplifying quarto output files\n\n\n\nWhen you compile quarto document, you will find that a number of superfluous files are created in a xx_files/ folder, and this folder is required for the .html output to be rendered properly (i.e., the formatting in the .html file will be lost if you separate the .html output file from the xx_files/ folder).\nYou can fix this by “embedding” these resource files inside the rendered html output document by specifying embed-resources: true in the “yaml” (document settings) at the top of the quarto document.\n---\ntitle: \"Introduction to R and RStudio\"\noutput: html\nembed-resources: true\n---\nWith this option, the xx_files/ folder will no longer be created and the html file will be properly rendered as a stand-alone file.\n\n\n\n1.4.1.1 Markdown text\nBased on the html output, let’s try to make some sense of the syntax used in the original quarto (.qmd) document. The text in a quarto document uses markdown syntax.\nCan you figure out what the ## syntax does (if you can’t see the ## syntax, ensure that you are viewing the quarto document using “Source” rather than “Visual” in the top-right corner of the document)? The pound symbols are markdown syntax for creating headers: # will create a top-level header, ## will create a level-2 header, ### will create a level-3 header, etc.\nNotice that the word “Render” is shown in bold in the rendered html file. By looking at the .qmd file, can you figure out what the markdown syntax is for creating bold-face text?\nTo learn more about markdown syntax, see https://www.markdownguide.org/basic-syntax/."
  },
  {
    "objectID": "01-rstudio-quarto.html#writing-code-in-quarto-documents",
    "href": "01-rstudio-quarto.html#writing-code-in-quarto-documents",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.5 Writing code in quarto documents",
    "text": "1.5 Writing code in quarto documents\n\n1.5.1 Code chunks\nAt this stage, much of quarto’s power (like its predecessor, R Markdown) lies in combining text with “code chunks”. Take a look at your analysis.qmd file. This file already contains two code chunks indicated by the following syntax:\n```{r}\n\n```\n```{r} tells quarto that you’re beginning an R “code chunk”, i.e., you’re about to write some R code, and ``` tells quarto that you’re done with R and are going back to writing regular (markdown) text.\nNote in the compiled markdown document, this R code chunk rendered as:\n\n1 + 1\n\n[1] 2\n\n\nIn the rendered html file, the output ([1] 2) of the R code being evaluated (1 + 1) is shown below the code itself (note also that while the code is shown in the html output, the backtick syntax is hidden).\nWhy is there a [1] before the output ([1] 2)? This is just specifying that 2 is the first “entry” of the output.\nNote that in the second code chunk, there is a “code chunk option” specified: #| echo: false .\n```{r}\n#| echo: false\n2 * 2\n```\nThis #| syntax at the beginning of a code chunk corresponds to various options for when the code chunk is “rendered” into html (or pdf).\nBy looking at the output html file, can you figure out what #| echo: false does?\nIt hides the code from the html output file, while still showing the output ([1] 4). Sometimes, depending on the type of document you’re creating and who your intended audience is, it is often helpful to hide the code, but still show the output (e.g., figures or tables) of your R code in the document.\n\n\n1.5.2 Code comments\nNote that another use of the # symbol in an R code chunk is as a code comment (in this case, # will not be followed by |). Code comments will be shown with your code chunk but don’t do anything other than add some text alongside your code, which is often helpful for explaining what a piece of code is doing when it’s not obvious.\n\n\n[1] 4"
  },
  {
    "objectID": "01-rstudio-quarto.html#the-console",
    "href": "01-rstudio-quarto.html#the-console",
    "title": "1  Introduction to RStudio and quarto",
    "section": "1.6 The console",
    "text": "1.6 The console\nRather than compiling your quarto document every time you want to look at the output of the code in your quarto document, you can instead run individual chunks of your code in the R console.\n\n\n\n\n\n\nTip: Running segments of your code in the console\n\n\n\nRStudio offers you great flexibility in running code from within the editor window. There are buttons, menu choices, and keyboard shortcuts. To run the current line of code inside a code chunk, you can 1. click on the Run button above the editor panel, or 2. select “Run Lines” from the “Code” menu, or 3. hit Ctrl+Return in Windows or Linux or ⌘+Return on OS X. (This shortcut can also be seen by hovering the mouse over the button).\n\n\nThe first thing you will see in the R console (interactive session) is a bunch of information, followed by a “>” and a blinking cursor. In many ways this is similar to the shell environment you learned about during the shell lessons: it operates on the same idea of a “Read, evaluate, print loop”: you type in commands, R tries to execute them, and then returns a result.\nIf you type in an incomplete command, R will wait for you to complete it. If you are familiar with Unix Shell’s bash, you may recognize this\nbehavior from bash.\n\n\n\n\n\nAny time you hit return and the R session shows a “+” instead of a “>”, it means it’s waiting for you to complete the command. If you want to cancel a command you can hit Esc and RStudio will give you back the “>” prompt.\n\n\n\n\n\n\nTip: Canceling commands\n\n\n\nIf you’re using R from the command line instead of from within RStudio, you need to use Ctrl+C instead of Esc to cancel the command. This applies to Mac users as well! Canceling a command isn’t only useful for killing incomplete commands: you can also use it to tell R to stop running code (for example if it’s taking much longer than you expect), or to get rid of the code you’re currently writing."
  },
  {
    "objectID": "05-data-structures-part2.html#adding-columns-and-rows-in-data-frames",
    "href": "05-data-structures-part2.html#adding-columns-and-rows-in-data-frames",
    "title": "5  Exploring Data Frames",
    "section": "5.1 Adding columns and rows in data frames",
    "text": "5.1 Adding columns and rows in data frames\nWe already learned that the columns of a data frame are vectors, so that our data are consistent in type throughout the columns. As such, if we want to add a new column, we can start by making a new vector:\n\n\n\n\nage <- c(2, 3, 5)\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\nWe can then add this as a column via:\n\ncbind(cats, age)\n\n    coat weight likes_string age\n1 calico    2.1            1   2\n2  black    5.0            0   3\n3  tabby    3.2            1   5\n\n\nNote that if we tried to add a vector of ages with a different number of entries than the number of rows in the data frame, it would fail:\n\nage <- c(2, 3, 5, 12)\ncbind(cats, age)\n\nError in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 3, 4\n\nage <- c(2, 3)\ncbind(cats, age)\n\nError in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 3, 2\n\n\nWhy didn’t this work? Of course, R wants to see one element in our new column for every row in the table:\n\nnrow(cats)\n\n[1] 3\n\nlength(age)\n\n[1] 2\n\n\nSo for it to work we need to have nrow(cats) = length(age). Let’s overwrite the content of cats with our new data frame.\n\nage <- c(2, 3, 5)\ncats <- cbind(cats, age)\n\nNow how about adding rows?\n\nnewRow <- list(\"tortoiseshell\", 3.3, TRUE, 9)\ncats <- rbind(cats, newRow)\n\nWarning in `[<-.factor`(`*tmp*`, ri, value = \"tortoiseshell\"): invalid factor\nlevel, NA generated\n\n\nLooks like our attempt to use the rbind() function returns a warning. Recall that, unlike errors, warnings do not necessarily stop a function from performing its intended action. You can confirm this by taking a look at the cats data frame.\n\ncats\n\n    coat weight likes_string age\n1 calico    2.1            1   2\n2  black    5.0            0   3\n3  tabby    3.2            1   5\n4   <NA>    3.3            1   9\n\n\nNotice that not only did we successfully add a new row, but there is NA in the column coats where we expected “tortoiseshell” to be. Why did this happen?"
  },
  {
    "objectID": "05-data-structures-part2.html#factors",
    "href": "05-data-structures-part2.html#factors",
    "title": "5  Exploring Data Frames",
    "section": "5.2 Factors",
    "text": "5.2 Factors\nFor an object containing the data type factor, each different value represents what is called a level. In our case, the factor “coat” has 3 levels: “black”, “calico”, and “tabby”. R will only accept values that match one of the levels. If you add a new value, it will become NA.\nThe warning is telling us that we unsuccessfully added “tortoiseshell” to our coat factor, but 3.3 (a numeric), TRUE (a logical), and 9 (a numeric) were successfully added to weight, likes_string, and age, respectively, since those variables are not factors. To successfully add a cat with a “tortoiseshell” coat, add “tortoiseshell” as a possible level of the factor:\n\nlevels(cats$coat)\n\n[1] \"black\"  \"calico\" \"tabby\" \n\nlevels(cats$coat) <- c(levels(cats$coat), \"tortoiseshell\")\ncats <- rbind(cats, list(\"tortoiseshell\", 3.3, TRUE, 9))\n\nAlternatively, we can change a factor into a character vector; we lose the handy categories of the factor, but we can subsequently add any word we want to the column without babysitting the factor levels:\n\nstr(cats)\n\n'data.frame':   5 obs. of  4 variables:\n $ coat        : Factor w/ 4 levels \"black\",\"calico\",..: 2 1 3 NA 4\n $ weight      : num  2.1 5 3.2 3.3 3.3\n $ likes_string: int  1 0 1 1 1\n $ age         : num  2 3 5 9 9\n\ncats$coat <- as.character(cats$coat)\nstr(cats)\n\n'data.frame':   5 obs. of  4 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\" NA ...\n $ weight      : num  2.1 5 3.2 3.3 3.3\n $ likes_string: int  1 0 1 1 1\n $ age         : num  2 3 5 9 9\n\n\n\n\n\n\n\n\nChallenge 1\n\n\n\nLet’s imagine that 1 cat year is equivalent to 7 human years.\n\nCreate a vector called human_age by multiplying cats$age by 7.\nConvert human_age to a factor.\nConvert human_age back to a numeric vector using the as.numeric() function. Now divide it by 7 to get the original ages back. Explain what happened.\n\n\n\n\n\n\n\nSolution to Challenge 1\n\n\n\n\n\n\nhuman_age <- cats$age * 7\nhuman_age <- factor(human_age). as.factor(human_age) works just as well.\nas.numeric(human_age) yields 1 2 3 4 4 because factors are stored as integers (here, 1:4), each of which is associated with a label (here, 28, 35, 56, and 63). Converting the factor to a numeric vector gives us the underlying integers, not the labels. If we want the original numbers, we need to convert human_age to a character vector (using as.character(human_age)) and then to a numeric vector (why does this work?). This comes up in real life when we accidentally include a character somewhere in a column of a .csv file supposed to only contain numbers, and set stringsAsFactors=TRUE when we read in the data."
  },
  {
    "objectID": "05-data-structures-part2.html#removing-rows",
    "href": "05-data-structures-part2.html#removing-rows",
    "title": "5  Exploring Data Frames",
    "section": "5.3 Removing rows",
    "text": "5.3 Removing rows\nWe now know how to add rows and columns to our data frame in R—but in our first attempt to add a “tortoiseshell” cat to the data frame we have accidentally added a garbage row:\n\ncats\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n4          <NA>    3.3            1   9\n5 tortoiseshell    3.3            1   9\n\n\nWe can ask for a data frame minus this offending row:\n\ncats[-4, ]\n\n           coat weight likes_string age\n1        calico    2.1            1   2\n2         black    5.0            0   3\n3         tabby    3.2            1   5\n5 tortoiseshell    3.3            1   9\n\n\nNotice the comma with nothing after it to indicate that we want to drop the entire fourth row.\nNote: we could also remove both new rows at once by putting the row numbers inside of a vector using c(): cats[c(-4,-5), ]"
  },
  {
    "objectID": "05-data-structures-part2.html#removing-columns",
    "href": "05-data-structures-part2.html#removing-columns",
    "title": "5  Exploring Data Frames",
    "section": "5.4 Removing columns",
    "text": "5.4 Removing columns\nWe can also remove columns in our data frame. What if we want to remove the column “age”. We can remove it in two ways, by variable number or by index.\n\ncats[, -4]\n\n           coat weight likes_string\n1        calico    2.1            1\n2         black    5.0            0\n3         tabby    3.2            1\n4          <NA>    3.3            1\n5 tortoiseshell    3.3            1\n\n\nNotice the comma with nothing before it, indicating we want to keep all of the rows.\nAlternatively, we can drop the column by using the index name and the %in% operator. The %in% operator goes through each element of its left argument, in this case the names of cats, and asks, “Does this element occur in the second argument?”\n\ndrop <- names(cats) %in% c(\"age\")\ncats[, !drop]\n\n           coat weight likes_string\n1        calico    2.1            1\n2         black    5.0            0\n3         tabby    3.2            1\n4          <NA>    3.3            1\n5 tortoiseshell    3.3            1\n\n\nWe will cover subsetting with logical operators like %in% in more detail in the next episode. See the section Subsetting through other logical operations"
  },
  {
    "objectID": "05-data-structures-part2.html#appending-to-a-data-frame",
    "href": "05-data-structures-part2.html#appending-to-a-data-frame",
    "title": "5  Exploring Data Frames",
    "section": "5.5 Appending to a data frame",
    "text": "5.5 Appending to a data frame\nThe key to remember when adding data to a data frame is that columns are vectors and rows are lists. We can also glue two data frames together with rbind:\n\ncats <- rbind(cats, cats)\ncats\n\n            coat weight likes_string age\n1         calico    2.1            1   2\n2          black    5.0            0   3\n3          tabby    3.2            1   5\n4           <NA>    3.3            1   9\n5  tortoiseshell    3.3            1   9\n6         calico    2.1            1   2\n7          black    5.0            0   3\n8          tabby    3.2            1   5\n9           <NA>    3.3            1   9\n10 tortoiseshell    3.3            1   9\n\n\nBut now the row names are unnecessarily complicated. We can remove the rownames, and R will automatically re-name them sequentially:\n\nrownames(cats) <- NULL\ncats\n\n            coat weight likes_string age\n1         calico    2.1            1   2\n2          black    5.0            0   3\n3          tabby    3.2            1   5\n4           <NA>    3.3            1   9\n5  tortoiseshell    3.3            1   9\n6         calico    2.1            1   2\n7          black    5.0            0   3\n8          tabby    3.2            1   5\n9           <NA>    3.3            1   9\n10 tortoiseshell    3.3            1   9\n\n\n\n\n\n\n\n\nChallenge 2\n\n\n\nYou can create a new data frame right from within R with the following syntax:\n\ndf <- data.frame(id = c(\"a\", \"b\", \"c\"),\n                x = 1:3,\n                y = c(TRUE, TRUE, FALSE))\n\nMake a data frame that holds the following information for yourself:\n\nfirst name\nlast name\nlucky number\n\nThen use rbind to add an entry for the people sitting beside you. Finally, use cbind to add a column with each person’s answer to the question, “Is it time for coffee break?”\n\n\n\n\n\n\nSolution to Challenge 2\n\n\n\n\n\n\ndf <- data.frame(first = c(\"Grace\"),\n                last = c(\"Hopper\"),\n                lucky_number = c(0))\ndf <- rbind(df, list(\"Marie\", \"Curie\", 238) )\ndf <- cbind(df, coffeetime = c(TRUE,TRUE))"
  },
  {
    "objectID": "05-data-structures-part2.html#realistic-example",
    "href": "05-data-structures-part2.html#realistic-example",
    "title": "5  Exploring Data Frames",
    "section": "5.6 Realistic example",
    "text": "5.6 Realistic example\nSo far, you have seen the basics of manipulating data frames with our cat data; now let’s use those skills to digest a more realistic dataset. Let’s read in the gapminder dataset that we downloaded previously:\n\ngapminder <- read.csv(\"data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\n\n\n\n\n\n\nMiscellaneous Tips\n\n\n\n\nAnother type of file you might encounter are tab-separated value files (.tsv). To specify a tab as a separator, use \"\\\\t\" or read.delim().\nFiles can also be downloaded directly from the Internet into a local folder of your choice onto your computer using the download.file function.\n\nThe read.csv function can then be executed to read the downloaded file from the download location, for example,\n\ndownload.file(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv\", destfile = \"data/gapminder_data.csv\")\ngapminder <- read.csv(\"data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\n\nAlternatively, you can also read in files directly into R from the Internet by replacing the file paths with a web address in read.csv. One should note that in doing this no local copy of the csv file is first saved onto your computer. For example,\n\n\ngapminder <- read.csv(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\n\nYou can read directly from excel spreadsheets without converting them to plain text first by using the readxl package.\n\n\n\nLet’s investigate gapminder a bit; the first thing we should always do is check out what the data looks like with str:\n\nstr(gapminder)\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\nAn additional method for examining the structure of gapminder is to use the summary function. This function can be used on various objects in R. For data frames, summary yields a numeric, tabular, or descriptive summary of each column. Factor columns are summarized by the number of items in each level, numeric or integer columns by the descriptive statistics (quartiles and mean), and character columns by its length, class, and mode.\n\nsummary(gapminder$country)\n\n             Afghanistan                  Albania                  Algeria \n                      12                       12                       12 \n                  Angola                Argentina                Australia \n                      12                       12                       12 \n                 Austria                  Bahrain               Bangladesh \n                      12                       12                       12 \n                 Belgium                    Benin                  Bolivia \n                      12                       12                       12 \n  Bosnia and Herzegovina                 Botswana                   Brazil \n                      12                       12                       12 \n                Bulgaria             Burkina Faso                  Burundi \n                      12                       12                       12 \n                Cambodia                 Cameroon                   Canada \n                      12                       12                       12 \nCentral African Republic                     Chad                    Chile \n                      12                       12                       12 \n                   China                 Colombia                  Comoros \n                      12                       12                       12 \n         Congo Dem. Rep.               Congo Rep.               Costa Rica \n                      12                       12                       12 \n           Cote d'Ivoire                  Croatia                     Cuba \n                      12                       12                       12 \n          Czech Republic                  Denmark                 Djibouti \n                      12                       12                       12 \n      Dominican Republic                  Ecuador                    Egypt \n                      12                       12                       12 \n             El Salvador        Equatorial Guinea                  Eritrea \n                      12                       12                       12 \n                Ethiopia                  Finland                   France \n                      12                       12                       12 \n                   Gabon                   Gambia                  Germany \n                      12                       12                       12 \n                   Ghana                   Greece                Guatemala \n                      12                       12                       12 \n                  Guinea            Guinea-Bissau                    Haiti \n                      12                       12                       12 \n                Honduras          Hong Kong China                  Hungary \n                      12                       12                       12 \n                 Iceland                    India                Indonesia \n                      12                       12                       12 \n                    Iran                     Iraq                  Ireland \n                      12                       12                       12 \n                  Israel                    Italy                  Jamaica \n                      12                       12                       12 \n                   Japan                   Jordan                    Kenya \n                      12                       12                       12 \n         Korea Dem. Rep.               Korea Rep.                   Kuwait \n                      12                       12                       12 \n                 Lebanon                  Lesotho                  Liberia \n                      12                       12                       12 \n                   Libya               Madagascar                   Malawi \n                      12                       12                       12 \n                Malaysia                     Mali               Mauritania \n                      12                       12                       12 \n               Mauritius                   Mexico                 Mongolia \n                      12                       12                       12 \n              Montenegro                  Morocco               Mozambique \n                      12                       12                       12 \n                 Myanmar                  Namibia                    Nepal \n                      12                       12                       12 \n             Netherlands              New Zealand                Nicaragua \n                      12                       12                       12 \n                   Niger                  Nigeria                   Norway \n                      12                       12                       12 \n                    Oman                 Pakistan                   Panama \n                      12                       12                       12 \n                 (Other) \n                     516 \n\n\nAlong with the str() and summary() functions, we can examine individual columns of the data frame with our class() function:\n\nclass(gapminder$year)\n\n[1] \"integer\"\n\nclass(gapminder$country)\n\n[1] \"factor\"\n\nstr(gapminder$country)\n\n Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n\nWe can also interrogate the data frame for information about its dimensions; remembering that str(gapminder) said there were 1704 observations of 6 variables in gapminder, what do you think the following will produce, and why?\n\nlength(gapminder)\n\n[1] 6\n\n\nA fair guess would have been to say that the length of a data frame would be the number of rows it has (1704), but this is not the case; remember, a data frame is a list of vectors and factors. When length gave us 6, it’s because gapminder is built out of a list of 6 columns. To get the number of rows and columns in our dataset, try:\n\nnrow(gapminder)\n\n[1] 1704\n\nncol(gapminder)\n\n[1] 6\n\n\nOr, both at once:\n\ndim(gapminder)\n\n[1] 1704    6\n\n\nWe’ll also likely want to know what the titles of all the columns are, so we can ask for them later:\n\ncolnames(gapminder)\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nAt this stage, it’s important to ask ourselves if the structure R is reporting matches our intuition or expectations; do the basic data types reported for each column make sense? If not, we need to sort any problems out now before they turn into bad surprises down the road, using what we’ve learned about how R interprets data, and the importance of strict consistency in how we record our data.\nOnce we’re happy that the data types and structures seem reasonable, it’s time to start digging into our data proper. Check out the first few lines:\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\n\n\n\n\n\n\nChallenge 3\n\n\n\nIt’s good practice to also check the last few lines of your data and some in the middle. How would you do this? Searching for ones specifically in the middle isn’t too hard, but we could ask for a few lines at random. How would you code this?\n\n\n\n\n\n\nSolution to Challenge 3\n\n\n\n\n\nTo check the last few lines it’s relatively simple as R already has a function for this:\n\ntail(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\ntail(gapminder, n = 15)\n\n      country year      pop continent lifeExp gdpPercap\n1690   Zambia 1997  9417789    Africa  40.238 1071.3538\n1691   Zambia 2002 10595811    Africa  39.193 1071.6139\n1692   Zambia 2007 11746035    Africa  42.384 1271.2116\n1693 Zimbabwe 1952  3080907    Africa  48.451  406.8841\n1694 Zimbabwe 1957  3646340    Africa  50.469  518.7643\n1695 Zimbabwe 1962  4277736    Africa  52.358  527.2722\n1696 Zimbabwe 1967  4995432    Africa  53.995  569.7951\n1697 Zimbabwe 1972  5861135    Africa  55.635  799.3622\n1698 Zimbabwe 1977  6642107    Africa  57.674  685.5877\n1699 Zimbabwe 1982  7636524    Africa  60.363  788.8550\n1700 Zimbabwe 1987  9216418    Africa  62.351  706.1573\n1701 Zimbabwe 1992 10704340    Africa  60.377  693.4208\n1702 Zimbabwe 1997 11404948    Africa  46.809  792.4500\n1703 Zimbabwe 2002 11926563    Africa  39.989  672.0386\n1704 Zimbabwe 2007 12311143    Africa  43.487  469.7093\n\n\nWhat about a few arbitrary rows just in case something is odd in the middle?\n\n5.7 Tip: There are several ways to achieve this.\nThe solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!\nRemember my_dataframe[rows, cols] will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don’t know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.\n\ngapminder[sample(nrow(gapminder), 5), ]\n\n         country year      pop continent lifeExp gdpPercap\n1648     Vietnam 1967 39463910      Asia  47.838  637.1233\n1419       Spain 1962 31158061    Europe  69.690 5693.8439\n473  El Salvador 1972  3790903  Americas  58.207 4520.2460\n623       Guinea 2002  8807818    Africa  53.676  945.5836\n285        Chile 1992 13572994  Americas  74.126 7596.1260\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 4\n\n\n\nGo to file -> new file -> R script, and write an R script to load in the gapminder dataset. Put it in the scripts/ directory and add it to version control.\nRun the script using the source function, using the file path as its argument (or by pressing the “source” button in RStudio).\n\n\n\n\n\n\nSolution to Challenge 4\n\n\n\n\n\nThe source function can be used to use a script within a script. Assume you would like to load the same type of file over and over again and therefore you need to specify the arguments to fit the needs of your file. Instead of writing the necessary argument again and again you could just write it once and save it as a script. Then, you can use source(\"Your_Script_containing_the_load_function\") in a new script to use the function of that script without writing everything again. Check out ?source to find out more.\n\ndownload.file(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv\", destfile = \"data/gapminder_data.csv\")\ngapminder <- read.csv(file = \"data/gapminder_data.csv\", stringsAsFactors = TRUE)\n\nTo run the script and load the data into the gapminder variable:\n\nsource(file = \"scripts/load-gapminder.R\")\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge 5\n\n\n\nRead the output of str(gapminder) again; this time, use what you’ve learned about factors, lists and vectors, as well as the output of functions like colnames and dim to explain what everything that str prints out for gapminder means. If there are any parts you can’t interpret, discuss with your neighbors!\n\n\n\n\n\n\nSolution to Challenge 5\n\n\n\n\n\nThe object gapminder is a data frame with columns - country and continent are factors. - year is an integer vector. - pop, lifeExp, and gdpPercap are numeric vectors."
  },
  {
    "objectID": "05-data-structures-part2.html#tip-there-are-several-ways-to-achieve-this.",
    "href": "05-data-structures-part2.html#tip-there-are-several-ways-to-achieve-this.",
    "title": "5  Exploring Data Frames",
    "section": "5.7 Tip: There are several ways to achieve this.",
    "text": "5.7 Tip: There are several ways to achieve this.\nThe solution here presents one form of using nested functions, i.e. a function passed as an argument to another function. This might sound like a new concept, but you are already using it!\nRemember my_dataframe[rows, cols] will print to screen your data frame with the number of rows and columns you asked for (although you might have asked for a range or named columns for example). How would you get the last row if you don’t know how many rows your data frame has? R has a function for this. What about getting a (pseudorandom) sample? R also has a function for this.\n\ngapminder[sample(nrow(gapminder), 5), ]\n\n         country year      pop continent lifeExp gdpPercap\n1648     Vietnam 1967 39463910      Asia  47.838  637.1233\n1419       Spain 1962 31158061    Europe  69.690 5693.8439\n473  El Salvador 1972  3790903  Americas  58.207 4520.2460\n623       Guinea 2002  8807818    Africa  53.676  945.5836\n285        Chile 1992 13572994  Americas  74.126 7596.1260"
  }
]